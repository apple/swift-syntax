%{
  from gyb_syntax_support import *
  # -*- mode: Swift -*-
  # Ignore the following admonition; it applies to the resulting .swift file only
}%
//// Automatically Generated From RawSyntaxValidation.swift.gyb.
//// Do Not Edit Directly!
//===----------- RawSyntaxValidation.swift - Layout validation ------------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2022 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

%{
def get_verify_call(idx, child, is_optional):
  question_mark = "?" if is_optional else ""
  if child.is_token():
    token_choices = ', '.join([f'.{token.swift_kind()}' for token in child.token_choices])
    text_choices = ', '.join([f'"{text}"' for text in child.text_choices])
    return f"verify(layout[{idx}], as: Raw{child.type_name}{question_mark}.self, tokenChoices: [{token_choices}], textChoices: [{text_choices}])"
  else:
    return f"verify(layout[{idx}], as: Raw{child.type_name}{question_mark}.self)"
}%

/// Check that the `layout` is valid for the given 'SyntaxKind'.
///
/// Note that this only validates the immediate children.
/// Results in an assertion failure if the layout is invalid.
func validateLayout(layout: RawSyntaxBuffer, as kind: SyntaxKind) {
#if DEBUG
  enum ValidationError: CustomStringConvertible {
    case expectedNonNil(expectedKind: RawSyntaxNodeProtocol.Type, file: StaticString, line: UInt)
    case kindMismatch(expectedKind: RawSyntaxNodeProtocol.Type, actualKind: SyntaxKind, file: StaticString, line: UInt)
    case mismatchedTokenKindChoices(expectedKinds: [RawTokenKind], actualKind: RawTokenKind, file: StaticString, line: UInt)
    case mismatchedTokenTextChoices(expectedTexts: [SyntaxText], actualText: SyntaxText, file: StaticString, line: UInt)

    var description: String {
      switch self {
      case .expectedNonNil(expectedKind: let expectedKind, file: _, line: _):
        return "Expected non-nil node of type \(expectedKind) but received nil"
      case .kindMismatch(expectedKind: let expectedKind, actualKind: let actualKind, file: _, line: _):
        return "Expected node of type \(expectedKind) but received \(actualKind)"
      case .mismatchedTokenKindChoices(expectedKinds: let expectedKinds, actualKind: let actualKind, file: _, line: _):
        return "Expected token of kind \(expectedKinds) but received \(actualKind)"
      case .mismatchedTokenTextChoices(expectedTexts: let expectedTexts, actualText: let actualText, file: _, line: _):
        return "Expected token with text \(expectedTexts) but received \(actualText)"
      }
    }

    var fileAndLine: (StaticString, UInt) {
      switch self {
      case .expectedNonNil(expectedKind: _, file: let file, line: let line):
        return (file, line)
      case .kindMismatch(expectedKind: _, actualKind: _, file: let file, line: let line):
        return (file, line)
      case .mismatchedTokenKindChoices(expectedKinds: _, actualKind: _, file: let file, line: let line):
        return (file, line)
      case .mismatchedTokenTextChoices(expectedTexts: _, actualText: _, file: let file, line: let line):
        return (file, line)
      }
    }
  }

  func verify<Node: RawSyntaxNodeProtocol>(_ raw: RawSyntax?, as _: Node.Type, file: StaticString = #file, line: UInt = #line) -> ValidationError? {
    guard let raw = raw else {
      return .expectedNonNil(expectedKind: Node.self, file: file, line: line)
    }
    guard Node.isKindOf(raw) else {
      return .kindMismatch(expectedKind: Node.self, actualKind: raw.kind, file: file, line: line)
    }
    return nil
  }

  func verify<Node: RawSyntaxNodeProtocol>(_ raw: RawSyntax?, as _: Node?.Type, file: StaticString = #file, line: UInt = #line) -> ValidationError? {
    if raw != nil {
      return verify(raw, as: Node.self, file: file, line: line)
    }
    return nil
  }

  func verify(_ raw: RawSyntax?, as: RawTokenSyntax.Type, tokenChoices: [RawTokenKind], textChoices: [SyntaxText], file: StaticString = #file, line: UInt = #line) -> ValidationError? {
    guard let raw = raw else {
      return .expectedNonNil(expectedKind: RawTokenSyntax.self, file: file, line: line)
    }
    guard let token = raw.as(RawTokenSyntax.self) else {
      return .kindMismatch(expectedKind: RawTokenSyntax.self, actualKind: raw.kind, file: file, line: line)
    }
    guard tokenChoices.isEmpty || tokenChoices.contains(token.tokenKind) else {
      return .mismatchedTokenKindChoices(expectedKinds: tokenChoices, actualKind: token.tokenKind, file: file, line: line)
    }
    guard textChoices.isEmpty || textChoices.contains(token.tokenText) else {
      return .mismatchedTokenTextChoices(expectedTexts: textChoices, actualText: token.tokenText, file: file, line: line)
    }
    return nil
  }

  func verify(_ raw: RawSyntax?, as: RawTokenSyntax?.Type, tokenChoices: [RawTokenKind], textChoices: [SyntaxText], file: StaticString = #file, line: UInt = #line) -> ValidationError? {
    if raw != nil {
      return verify(raw, as: RawTokenSyntax.self, tokenChoices: tokenChoices, textChoices: textChoices, file: file, line: line)
    }
    return nil
  }

  func assertNoError(_ nodeKind: SyntaxKind, _ index: Int, _ error: ValidationError?) {
    if let error = error {
      let (file, line) = error.fileAndLine
      assertionFailure("""
        Error validating child at index \(index) of \(nodeKind):
        \(error.description)
        """, file: file, line: line)
    }
  }

  func assertAnyHasNoError(_ nodeKind: SyntaxKind, _ index: Int, _ errors: [ValidationError?]) {
    let nonNilErrors = errors.compactMap({ $0 })
    if nonNilErrors.count == errors.count, let firstError = nonNilErrors.first {
      let (file, line) = firstError.fileAndLine
      assertionFailure("""
        Error validating child at index \(index) of \(nodeKind):
        Node did not satisfy any node choice requirement.
        Validation failures:
        \(nonNilErrors.map({ "- \($0.description)" }).joined(separator: "\n") )
        """, file: file, line: line)
    }
  }

  switch kind {
  case .unknown:
    break
  case .token:
    assertionFailure("validateLayout for .token kind is not supported")
% for node in NON_BASE_SYNTAX_NODES:
  case .${node.swift_syntax_kind}:
%   if node.is_buildable() or node.is_missing():
    assert(layout.count == ${len(node.children)})
%     for (idx, child) in enumerate(node.children):
%       if child.node_choices:
    assertAnyHasNoError(kind, ${idx}, [
%         for node_choice in child.node_choices:
      ${get_verify_call(idx, node_choice, child.is_optional)},
%         end
    ])
%       else:
    assertNoError(kind, ${idx}, ${get_verify_call(idx, child, child.is_optional)})
%       end
%     end
%   elif node.is_syntax_collection():
    for (index, element) in layout.enumerated() {
      assertNoError(kind, index, verify(element, as: Raw${node.collection_element_type}.self))
    }
%   end
    break
% end
  }
#endif
}
