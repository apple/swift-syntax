//// Automatically Generated From SyntaxNodes.swift.gyb.
//// Do Not Edit Directly!
//===------------ SyntaxNodes.swift - Syntax Node definitions -------------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2017 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

import _InternalSwiftSyntaxParser


/// Provide all the cusotmised casting functions for Syntax nodes
extension Syntax {
  public func `is`<S: SyntaxProtocol>(_ syntaxType: S.Type) -> Bool {
    return self.as(syntaxType) != nil
  }

  public func `as`<S: SyntaxProtocol>(_ syntaxType: S.Type) -> S? {
    return S.init(self)
  }
}

/// A wrapper around a raw Syntax layout.
public struct UnknownSyntax: SyntaxProtocol {
  public let _syntaxNode: Syntax

  /// Convert the given `Syntax` node to an `UnknownSyntax` if possible. Return 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .unknown else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates an `UnknownSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .unknown)
    self._syntaxNode = Syntax(data)
  }
}

extension UnknownSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [:])
  }
}

/// A Syntax node representing a single token.
public struct TokenSyntax: SyntaxProtocol {
  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `TokenSyntax` if possible. Returns
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .token else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a Syntax node from the given `SyntaxData`. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .token)
    self._syntaxNode = Syntax(data)
  }

  public var presence: SourcePresence {
    return raw.presence
  }

  /// The text of the token as written in the source code.
  public var text: String {
    return tokenKind.text
  }

  /// Returns a new TokenSyntax with its kind replaced
  /// by the provided token kind.
  public func withKind(_ tokenKind: TokenKind) -> TokenSyntax {
    guard raw.kind == .token else {
      fatalError("TokenSyntax must have token as its raw")
    }
    let newRaw = RawSyntax.createAndCalcLength(kind: tokenKind,
      leadingTrivia: raw.formLeadingTrivia()!, trailingTrivia: raw.formTrailingTrivia()!,
      presence: raw.presence)
    let newData = data.replacingSelf(newRaw)
    return TokenSyntax(newData)
  }

  /// Returns a new TokenSyntax with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> TokenSyntax {
    guard raw.kind == .token else {
      fatalError("TokenSyntax must have token as its raw")
    }
    return TokenSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new TokenSyntax with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> TokenSyntax {
    guard raw.kind == .token else {
      fatalError("TokenSyntax must have token as its raw")
    }
    return TokenSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new TokenSyntax with its leading trivia removed.
  public func withoutLeadingTrivia() -> TokenSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new TokenSyntax with its trailing trivia removed.
  public func withoutTrailingTrivia() -> TokenSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new TokenSyntax with all trivia removed.
  public func withoutTrivia() -> TokenSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this token.
  public var leadingTrivia: Trivia {
    get {
      return raw.formTokenLeadingTrivia()!
    }
    set {
      self = withLeadingTrivia(newValue)
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this token.
  public var trailingTrivia: Trivia {
    get {
      return raw.formTokenTrailingTrivia()!
    }
    set {
      self = withTrailingTrivia(newValue)
    }
  }

  /// The kind of token this node represents.
  public var tokenKind: TokenKind {
    get {
      return raw.formTokenKind()!
    }
    set {
      self = withKind(newValue)
    }
  }

  /// The length this node takes up spelled out in the source, excluding its
  /// leading or trailing trivia.
  public var contentLength: SourceLength {
    return raw.tokenContentLength
  }

  /// The length this node's leading trivia takes up spelled out in source.
  public var leadingTriviaLength: SourceLength {
    return raw.tokenLeadingTriviaLength
  }

  /// The length this node's trailing trivia takes up spelled out in source.
  public var trailingTriviaLength: SourceLength {
    return raw.tokenTrailingTriviaLength
  }

  /// The length of this node including all of its trivia.
  public var totalLength: SourceLength {
    return raw.totalLength
  }
}

extension TokenSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "text": text,
      "leadingTrivia": leadingTrivia,
      "trailingTrivia": trailingTrivia,
      "tokenKind": tokenKind,
    ])
  }
}


/// Protocol to which all `DeclSyntax` nodes conform. Extension point to add
/// common methods to all `DeclSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol DeclSyntaxProtocol: SyntaxProtocol {}

public struct DeclSyntax: DeclSyntaxProtocol {
  public let _syntaxNode: Syntax

  public init<S: DeclSyntaxProtocol>(_ syntax: S) {
    // We know this cast is going to succeed. Go through init(_: SyntaxData)
    // to do a sanity check and verify the kind matches in debug builds and get
    // maximum performance in release builds.
    self.init(syntax._syntaxNode.data)
  }

  /// Converts the given `Syntax` node to a `DeclSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    switch syntax.raw.kind {
    case .unknownDecl, .typealiasDecl, .associatedtypeDecl, .ifConfigDecl, .poundErrorDecl, .poundWarningDecl, .poundSourceLocation, .classDecl, .structDecl, .protocolDecl, .extensionDecl, .functionDecl, .initializerDecl, .deinitializerDecl, .subscriptDecl, .importDecl, .accessorDecl, .variableDecl, .enumCaseDecl, .enumDecl, .operatorDecl, .precedenceGroupDecl:
      self._syntaxNode = syntax
    default:
      return nil
    }
  }

  /// Creates a `DeclSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    // Assert that the kind of the given data matches in debug builds.
#if DEBUG
    switch data.raw.kind {
    case .unknownDecl, .typealiasDecl, .associatedtypeDecl, .ifConfigDecl, .poundErrorDecl, .poundWarningDecl, .poundSourceLocation, .classDecl, .structDecl, .protocolDecl, .extensionDecl, .functionDecl, .initializerDecl, .deinitializerDecl, .subscriptDecl, .importDecl, .accessorDecl, .variableDecl, .enumCaseDecl, .enumDecl, .operatorDecl, .precedenceGroupDecl:
      break
    default:
      fatalError("Unable to create DeclSyntax from \(data.raw.kind)")
    }
#endif

    self._syntaxNode = Syntax(data)
  }

  public func `is`<S: DeclSyntaxProtocol>(_ syntaxType: S.Type) -> Bool {
    return self.as(syntaxType) != nil
  }

  public func `as`<S: DeclSyntaxProtocol>(_ syntaxType: S.Type) -> S? {
    return S.init(_syntaxNode)
  }
}

/// Protocol to which all `ExprSyntax` nodes conform. Extension point to add
/// common methods to all `ExprSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol ExprSyntaxProtocol: SyntaxProtocol {}

public struct ExprSyntax: ExprSyntaxProtocol {
  public let _syntaxNode: Syntax

  public init<S: ExprSyntaxProtocol>(_ syntax: S) {
    // We know this cast is going to succeed. Go through init(_: SyntaxData)
    // to do a sanity check and verify the kind matches in debug builds and get
    // maximum performance in release builds.
    self.init(syntax._syntaxNode.data)
  }

  /// Converts the given `Syntax` node to a `ExprSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    switch syntax.raw.kind {
    case .unknownExpr, .inOutExpr, .poundColumnExpr, .tryExpr, .identifierExpr, .superRefExpr, .nilLiteralExpr, .discardAssignmentExpr, .assignmentExpr, .sequenceExpr, .poundLineExpr, .poundFileExpr, .poundFunctionExpr, .poundDsohandleExpr, .symbolicReferenceExpr, .prefixOperatorExpr, .binaryOperatorExpr, .arrowExpr, .floatLiteralExpr, .tupleExpr, .arrayExpr, .dictionaryExpr, .integerLiteralExpr, .booleanLiteralExpr, .ternaryExpr, .memberAccessExpr, .isExpr, .asExpr, .typeExpr, .closureExpr, .unresolvedPatternExpr, .functionCallExpr, .subscriptExpr, .optionalChainingExpr, .forcedValueExpr, .postfixUnaryExpr, .specializeExpr, .stringLiteralExpr, .keyPathExpr, .keyPathBaseExpr, .objcKeyPathExpr, .objcSelectorExpr, .editorPlaceholderExpr, .objectLiteralExpr:
      self._syntaxNode = syntax
    default:
      return nil
    }
  }

  /// Creates a `ExprSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    // Assert that the kind of the given data matches in debug builds.
#if DEBUG
    switch data.raw.kind {
    case .unknownExpr, .inOutExpr, .poundColumnExpr, .tryExpr, .identifierExpr, .superRefExpr, .nilLiteralExpr, .discardAssignmentExpr, .assignmentExpr, .sequenceExpr, .poundLineExpr, .poundFileExpr, .poundFunctionExpr, .poundDsohandleExpr, .symbolicReferenceExpr, .prefixOperatorExpr, .binaryOperatorExpr, .arrowExpr, .floatLiteralExpr, .tupleExpr, .arrayExpr, .dictionaryExpr, .integerLiteralExpr, .booleanLiteralExpr, .ternaryExpr, .memberAccessExpr, .isExpr, .asExpr, .typeExpr, .closureExpr, .unresolvedPatternExpr, .functionCallExpr, .subscriptExpr, .optionalChainingExpr, .forcedValueExpr, .postfixUnaryExpr, .specializeExpr, .stringLiteralExpr, .keyPathExpr, .keyPathBaseExpr, .objcKeyPathExpr, .objcSelectorExpr, .editorPlaceholderExpr, .objectLiteralExpr:
      break
    default:
      fatalError("Unable to create ExprSyntax from \(data.raw.kind)")
    }
#endif

    self._syntaxNode = Syntax(data)
  }

  public func `is`<S: ExprSyntaxProtocol>(_ syntaxType: S.Type) -> Bool {
    return self.as(syntaxType) != nil
  }

  public func `as`<S: ExprSyntaxProtocol>(_ syntaxType: S.Type) -> S? {
    return S.init(_syntaxNode)
  }
}

/// Protocol to which all `StmtSyntax` nodes conform. Extension point to add
/// common methods to all `StmtSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol StmtSyntaxProtocol: SyntaxProtocol {}

public struct StmtSyntax: StmtSyntaxProtocol {
  public let _syntaxNode: Syntax

  public init<S: StmtSyntaxProtocol>(_ syntax: S) {
    // We know this cast is going to succeed. Go through init(_: SyntaxData)
    // to do a sanity check and verify the kind matches in debug builds and get
    // maximum performance in release builds.
    self.init(syntax._syntaxNode.data)
  }

  /// Converts the given `Syntax` node to a `StmtSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    switch syntax.raw.kind {
    case .unknownStmt, .continueStmt, .whileStmt, .deferStmt, .expressionStmt, .repeatWhileStmt, .guardStmt, .forInStmt, .switchStmt, .doStmt, .returnStmt, .yieldStmt, .fallthroughStmt, .breakStmt, .declarationStmt, .throwStmt, .ifStmt, .poundAssertStmt:
      self._syntaxNode = syntax
    default:
      return nil
    }
  }

  /// Creates a `StmtSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    // Assert that the kind of the given data matches in debug builds.
#if DEBUG
    switch data.raw.kind {
    case .unknownStmt, .continueStmt, .whileStmt, .deferStmt, .expressionStmt, .repeatWhileStmt, .guardStmt, .forInStmt, .switchStmt, .doStmt, .returnStmt, .yieldStmt, .fallthroughStmt, .breakStmt, .declarationStmt, .throwStmt, .ifStmt, .poundAssertStmt:
      break
    default:
      fatalError("Unable to create StmtSyntax from \(data.raw.kind)")
    }
#endif

    self._syntaxNode = Syntax(data)
  }

  public func `is`<S: StmtSyntaxProtocol>(_ syntaxType: S.Type) -> Bool {
    return self.as(syntaxType) != nil
  }

  public func `as`<S: StmtSyntaxProtocol>(_ syntaxType: S.Type) -> S? {
    return S.init(_syntaxNode)
  }
}

/// Protocol to which all `TypeSyntax` nodes conform. Extension point to add
/// common methods to all `TypeSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol TypeSyntaxProtocol: SyntaxProtocol {}

public struct TypeSyntax: TypeSyntaxProtocol {
  public let _syntaxNode: Syntax

  public init<S: TypeSyntaxProtocol>(_ syntax: S) {
    // We know this cast is going to succeed. Go through init(_: SyntaxData)
    // to do a sanity check and verify the kind matches in debug builds and get
    // maximum performance in release builds.
    self.init(syntax._syntaxNode.data)
  }

  /// Converts the given `Syntax` node to a `TypeSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    switch syntax.raw.kind {
    case .unknownType, .simpleTypeIdentifier, .memberTypeIdentifier, .classRestrictionType, .arrayType, .dictionaryType, .metatypeType, .optionalType, .someType, .implicitlyUnwrappedOptionalType, .compositionType, .tupleType, .functionType, .attributedType:
      self._syntaxNode = syntax
    default:
      return nil
    }
  }

  /// Creates a `TypeSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    // Assert that the kind of the given data matches in debug builds.
#if DEBUG
    switch data.raw.kind {
    case .unknownType, .simpleTypeIdentifier, .memberTypeIdentifier, .classRestrictionType, .arrayType, .dictionaryType, .metatypeType, .optionalType, .someType, .implicitlyUnwrappedOptionalType, .compositionType, .tupleType, .functionType, .attributedType:
      break
    default:
      fatalError("Unable to create TypeSyntax from \(data.raw.kind)")
    }
#endif

    self._syntaxNode = Syntax(data)
  }

  public func `is`<S: TypeSyntaxProtocol>(_ syntaxType: S.Type) -> Bool {
    return self.as(syntaxType) != nil
  }

  public func `as`<S: TypeSyntaxProtocol>(_ syntaxType: S.Type) -> S? {
    return S.init(_syntaxNode)
  }
}

/// Protocol to which all `PatternSyntax` nodes conform. Extension point to add
/// common methods to all `PatternSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol PatternSyntaxProtocol: SyntaxProtocol {}

public struct PatternSyntax: PatternSyntaxProtocol {
  public let _syntaxNode: Syntax

  public init<S: PatternSyntaxProtocol>(_ syntax: S) {
    // We know this cast is going to succeed. Go through init(_: SyntaxData)
    // to do a sanity check and verify the kind matches in debug builds and get
    // maximum performance in release builds.
    self.init(syntax._syntaxNode.data)
  }

  /// Converts the given `Syntax` node to a `PatternSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    switch syntax.raw.kind {
    case .unknownPattern, .enumCasePattern, .isTypePattern, .optionalPattern, .identifierPattern, .asTypePattern, .tuplePattern, .wildcardPattern, .expressionPattern, .valueBindingPattern:
      self._syntaxNode = syntax
    default:
      return nil
    }
  }

  /// Creates a `PatternSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    // Assert that the kind of the given data matches in debug builds.
#if DEBUG
    switch data.raw.kind {
    case .unknownPattern, .enumCasePattern, .isTypePattern, .optionalPattern, .identifierPattern, .asTypePattern, .tuplePattern, .wildcardPattern, .expressionPattern, .valueBindingPattern:
      break
    default:
      fatalError("Unable to create PatternSyntax from \(data.raw.kind)")
    }
#endif

    self._syntaxNode = Syntax(data)
  }

  public func `is`<S: PatternSyntaxProtocol>(_ syntaxType: S.Type) -> Bool {
    return self.as(syntaxType) != nil
  }

  public func `as`<S: PatternSyntaxProtocol>(_ syntaxType: S.Type) -> S? {
    return S.init(_syntaxNode)
  }
}

/// Protocol to which all `UnknownDeclSyntax` nodes conform. Extension point to add
/// common methods to all `UnknownDeclSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol UnknownDeclSyntaxProtocol: DeclSyntaxProtocol {}


public struct UnknownDeclSyntax: DeclSyntaxProtocol {

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `UnknownDeclSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .unknownDecl else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `UnknownDeclSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .unknownDecl)
    self._syntaxNode = Syntax(data)
  }


  /// Returns a new `UnknownDeclSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> UnknownDeclSyntax {
    return UnknownDeclSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `UnknownDeclSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> UnknownDeclSyntax {
    return UnknownDeclSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `UnknownDeclSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> UnknownDeclSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `UnknownDeclSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> UnknownDeclSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `UnknownDeclSyntax` with all trivia removed.
  public func withoutTrivia() -> UnknownDeclSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `UnknownDeclSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `UnknownDeclSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `UnknownExprSyntax` nodes conform. Extension point to add
/// common methods to all `UnknownExprSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol UnknownExprSyntaxProtocol: ExprSyntaxProtocol {}


public struct UnknownExprSyntax: ExprSyntaxProtocol {

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `UnknownExprSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .unknownExpr else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `UnknownExprSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .unknownExpr)
    self._syntaxNode = Syntax(data)
  }


  /// Returns a new `UnknownExprSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> UnknownExprSyntax {
    return UnknownExprSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `UnknownExprSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> UnknownExprSyntax {
    return UnknownExprSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `UnknownExprSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> UnknownExprSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `UnknownExprSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> UnknownExprSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `UnknownExprSyntax` with all trivia removed.
  public func withoutTrivia() -> UnknownExprSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `UnknownExprSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `UnknownExprSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `UnknownStmtSyntax` nodes conform. Extension point to add
/// common methods to all `UnknownStmtSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol UnknownStmtSyntaxProtocol: StmtSyntaxProtocol {}


public struct UnknownStmtSyntax: StmtSyntaxProtocol {

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `UnknownStmtSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .unknownStmt else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `UnknownStmtSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .unknownStmt)
    self._syntaxNode = Syntax(data)
  }


  /// Returns a new `UnknownStmtSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> UnknownStmtSyntax {
    return UnknownStmtSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `UnknownStmtSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> UnknownStmtSyntax {
    return UnknownStmtSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `UnknownStmtSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> UnknownStmtSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `UnknownStmtSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> UnknownStmtSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `UnknownStmtSyntax` with all trivia removed.
  public func withoutTrivia() -> UnknownStmtSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `UnknownStmtSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `UnknownStmtSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `UnknownTypeSyntax` nodes conform. Extension point to add
/// common methods to all `UnknownTypeSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol UnknownTypeSyntaxProtocol: TypeSyntaxProtocol {}


public struct UnknownTypeSyntax: TypeSyntaxProtocol {

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `UnknownTypeSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .unknownType else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `UnknownTypeSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .unknownType)
    self._syntaxNode = Syntax(data)
  }


  /// Returns a new `UnknownTypeSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> UnknownTypeSyntax {
    return UnknownTypeSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `UnknownTypeSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> UnknownTypeSyntax {
    return UnknownTypeSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `UnknownTypeSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> UnknownTypeSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `UnknownTypeSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> UnknownTypeSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `UnknownTypeSyntax` with all trivia removed.
  public func withoutTrivia() -> UnknownTypeSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `UnknownTypeSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `UnknownTypeSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `UnknownPatternSyntax` nodes conform. Extension point to add
/// common methods to all `UnknownPatternSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol UnknownPatternSyntaxProtocol: PatternSyntaxProtocol {}


public struct UnknownPatternSyntax: PatternSyntaxProtocol {

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `UnknownPatternSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .unknownPattern else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `UnknownPatternSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .unknownPattern)
    self._syntaxNode = Syntax(data)
  }


  /// Returns a new `UnknownPatternSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> UnknownPatternSyntax {
    return UnknownPatternSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `UnknownPatternSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> UnknownPatternSyntax {
    return UnknownPatternSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `UnknownPatternSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> UnknownPatternSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `UnknownPatternSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> UnknownPatternSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `UnknownPatternSyntax` with all trivia removed.
  public func withoutTrivia() -> UnknownPatternSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `UnknownPatternSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `UnknownPatternSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `CodeBlockItemSyntax` nodes conform. Extension point to add
/// common methods to all `CodeBlockItemSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol CodeBlockItemSyntaxProtocol: SyntaxProtocol {}


/// 
/// A CodeBlockItem is any Syntax node that appears on its own line inside
/// a CodeBlock.
/// 
public struct CodeBlockItemSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case item
    case semicolon
    case errorTokens
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `CodeBlockItemSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .codeBlockItem else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `CodeBlockItemSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .codeBlockItem)
    self._syntaxNode = Syntax(data)
  }

  /// The underlying node inside the code block.
  public var item: Syntax {
    get {
      let childData = data.child(at: Cursor.item, 
                                 parent: Syntax(self))
      return Syntax(childData!)
    }
    set(value) {
      self = withItem(value)
    }
  }

  /// Returns a copy of the receiver with its `item` replaced.
  /// - param newChild: The new `item` to replace the node's
  ///                   current `item`, if present.
  public func withItem(
    _ newChild: Syntax?) -> CodeBlockItemSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.unknown)
    let newData = data.replacingChild(raw, at: Cursor.item)
    return CodeBlockItemSyntax(newData)
  }
  /// 
  /// If present, the trailing semicolon at the end of the item.
  /// 
  public var semicolon: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.semicolon, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withSemicolon(value)
    }
  }

  /// Returns a copy of the receiver with its `semicolon` replaced.
  /// - param newChild: The new `semicolon` to replace the node's
  ///                   current `semicolon`, if present.
  public func withSemicolon(
    _ newChild: TokenSyntax?) -> CodeBlockItemSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.semicolon)
    return CodeBlockItemSyntax(newData)
  }
  public var errorTokens: Syntax? {
    get {
      let childData = data.child(at: Cursor.errorTokens, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return Syntax(childData!)
    }
    set(value) {
      self = withErrorTokens(value)
    }
  }

  /// Returns a copy of the receiver with its `errorTokens` replaced.
  /// - param newChild: The new `errorTokens` to replace the node's
  ///                   current `errorTokens`, if present.
  public func withErrorTokens(
    _ newChild: Syntax?) -> CodeBlockItemSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.errorTokens)
    return CodeBlockItemSyntax(newData)
  }

  /// Returns a new `CodeBlockItemSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> CodeBlockItemSyntax {
    return CodeBlockItemSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `CodeBlockItemSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> CodeBlockItemSyntax {
    return CodeBlockItemSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `CodeBlockItemSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> CodeBlockItemSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `CodeBlockItemSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> CodeBlockItemSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `CodeBlockItemSyntax` with all trivia removed.
  public func withoutTrivia() -> CodeBlockItemSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `CodeBlockItemSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `CodeBlockItemSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `CodeBlockItemListSyntax` nodes conform. Extension point to add
/// common methods to all `CodeBlockItemListSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol CodeBlockItemListSyntaxProtocol: SyntaxProtocol {}

/// Protocol to which all `CodeBlockSyntax` nodes conform. Extension point to add
/// common methods to all `CodeBlockSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol CodeBlockSyntaxProtocol: SyntaxProtocol {}


public struct CodeBlockSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case leftBrace
    case statements
    case rightBrace
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `CodeBlockSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .codeBlock else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `CodeBlockSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .codeBlock)
    self._syntaxNode = Syntax(data)
  }

  public var leftBrace: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.leftBrace, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withLeftBrace(value)
    }
  }

  /// Returns a copy of the receiver with its `leftBrace` replaced.
  /// - param newChild: The new `leftBrace` to replace the node's
  ///                   current `leftBrace`, if present.
  public func withLeftBrace(
    _ newChild: TokenSyntax?) -> CodeBlockSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.leftBrace)
    let newData = data.replacingChild(raw, at: Cursor.leftBrace)
    return CodeBlockSyntax(newData)
  }
  public var statements: CodeBlockItemListSyntax {
    get {
      let childData = data.child(at: Cursor.statements, 
                                 parent: Syntax(self))
      return CodeBlockItemListSyntax(childData!)
    }
    set(value) {
      self = withStatements(value)
    }
  }

  /// Adds the provided `Statement` to the node's `statements`
  /// collection.
  /// - param element: The new `Statement` to add to the node's
  ///                  `statements` collection.
  /// - returns: A copy of the receiver with the provided `Statement`
  ///            appended to its `statements` collection.
  public func addStatement(_ element: CodeBlockItemSyntax) -> CodeBlockSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.statements] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.codeBlockItemList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.statements)
    return CodeBlockSyntax(newData)
  }

  /// Returns a copy of the receiver with its `statements` replaced.
  /// - param newChild: The new `statements` to replace the node's
  ///                   current `statements`, if present.
  public func withStatements(
    _ newChild: CodeBlockItemListSyntax?) -> CodeBlockSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.codeBlockItemList)
    let newData = data.replacingChild(raw, at: Cursor.statements)
    return CodeBlockSyntax(newData)
  }
  public var rightBrace: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.rightBrace, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withRightBrace(value)
    }
  }

  /// Returns a copy of the receiver with its `rightBrace` replaced.
  /// - param newChild: The new `rightBrace` to replace the node's
  ///                   current `rightBrace`, if present.
  public func withRightBrace(
    _ newChild: TokenSyntax?) -> CodeBlockSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.rightBrace)
    let newData = data.replacingChild(raw, at: Cursor.rightBrace)
    return CodeBlockSyntax(newData)
  }

  /// Returns a new `CodeBlockSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> CodeBlockSyntax {
    return CodeBlockSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `CodeBlockSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> CodeBlockSyntax {
    return CodeBlockSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `CodeBlockSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> CodeBlockSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `CodeBlockSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> CodeBlockSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `CodeBlockSyntax` with all trivia removed.
  public func withoutTrivia() -> CodeBlockSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `CodeBlockSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `CodeBlockSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `InOutExprSyntax` nodes conform. Extension point to add
/// common methods to all `InOutExprSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol InOutExprSyntaxProtocol: ExprSyntaxProtocol {}


public struct InOutExprSyntax: ExprSyntaxProtocol {
  enum Cursor: Int {
    case ampersand
    case expression
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `InOutExprSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .inOutExpr else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `InOutExprSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .inOutExpr)
    self._syntaxNode = Syntax(data)
  }

  public var ampersand: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.ampersand, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withAmpersand(value)
    }
  }

  /// Returns a copy of the receiver with its `ampersand` replaced.
  /// - param newChild: The new `ampersand` to replace the node's
  ///                   current `ampersand`, if present.
  public func withAmpersand(
    _ newChild: TokenSyntax?) -> InOutExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.prefixAmpersand)
    let newData = data.replacingChild(raw, at: Cursor.ampersand)
    return InOutExprSyntax(newData)
  }
  public var expression: ExprSyntax {
    get {
      let childData = data.child(at: Cursor.expression, 
                                 parent: Syntax(self))
      return ExprSyntax(childData!)
    }
    set(value) {
      self = withExpression(value)
    }
  }

  /// Returns a copy of the receiver with its `expression` replaced.
  /// - param newChild: The new `expression` to replace the node's
  ///                   current `expression`, if present.
  public func withExpression(
    _ newChild: ExprSyntax?) -> InOutExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.expr)
    let newData = data.replacingChild(raw, at: Cursor.expression)
    return InOutExprSyntax(newData)
  }

  /// Returns a new `InOutExprSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> InOutExprSyntax {
    return InOutExprSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `InOutExprSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> InOutExprSyntax {
    return InOutExprSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `InOutExprSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> InOutExprSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `InOutExprSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> InOutExprSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `InOutExprSyntax` with all trivia removed.
  public func withoutTrivia() -> InOutExprSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `InOutExprSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `InOutExprSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `PoundColumnExprSyntax` nodes conform. Extension point to add
/// common methods to all `PoundColumnExprSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol PoundColumnExprSyntaxProtocol: ExprSyntaxProtocol {}


public struct PoundColumnExprSyntax: ExprSyntaxProtocol {
  enum Cursor: Int {
    case poundColumn
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `PoundColumnExprSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .poundColumnExpr else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `PoundColumnExprSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .poundColumnExpr)
    self._syntaxNode = Syntax(data)
  }

  public var poundColumn: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.poundColumn, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withPoundColumn(value)
    }
  }

  /// Returns a copy of the receiver with its `poundColumn` replaced.
  /// - param newChild: The new `poundColumn` to replace the node's
  ///                   current `poundColumn`, if present.
  public func withPoundColumn(
    _ newChild: TokenSyntax?) -> PoundColumnExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.poundColumnKeyword)
    let newData = data.replacingChild(raw, at: Cursor.poundColumn)
    return PoundColumnExprSyntax(newData)
  }

  /// Returns a new `PoundColumnExprSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> PoundColumnExprSyntax {
    return PoundColumnExprSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `PoundColumnExprSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> PoundColumnExprSyntax {
    return PoundColumnExprSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `PoundColumnExprSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> PoundColumnExprSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `PoundColumnExprSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> PoundColumnExprSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `PoundColumnExprSyntax` with all trivia removed.
  public func withoutTrivia() -> PoundColumnExprSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `PoundColumnExprSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `PoundColumnExprSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `TupleExprElementListSyntax` nodes conform. Extension point to add
/// common methods to all `TupleExprElementListSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol TupleExprElementListSyntaxProtocol: SyntaxProtocol {}

/// Protocol to which all `ArrayElementListSyntax` nodes conform. Extension point to add
/// common methods to all `ArrayElementListSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol ArrayElementListSyntaxProtocol: SyntaxProtocol {}

/// Protocol to which all `DictionaryElementListSyntax` nodes conform. Extension point to add
/// common methods to all `DictionaryElementListSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol DictionaryElementListSyntaxProtocol: SyntaxProtocol {}

/// Protocol to which all `StringLiteralSegmentsSyntax` nodes conform. Extension point to add
/// common methods to all `StringLiteralSegmentsSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol StringLiteralSegmentsSyntaxProtocol: SyntaxProtocol {}

/// Protocol to which all `TryExprSyntax` nodes conform. Extension point to add
/// common methods to all `TryExprSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol TryExprSyntaxProtocol: ExprSyntaxProtocol {}


public struct TryExprSyntax: ExprSyntaxProtocol {
  enum Cursor: Int {
    case tryKeyword
    case questionOrExclamationMark
    case expression
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `TryExprSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .tryExpr else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `TryExprSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .tryExpr)
    self._syntaxNode = Syntax(data)
  }

  public var tryKeyword: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.tryKeyword, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withTryKeyword(value)
    }
  }

  /// Returns a copy of the receiver with its `tryKeyword` replaced.
  /// - param newChild: The new `tryKeyword` to replace the node's
  ///                   current `tryKeyword`, if present.
  public func withTryKeyword(
    _ newChild: TokenSyntax?) -> TryExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.tryKeyword)
    let newData = data.replacingChild(raw, at: Cursor.tryKeyword)
    return TryExprSyntax(newData)
  }
  public var questionOrExclamationMark: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.questionOrExclamationMark, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withQuestionOrExclamationMark(value)
    }
  }

  /// Returns a copy of the receiver with its `questionOrExclamationMark` replaced.
  /// - param newChild: The new `questionOrExclamationMark` to replace the node's
  ///                   current `questionOrExclamationMark`, if present.
  public func withQuestionOrExclamationMark(
    _ newChild: TokenSyntax?) -> TryExprSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.questionOrExclamationMark)
    return TryExprSyntax(newData)
  }
  public var expression: ExprSyntax {
    get {
      let childData = data.child(at: Cursor.expression, 
                                 parent: Syntax(self))
      return ExprSyntax(childData!)
    }
    set(value) {
      self = withExpression(value)
    }
  }

  /// Returns a copy of the receiver with its `expression` replaced.
  /// - param newChild: The new `expression` to replace the node's
  ///                   current `expression`, if present.
  public func withExpression(
    _ newChild: ExprSyntax?) -> TryExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.expr)
    let newData = data.replacingChild(raw, at: Cursor.expression)
    return TryExprSyntax(newData)
  }

  /// Returns a new `TryExprSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> TryExprSyntax {
    return TryExprSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `TryExprSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> TryExprSyntax {
    return TryExprSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `TryExprSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> TryExprSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `TryExprSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> TryExprSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `TryExprSyntax` with all trivia removed.
  public func withoutTrivia() -> TryExprSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `TryExprSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `TryExprSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `DeclNameArgumentSyntax` nodes conform. Extension point to add
/// common methods to all `DeclNameArgumentSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol DeclNameArgumentSyntaxProtocol: SyntaxProtocol {}


public struct DeclNameArgumentSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case name
    case colon
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `DeclNameArgumentSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .declNameArgument else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `DeclNameArgumentSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .declNameArgument)
    self._syntaxNode = Syntax(data)
  }

  public var name: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.name, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withName(value)
    }
  }

  /// Returns a copy of the receiver with its `name` replaced.
  /// - param newChild: The new `name` to replace the node's
  ///                   current `name`, if present.
  public func withName(
    _ newChild: TokenSyntax?) -> DeclNameArgumentSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.unknown(""))
    let newData = data.replacingChild(raw, at: Cursor.name)
    return DeclNameArgumentSyntax(newData)
  }
  public var colon: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.colon, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withColon(value)
    }
  }

  /// Returns a copy of the receiver with its `colon` replaced.
  /// - param newChild: The new `colon` to replace the node's
  ///                   current `colon`, if present.
  public func withColon(
    _ newChild: TokenSyntax?) -> DeclNameArgumentSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.colon)
    let newData = data.replacingChild(raw, at: Cursor.colon)
    return DeclNameArgumentSyntax(newData)
  }

  /// Returns a new `DeclNameArgumentSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> DeclNameArgumentSyntax {
    return DeclNameArgumentSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `DeclNameArgumentSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> DeclNameArgumentSyntax {
    return DeclNameArgumentSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `DeclNameArgumentSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> DeclNameArgumentSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `DeclNameArgumentSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> DeclNameArgumentSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `DeclNameArgumentSyntax` with all trivia removed.
  public func withoutTrivia() -> DeclNameArgumentSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `DeclNameArgumentSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `DeclNameArgumentSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `DeclNameArgumentListSyntax` nodes conform. Extension point to add
/// common methods to all `DeclNameArgumentListSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol DeclNameArgumentListSyntaxProtocol: SyntaxProtocol {}

/// Protocol to which all `DeclNameArgumentsSyntax` nodes conform. Extension point to add
/// common methods to all `DeclNameArgumentsSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol DeclNameArgumentsSyntaxProtocol: SyntaxProtocol {}


public struct DeclNameArgumentsSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case leftParen
    case arguments
    case rightParen
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `DeclNameArgumentsSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .declNameArguments else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `DeclNameArgumentsSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .declNameArguments)
    self._syntaxNode = Syntax(data)
  }

  public var leftParen: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.leftParen, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withLeftParen(value)
    }
  }

  /// Returns a copy of the receiver with its `leftParen` replaced.
  /// - param newChild: The new `leftParen` to replace the node's
  ///                   current `leftParen`, if present.
  public func withLeftParen(
    _ newChild: TokenSyntax?) -> DeclNameArgumentsSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.leftParen)
    let newData = data.replacingChild(raw, at: Cursor.leftParen)
    return DeclNameArgumentsSyntax(newData)
  }
  public var arguments: DeclNameArgumentListSyntax {
    get {
      let childData = data.child(at: Cursor.arguments, 
                                 parent: Syntax(self))
      return DeclNameArgumentListSyntax(childData!)
    }
    set(value) {
      self = withArguments(value)
    }
  }

  /// Adds the provided `Argument` to the node's `arguments`
  /// collection.
  /// - param element: The new `Argument` to add to the node's
  ///                  `arguments` collection.
  /// - returns: A copy of the receiver with the provided `Argument`
  ///            appended to its `arguments` collection.
  public func addArgument(_ element: DeclNameArgumentSyntax) -> DeclNameArgumentsSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.arguments] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.declNameArgumentList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.arguments)
    return DeclNameArgumentsSyntax(newData)
  }

  /// Returns a copy of the receiver with its `arguments` replaced.
  /// - param newChild: The new `arguments` to replace the node's
  ///                   current `arguments`, if present.
  public func withArguments(
    _ newChild: DeclNameArgumentListSyntax?) -> DeclNameArgumentsSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.declNameArgumentList)
    let newData = data.replacingChild(raw, at: Cursor.arguments)
    return DeclNameArgumentsSyntax(newData)
  }
  public var rightParen: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.rightParen, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withRightParen(value)
    }
  }

  /// Returns a copy of the receiver with its `rightParen` replaced.
  /// - param newChild: The new `rightParen` to replace the node's
  ///                   current `rightParen`, if present.
  public func withRightParen(
    _ newChild: TokenSyntax?) -> DeclNameArgumentsSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.rightParen)
    let newData = data.replacingChild(raw, at: Cursor.rightParen)
    return DeclNameArgumentsSyntax(newData)
  }

  /// Returns a new `DeclNameArgumentsSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> DeclNameArgumentsSyntax {
    return DeclNameArgumentsSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `DeclNameArgumentsSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> DeclNameArgumentsSyntax {
    return DeclNameArgumentsSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `DeclNameArgumentsSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> DeclNameArgumentsSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `DeclNameArgumentsSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> DeclNameArgumentsSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `DeclNameArgumentsSyntax` with all trivia removed.
  public func withoutTrivia() -> DeclNameArgumentsSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `DeclNameArgumentsSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `DeclNameArgumentsSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `IdentifierExprSyntax` nodes conform. Extension point to add
/// common methods to all `IdentifierExprSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol IdentifierExprSyntaxProtocol: ExprSyntaxProtocol {}


public struct IdentifierExprSyntax: ExprSyntaxProtocol {
  enum Cursor: Int {
    case identifier
    case declNameArguments
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `IdentifierExprSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .identifierExpr else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `IdentifierExprSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .identifierExpr)
    self._syntaxNode = Syntax(data)
  }

  public var identifier: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.identifier, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withIdentifier(value)
    }
  }

  /// Returns a copy of the receiver with its `identifier` replaced.
  /// - param newChild: The new `identifier` to replace the node's
  ///                   current `identifier`, if present.
  public func withIdentifier(
    _ newChild: TokenSyntax?) -> IdentifierExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let newData = data.replacingChild(raw, at: Cursor.identifier)
    return IdentifierExprSyntax(newData)
  }
  public var declNameArguments: DeclNameArgumentsSyntax? {
    get {
      let childData = data.child(at: Cursor.declNameArguments, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return DeclNameArgumentsSyntax(childData!)
    }
    set(value) {
      self = withDeclNameArguments(value)
    }
  }

  /// Returns a copy of the receiver with its `declNameArguments` replaced.
  /// - param newChild: The new `declNameArguments` to replace the node's
  ///                   current `declNameArguments`, if present.
  public func withDeclNameArguments(
    _ newChild: DeclNameArgumentsSyntax?) -> IdentifierExprSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.declNameArguments)
    return IdentifierExprSyntax(newData)
  }

  /// Returns a new `IdentifierExprSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> IdentifierExprSyntax {
    return IdentifierExprSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `IdentifierExprSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> IdentifierExprSyntax {
    return IdentifierExprSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `IdentifierExprSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> IdentifierExprSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `IdentifierExprSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> IdentifierExprSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `IdentifierExprSyntax` with all trivia removed.
  public func withoutTrivia() -> IdentifierExprSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `IdentifierExprSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `IdentifierExprSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `SuperRefExprSyntax` nodes conform. Extension point to add
/// common methods to all `SuperRefExprSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol SuperRefExprSyntaxProtocol: ExprSyntaxProtocol {}


public struct SuperRefExprSyntax: ExprSyntaxProtocol {
  enum Cursor: Int {
    case superKeyword
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `SuperRefExprSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .superRefExpr else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `SuperRefExprSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .superRefExpr)
    self._syntaxNode = Syntax(data)
  }

  public var superKeyword: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.superKeyword, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withSuperKeyword(value)
    }
  }

  /// Returns a copy of the receiver with its `superKeyword` replaced.
  /// - param newChild: The new `superKeyword` to replace the node's
  ///                   current `superKeyword`, if present.
  public func withSuperKeyword(
    _ newChild: TokenSyntax?) -> SuperRefExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.superKeyword)
    let newData = data.replacingChild(raw, at: Cursor.superKeyword)
    return SuperRefExprSyntax(newData)
  }

  /// Returns a new `SuperRefExprSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> SuperRefExprSyntax {
    return SuperRefExprSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `SuperRefExprSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> SuperRefExprSyntax {
    return SuperRefExprSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `SuperRefExprSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> SuperRefExprSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `SuperRefExprSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> SuperRefExprSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `SuperRefExprSyntax` with all trivia removed.
  public func withoutTrivia() -> SuperRefExprSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `SuperRefExprSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `SuperRefExprSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `NilLiteralExprSyntax` nodes conform. Extension point to add
/// common methods to all `NilLiteralExprSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol NilLiteralExprSyntaxProtocol: ExprSyntaxProtocol {}


public struct NilLiteralExprSyntax: ExprSyntaxProtocol {
  enum Cursor: Int {
    case nilKeyword
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `NilLiteralExprSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .nilLiteralExpr else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `NilLiteralExprSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .nilLiteralExpr)
    self._syntaxNode = Syntax(data)
  }

  public var nilKeyword: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.nilKeyword, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withNilKeyword(value)
    }
  }

  /// Returns a copy of the receiver with its `nilKeyword` replaced.
  /// - param newChild: The new `nilKeyword` to replace the node's
  ///                   current `nilKeyword`, if present.
  public func withNilKeyword(
    _ newChild: TokenSyntax?) -> NilLiteralExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.nilKeyword)
    let newData = data.replacingChild(raw, at: Cursor.nilKeyword)
    return NilLiteralExprSyntax(newData)
  }

  /// Returns a new `NilLiteralExprSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> NilLiteralExprSyntax {
    return NilLiteralExprSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `NilLiteralExprSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> NilLiteralExprSyntax {
    return NilLiteralExprSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `NilLiteralExprSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> NilLiteralExprSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `NilLiteralExprSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> NilLiteralExprSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `NilLiteralExprSyntax` with all trivia removed.
  public func withoutTrivia() -> NilLiteralExprSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `NilLiteralExprSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `NilLiteralExprSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `DiscardAssignmentExprSyntax` nodes conform. Extension point to add
/// common methods to all `DiscardAssignmentExprSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol DiscardAssignmentExprSyntaxProtocol: ExprSyntaxProtocol {}


public struct DiscardAssignmentExprSyntax: ExprSyntaxProtocol {
  enum Cursor: Int {
    case wildcard
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `DiscardAssignmentExprSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .discardAssignmentExpr else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `DiscardAssignmentExprSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .discardAssignmentExpr)
    self._syntaxNode = Syntax(data)
  }

  public var wildcard: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.wildcard, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withWildcard(value)
    }
  }

  /// Returns a copy of the receiver with its `wildcard` replaced.
  /// - param newChild: The new `wildcard` to replace the node's
  ///                   current `wildcard`, if present.
  public func withWildcard(
    _ newChild: TokenSyntax?) -> DiscardAssignmentExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.wildcardKeyword)
    let newData = data.replacingChild(raw, at: Cursor.wildcard)
    return DiscardAssignmentExprSyntax(newData)
  }

  /// Returns a new `DiscardAssignmentExprSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> DiscardAssignmentExprSyntax {
    return DiscardAssignmentExprSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `DiscardAssignmentExprSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> DiscardAssignmentExprSyntax {
    return DiscardAssignmentExprSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `DiscardAssignmentExprSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> DiscardAssignmentExprSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `DiscardAssignmentExprSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> DiscardAssignmentExprSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `DiscardAssignmentExprSyntax` with all trivia removed.
  public func withoutTrivia() -> DiscardAssignmentExprSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `DiscardAssignmentExprSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `DiscardAssignmentExprSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `AssignmentExprSyntax` nodes conform. Extension point to add
/// common methods to all `AssignmentExprSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol AssignmentExprSyntaxProtocol: ExprSyntaxProtocol {}


public struct AssignmentExprSyntax: ExprSyntaxProtocol {
  enum Cursor: Int {
    case assignToken
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `AssignmentExprSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .assignmentExpr else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `AssignmentExprSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .assignmentExpr)
    self._syntaxNode = Syntax(data)
  }

  public var assignToken: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.assignToken, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withAssignToken(value)
    }
  }

  /// Returns a copy of the receiver with its `assignToken` replaced.
  /// - param newChild: The new `assignToken` to replace the node's
  ///                   current `assignToken`, if present.
  public func withAssignToken(
    _ newChild: TokenSyntax?) -> AssignmentExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.equal)
    let newData = data.replacingChild(raw, at: Cursor.assignToken)
    return AssignmentExprSyntax(newData)
  }

  /// Returns a new `AssignmentExprSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> AssignmentExprSyntax {
    return AssignmentExprSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `AssignmentExprSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> AssignmentExprSyntax {
    return AssignmentExprSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `AssignmentExprSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> AssignmentExprSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `AssignmentExprSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> AssignmentExprSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `AssignmentExprSyntax` with all trivia removed.
  public func withoutTrivia() -> AssignmentExprSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `AssignmentExprSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `AssignmentExprSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `SequenceExprSyntax` nodes conform. Extension point to add
/// common methods to all `SequenceExprSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol SequenceExprSyntaxProtocol: ExprSyntaxProtocol {}


public struct SequenceExprSyntax: ExprSyntaxProtocol {
  enum Cursor: Int {
    case elements
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `SequenceExprSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .sequenceExpr else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `SequenceExprSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .sequenceExpr)
    self._syntaxNode = Syntax(data)
  }

  public var elements: ExprListSyntax {
    get {
      let childData = data.child(at: Cursor.elements, 
                                 parent: Syntax(self))
      return ExprListSyntax(childData!)
    }
    set(value) {
      self = withElements(value)
    }
  }

  /// Adds the provided `Element` to the node's `elements`
  /// collection.
  /// - param element: The new `Element` to add to the node's
  ///                  `elements` collection.
  /// - returns: A copy of the receiver with the provided `Element`
  ///            appended to its `elements` collection.
  public func addElement(_ element: ExprSyntax) -> SequenceExprSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.elements] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.exprList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.elements)
    return SequenceExprSyntax(newData)
  }

  /// Returns a copy of the receiver with its `elements` replaced.
  /// - param newChild: The new `elements` to replace the node's
  ///                   current `elements`, if present.
  public func withElements(
    _ newChild: ExprListSyntax?) -> SequenceExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.exprList)
    let newData = data.replacingChild(raw, at: Cursor.elements)
    return SequenceExprSyntax(newData)
  }

  /// Returns a new `SequenceExprSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> SequenceExprSyntax {
    return SequenceExprSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `SequenceExprSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> SequenceExprSyntax {
    return SequenceExprSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `SequenceExprSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> SequenceExprSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `SequenceExprSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> SequenceExprSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `SequenceExprSyntax` with all trivia removed.
  public func withoutTrivia() -> SequenceExprSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `SequenceExprSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `SequenceExprSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `ExprListSyntax` nodes conform. Extension point to add
/// common methods to all `ExprListSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol ExprListSyntaxProtocol: SyntaxProtocol {}

/// Protocol to which all `PoundLineExprSyntax` nodes conform. Extension point to add
/// common methods to all `PoundLineExprSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol PoundLineExprSyntaxProtocol: ExprSyntaxProtocol {}


public struct PoundLineExprSyntax: ExprSyntaxProtocol {
  enum Cursor: Int {
    case poundLine
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `PoundLineExprSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .poundLineExpr else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `PoundLineExprSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .poundLineExpr)
    self._syntaxNode = Syntax(data)
  }

  public var poundLine: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.poundLine, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withPoundLine(value)
    }
  }

  /// Returns a copy of the receiver with its `poundLine` replaced.
  /// - param newChild: The new `poundLine` to replace the node's
  ///                   current `poundLine`, if present.
  public func withPoundLine(
    _ newChild: TokenSyntax?) -> PoundLineExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.poundLineKeyword)
    let newData = data.replacingChild(raw, at: Cursor.poundLine)
    return PoundLineExprSyntax(newData)
  }

  /// Returns a new `PoundLineExprSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> PoundLineExprSyntax {
    return PoundLineExprSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `PoundLineExprSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> PoundLineExprSyntax {
    return PoundLineExprSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `PoundLineExprSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> PoundLineExprSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `PoundLineExprSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> PoundLineExprSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `PoundLineExprSyntax` with all trivia removed.
  public func withoutTrivia() -> PoundLineExprSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `PoundLineExprSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `PoundLineExprSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `PoundFileExprSyntax` nodes conform. Extension point to add
/// common methods to all `PoundFileExprSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol PoundFileExprSyntaxProtocol: ExprSyntaxProtocol {}


public struct PoundFileExprSyntax: ExprSyntaxProtocol {
  enum Cursor: Int {
    case poundFile
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `PoundFileExprSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .poundFileExpr else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `PoundFileExprSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .poundFileExpr)
    self._syntaxNode = Syntax(data)
  }

  public var poundFile: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.poundFile, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withPoundFile(value)
    }
  }

  /// Returns a copy of the receiver with its `poundFile` replaced.
  /// - param newChild: The new `poundFile` to replace the node's
  ///                   current `poundFile`, if present.
  public func withPoundFile(
    _ newChild: TokenSyntax?) -> PoundFileExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.poundFileKeyword)
    let newData = data.replacingChild(raw, at: Cursor.poundFile)
    return PoundFileExprSyntax(newData)
  }

  /// Returns a new `PoundFileExprSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> PoundFileExprSyntax {
    return PoundFileExprSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `PoundFileExprSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> PoundFileExprSyntax {
    return PoundFileExprSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `PoundFileExprSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> PoundFileExprSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `PoundFileExprSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> PoundFileExprSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `PoundFileExprSyntax` with all trivia removed.
  public func withoutTrivia() -> PoundFileExprSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `PoundFileExprSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `PoundFileExprSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `PoundFunctionExprSyntax` nodes conform. Extension point to add
/// common methods to all `PoundFunctionExprSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol PoundFunctionExprSyntaxProtocol: ExprSyntaxProtocol {}


public struct PoundFunctionExprSyntax: ExprSyntaxProtocol {
  enum Cursor: Int {
    case poundFunction
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `PoundFunctionExprSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .poundFunctionExpr else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `PoundFunctionExprSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .poundFunctionExpr)
    self._syntaxNode = Syntax(data)
  }

  public var poundFunction: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.poundFunction, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withPoundFunction(value)
    }
  }

  /// Returns a copy of the receiver with its `poundFunction` replaced.
  /// - param newChild: The new `poundFunction` to replace the node's
  ///                   current `poundFunction`, if present.
  public func withPoundFunction(
    _ newChild: TokenSyntax?) -> PoundFunctionExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.poundFunctionKeyword)
    let newData = data.replacingChild(raw, at: Cursor.poundFunction)
    return PoundFunctionExprSyntax(newData)
  }

  /// Returns a new `PoundFunctionExprSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> PoundFunctionExprSyntax {
    return PoundFunctionExprSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `PoundFunctionExprSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> PoundFunctionExprSyntax {
    return PoundFunctionExprSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `PoundFunctionExprSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> PoundFunctionExprSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `PoundFunctionExprSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> PoundFunctionExprSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `PoundFunctionExprSyntax` with all trivia removed.
  public func withoutTrivia() -> PoundFunctionExprSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `PoundFunctionExprSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `PoundFunctionExprSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `PoundDsohandleExprSyntax` nodes conform. Extension point to add
/// common methods to all `PoundDsohandleExprSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol PoundDsohandleExprSyntaxProtocol: ExprSyntaxProtocol {}


public struct PoundDsohandleExprSyntax: ExprSyntaxProtocol {
  enum Cursor: Int {
    case poundDsohandle
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `PoundDsohandleExprSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .poundDsohandleExpr else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `PoundDsohandleExprSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .poundDsohandleExpr)
    self._syntaxNode = Syntax(data)
  }

  public var poundDsohandle: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.poundDsohandle, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withPoundDsohandle(value)
    }
  }

  /// Returns a copy of the receiver with its `poundDsohandle` replaced.
  /// - param newChild: The new `poundDsohandle` to replace the node's
  ///                   current `poundDsohandle`, if present.
  public func withPoundDsohandle(
    _ newChild: TokenSyntax?) -> PoundDsohandleExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.poundDsohandleKeyword)
    let newData = data.replacingChild(raw, at: Cursor.poundDsohandle)
    return PoundDsohandleExprSyntax(newData)
  }

  /// Returns a new `PoundDsohandleExprSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> PoundDsohandleExprSyntax {
    return PoundDsohandleExprSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `PoundDsohandleExprSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> PoundDsohandleExprSyntax {
    return PoundDsohandleExprSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `PoundDsohandleExprSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> PoundDsohandleExprSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `PoundDsohandleExprSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> PoundDsohandleExprSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `PoundDsohandleExprSyntax` with all trivia removed.
  public func withoutTrivia() -> PoundDsohandleExprSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `PoundDsohandleExprSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `PoundDsohandleExprSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `SymbolicReferenceExprSyntax` nodes conform. Extension point to add
/// common methods to all `SymbolicReferenceExprSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol SymbolicReferenceExprSyntaxProtocol: ExprSyntaxProtocol {}


public struct SymbolicReferenceExprSyntax: ExprSyntaxProtocol {
  enum Cursor: Int {
    case identifier
    case genericArgumentClause
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `SymbolicReferenceExprSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .symbolicReferenceExpr else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `SymbolicReferenceExprSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .symbolicReferenceExpr)
    self._syntaxNode = Syntax(data)
  }

  public var identifier: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.identifier, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withIdentifier(value)
    }
  }

  /// Returns a copy of the receiver with its `identifier` replaced.
  /// - param newChild: The new `identifier` to replace the node's
  ///                   current `identifier`, if present.
  public func withIdentifier(
    _ newChild: TokenSyntax?) -> SymbolicReferenceExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let newData = data.replacingChild(raw, at: Cursor.identifier)
    return SymbolicReferenceExprSyntax(newData)
  }
  public var genericArgumentClause: GenericArgumentClauseSyntax? {
    get {
      let childData = data.child(at: Cursor.genericArgumentClause, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return GenericArgumentClauseSyntax(childData!)
    }
    set(value) {
      self = withGenericArgumentClause(value)
    }
  }

  /// Returns a copy of the receiver with its `genericArgumentClause` replaced.
  /// - param newChild: The new `genericArgumentClause` to replace the node's
  ///                   current `genericArgumentClause`, if present.
  public func withGenericArgumentClause(
    _ newChild: GenericArgumentClauseSyntax?) -> SymbolicReferenceExprSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.genericArgumentClause)
    return SymbolicReferenceExprSyntax(newData)
  }

  /// Returns a new `SymbolicReferenceExprSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> SymbolicReferenceExprSyntax {
    return SymbolicReferenceExprSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `SymbolicReferenceExprSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> SymbolicReferenceExprSyntax {
    return SymbolicReferenceExprSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `SymbolicReferenceExprSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> SymbolicReferenceExprSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `SymbolicReferenceExprSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> SymbolicReferenceExprSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `SymbolicReferenceExprSyntax` with all trivia removed.
  public func withoutTrivia() -> SymbolicReferenceExprSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `SymbolicReferenceExprSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `SymbolicReferenceExprSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `PrefixOperatorExprSyntax` nodes conform. Extension point to add
/// common methods to all `PrefixOperatorExprSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol PrefixOperatorExprSyntaxProtocol: ExprSyntaxProtocol {}


public struct PrefixOperatorExprSyntax: ExprSyntaxProtocol {
  enum Cursor: Int {
    case operatorToken
    case postfixExpression
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `PrefixOperatorExprSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .prefixOperatorExpr else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `PrefixOperatorExprSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .prefixOperatorExpr)
    self._syntaxNode = Syntax(data)
  }

  public var operatorToken: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.operatorToken, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withOperatorToken(value)
    }
  }

  /// Returns a copy of the receiver with its `operatorToken` replaced.
  /// - param newChild: The new `operatorToken` to replace the node's
  ///                   current `operatorToken`, if present.
  public func withOperatorToken(
    _ newChild: TokenSyntax?) -> PrefixOperatorExprSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.operatorToken)
    return PrefixOperatorExprSyntax(newData)
  }
  public var postfixExpression: ExprSyntax {
    get {
      let childData = data.child(at: Cursor.postfixExpression, 
                                 parent: Syntax(self))
      return ExprSyntax(childData!)
    }
    set(value) {
      self = withPostfixExpression(value)
    }
  }

  /// Returns a copy of the receiver with its `postfixExpression` replaced.
  /// - param newChild: The new `postfixExpression` to replace the node's
  ///                   current `postfixExpression`, if present.
  public func withPostfixExpression(
    _ newChild: ExprSyntax?) -> PrefixOperatorExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.expr)
    let newData = data.replacingChild(raw, at: Cursor.postfixExpression)
    return PrefixOperatorExprSyntax(newData)
  }

  /// Returns a new `PrefixOperatorExprSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> PrefixOperatorExprSyntax {
    return PrefixOperatorExprSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `PrefixOperatorExprSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> PrefixOperatorExprSyntax {
    return PrefixOperatorExprSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `PrefixOperatorExprSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> PrefixOperatorExprSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `PrefixOperatorExprSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> PrefixOperatorExprSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `PrefixOperatorExprSyntax` with all trivia removed.
  public func withoutTrivia() -> PrefixOperatorExprSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `PrefixOperatorExprSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `PrefixOperatorExprSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `BinaryOperatorExprSyntax` nodes conform. Extension point to add
/// common methods to all `BinaryOperatorExprSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol BinaryOperatorExprSyntaxProtocol: ExprSyntaxProtocol {}


public struct BinaryOperatorExprSyntax: ExprSyntaxProtocol {
  enum Cursor: Int {
    case operatorToken
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `BinaryOperatorExprSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .binaryOperatorExpr else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `BinaryOperatorExprSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .binaryOperatorExpr)
    self._syntaxNode = Syntax(data)
  }

  public var operatorToken: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.operatorToken, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withOperatorToken(value)
    }
  }

  /// Returns a copy of the receiver with its `operatorToken` replaced.
  /// - param newChild: The new `operatorToken` to replace the node's
  ///                   current `operatorToken`, if present.
  public func withOperatorToken(
    _ newChild: TokenSyntax?) -> BinaryOperatorExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.unknown(""))
    let newData = data.replacingChild(raw, at: Cursor.operatorToken)
    return BinaryOperatorExprSyntax(newData)
  }

  /// Returns a new `BinaryOperatorExprSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> BinaryOperatorExprSyntax {
    return BinaryOperatorExprSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `BinaryOperatorExprSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> BinaryOperatorExprSyntax {
    return BinaryOperatorExprSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `BinaryOperatorExprSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> BinaryOperatorExprSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `BinaryOperatorExprSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> BinaryOperatorExprSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `BinaryOperatorExprSyntax` with all trivia removed.
  public func withoutTrivia() -> BinaryOperatorExprSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `BinaryOperatorExprSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `BinaryOperatorExprSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `ArrowExprSyntax` nodes conform. Extension point to add
/// common methods to all `ArrowExprSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol ArrowExprSyntaxProtocol: ExprSyntaxProtocol {}


public struct ArrowExprSyntax: ExprSyntaxProtocol {
  enum Cursor: Int {
    case throwsToken
    case arrowToken
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `ArrowExprSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .arrowExpr else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `ArrowExprSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .arrowExpr)
    self._syntaxNode = Syntax(data)
  }

  public var throwsToken: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.throwsToken, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withThrowsToken(value)
    }
  }

  /// Returns a copy of the receiver with its `throwsToken` replaced.
  /// - param newChild: The new `throwsToken` to replace the node's
  ///                   current `throwsToken`, if present.
  public func withThrowsToken(
    _ newChild: TokenSyntax?) -> ArrowExprSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.throwsToken)
    return ArrowExprSyntax(newData)
  }
  public var arrowToken: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.arrowToken, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withArrowToken(value)
    }
  }

  /// Returns a copy of the receiver with its `arrowToken` replaced.
  /// - param newChild: The new `arrowToken` to replace the node's
  ///                   current `arrowToken`, if present.
  public func withArrowToken(
    _ newChild: TokenSyntax?) -> ArrowExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.arrow)
    let newData = data.replacingChild(raw, at: Cursor.arrowToken)
    return ArrowExprSyntax(newData)
  }

  /// Returns a new `ArrowExprSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> ArrowExprSyntax {
    return ArrowExprSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `ArrowExprSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> ArrowExprSyntax {
    return ArrowExprSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `ArrowExprSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> ArrowExprSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `ArrowExprSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> ArrowExprSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `ArrowExprSyntax` with all trivia removed.
  public func withoutTrivia() -> ArrowExprSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `ArrowExprSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `ArrowExprSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `FloatLiteralExprSyntax` nodes conform. Extension point to add
/// common methods to all `FloatLiteralExprSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol FloatLiteralExprSyntaxProtocol: ExprSyntaxProtocol {}


public struct FloatLiteralExprSyntax: ExprSyntaxProtocol {
  enum Cursor: Int {
    case floatingDigits
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `FloatLiteralExprSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .floatLiteralExpr else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `FloatLiteralExprSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .floatLiteralExpr)
    self._syntaxNode = Syntax(data)
  }

  public var floatingDigits: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.floatingDigits, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withFloatingDigits(value)
    }
  }

  /// Returns a copy of the receiver with its `floatingDigits` replaced.
  /// - param newChild: The new `floatingDigits` to replace the node's
  ///                   current `floatingDigits`, if present.
  public func withFloatingDigits(
    _ newChild: TokenSyntax?) -> FloatLiteralExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.floatingLiteral(""))
    let newData = data.replacingChild(raw, at: Cursor.floatingDigits)
    return FloatLiteralExprSyntax(newData)
  }

  /// Returns a new `FloatLiteralExprSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> FloatLiteralExprSyntax {
    return FloatLiteralExprSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `FloatLiteralExprSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> FloatLiteralExprSyntax {
    return FloatLiteralExprSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `FloatLiteralExprSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> FloatLiteralExprSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `FloatLiteralExprSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> FloatLiteralExprSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `FloatLiteralExprSyntax` with all trivia removed.
  public func withoutTrivia() -> FloatLiteralExprSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `FloatLiteralExprSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `FloatLiteralExprSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `TupleExprSyntax` nodes conform. Extension point to add
/// common methods to all `TupleExprSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol TupleExprSyntaxProtocol: ExprSyntaxProtocol {}


public struct TupleExprSyntax: ExprSyntaxProtocol {
  enum Cursor: Int {
    case leftParen
    case elementList
    case rightParen
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `TupleExprSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .tupleExpr else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `TupleExprSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .tupleExpr)
    self._syntaxNode = Syntax(data)
  }

  public var leftParen: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.leftParen, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withLeftParen(value)
    }
  }

  /// Returns a copy of the receiver with its `leftParen` replaced.
  /// - param newChild: The new `leftParen` to replace the node's
  ///                   current `leftParen`, if present.
  public func withLeftParen(
    _ newChild: TokenSyntax?) -> TupleExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.leftParen)
    let newData = data.replacingChild(raw, at: Cursor.leftParen)
    return TupleExprSyntax(newData)
  }
  public var elementList: TupleExprElementListSyntax {
    get {
      let childData = data.child(at: Cursor.elementList, 
                                 parent: Syntax(self))
      return TupleExprElementListSyntax(childData!)
    }
    set(value) {
      self = withElementList(value)
    }
  }

  /// Adds the provided `Element` to the node's `elementList`
  /// collection.
  /// - param element: The new `Element` to add to the node's
  ///                  `elementList` collection.
  /// - returns: A copy of the receiver with the provided `Element`
  ///            appended to its `elementList` collection.
  public func addElement(_ element: TupleExprElementSyntax) -> TupleExprSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.elementList] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.tupleExprElementList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.elementList)
    return TupleExprSyntax(newData)
  }

  /// Returns a copy of the receiver with its `elementList` replaced.
  /// - param newChild: The new `elementList` to replace the node's
  ///                   current `elementList`, if present.
  public func withElementList(
    _ newChild: TupleExprElementListSyntax?) -> TupleExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.tupleExprElementList)
    let newData = data.replacingChild(raw, at: Cursor.elementList)
    return TupleExprSyntax(newData)
  }
  public var rightParen: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.rightParen, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withRightParen(value)
    }
  }

  /// Returns a copy of the receiver with its `rightParen` replaced.
  /// - param newChild: The new `rightParen` to replace the node's
  ///                   current `rightParen`, if present.
  public func withRightParen(
    _ newChild: TokenSyntax?) -> TupleExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.rightParen)
    let newData = data.replacingChild(raw, at: Cursor.rightParen)
    return TupleExprSyntax(newData)
  }

  /// Returns a new `TupleExprSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> TupleExprSyntax {
    return TupleExprSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `TupleExprSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> TupleExprSyntax {
    return TupleExprSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `TupleExprSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> TupleExprSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `TupleExprSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> TupleExprSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `TupleExprSyntax` with all trivia removed.
  public func withoutTrivia() -> TupleExprSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `TupleExprSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `TupleExprSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `ArrayExprSyntax` nodes conform. Extension point to add
/// common methods to all `ArrayExprSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol ArrayExprSyntaxProtocol: ExprSyntaxProtocol {}


public struct ArrayExprSyntax: ExprSyntaxProtocol {
  enum Cursor: Int {
    case leftSquare
    case elements
    case rightSquare
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `ArrayExprSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .arrayExpr else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `ArrayExprSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .arrayExpr)
    self._syntaxNode = Syntax(data)
  }

  public var leftSquare: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.leftSquare, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withLeftSquare(value)
    }
  }

  /// Returns a copy of the receiver with its `leftSquare` replaced.
  /// - param newChild: The new `leftSquare` to replace the node's
  ///                   current `leftSquare`, if present.
  public func withLeftSquare(
    _ newChild: TokenSyntax?) -> ArrayExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.leftSquareBracket)
    let newData = data.replacingChild(raw, at: Cursor.leftSquare)
    return ArrayExprSyntax(newData)
  }
  public var elements: ArrayElementListSyntax {
    get {
      let childData = data.child(at: Cursor.elements, 
                                 parent: Syntax(self))
      return ArrayElementListSyntax(childData!)
    }
    set(value) {
      self = withElements(value)
    }
  }

  /// Adds the provided `Element` to the node's `elements`
  /// collection.
  /// - param element: The new `Element` to add to the node's
  ///                  `elements` collection.
  /// - returns: A copy of the receiver with the provided `Element`
  ///            appended to its `elements` collection.
  public func addElement(_ element: ArrayElementSyntax) -> ArrayExprSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.elements] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.arrayElementList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.elements)
    return ArrayExprSyntax(newData)
  }

  /// Returns a copy of the receiver with its `elements` replaced.
  /// - param newChild: The new `elements` to replace the node's
  ///                   current `elements`, if present.
  public func withElements(
    _ newChild: ArrayElementListSyntax?) -> ArrayExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.arrayElementList)
    let newData = data.replacingChild(raw, at: Cursor.elements)
    return ArrayExprSyntax(newData)
  }
  public var rightSquare: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.rightSquare, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withRightSquare(value)
    }
  }

  /// Returns a copy of the receiver with its `rightSquare` replaced.
  /// - param newChild: The new `rightSquare` to replace the node's
  ///                   current `rightSquare`, if present.
  public func withRightSquare(
    _ newChild: TokenSyntax?) -> ArrayExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.rightSquareBracket)
    let newData = data.replacingChild(raw, at: Cursor.rightSquare)
    return ArrayExprSyntax(newData)
  }

  /// Returns a new `ArrayExprSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> ArrayExprSyntax {
    return ArrayExprSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `ArrayExprSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> ArrayExprSyntax {
    return ArrayExprSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `ArrayExprSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> ArrayExprSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `ArrayExprSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> ArrayExprSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `ArrayExprSyntax` with all trivia removed.
  public func withoutTrivia() -> ArrayExprSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `ArrayExprSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `ArrayExprSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `DictionaryExprSyntax` nodes conform. Extension point to add
/// common methods to all `DictionaryExprSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol DictionaryExprSyntaxProtocol: ExprSyntaxProtocol {}


public struct DictionaryExprSyntax: ExprSyntaxProtocol {
  enum Cursor: Int {
    case leftSquare
    case content
    case rightSquare
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `DictionaryExprSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .dictionaryExpr else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `DictionaryExprSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .dictionaryExpr)
    self._syntaxNode = Syntax(data)
  }

  public var leftSquare: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.leftSquare, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withLeftSquare(value)
    }
  }

  /// Returns a copy of the receiver with its `leftSquare` replaced.
  /// - param newChild: The new `leftSquare` to replace the node's
  ///                   current `leftSquare`, if present.
  public func withLeftSquare(
    _ newChild: TokenSyntax?) -> DictionaryExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.leftSquareBracket)
    let newData = data.replacingChild(raw, at: Cursor.leftSquare)
    return DictionaryExprSyntax(newData)
  }
  public var content: Syntax {
    get {
      let childData = data.child(at: Cursor.content, 
                                 parent: Syntax(self))
      return Syntax(childData!)
    }
    set(value) {
      self = withContent(value)
    }
  }

  /// Returns a copy of the receiver with its `content` replaced.
  /// - param newChild: The new `content` to replace the node's
  ///                   current `content`, if present.
  public func withContent(
    _ newChild: Syntax?) -> DictionaryExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.unknown)
    let newData = data.replacingChild(raw, at: Cursor.content)
    return DictionaryExprSyntax(newData)
  }
  public var rightSquare: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.rightSquare, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withRightSquare(value)
    }
  }

  /// Returns a copy of the receiver with its `rightSquare` replaced.
  /// - param newChild: The new `rightSquare` to replace the node's
  ///                   current `rightSquare`, if present.
  public func withRightSquare(
    _ newChild: TokenSyntax?) -> DictionaryExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.rightSquareBracket)
    let newData = data.replacingChild(raw, at: Cursor.rightSquare)
    return DictionaryExprSyntax(newData)
  }

  /// Returns a new `DictionaryExprSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> DictionaryExprSyntax {
    return DictionaryExprSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `DictionaryExprSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> DictionaryExprSyntax {
    return DictionaryExprSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `DictionaryExprSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> DictionaryExprSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `DictionaryExprSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> DictionaryExprSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `DictionaryExprSyntax` with all trivia removed.
  public func withoutTrivia() -> DictionaryExprSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `DictionaryExprSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `DictionaryExprSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `TupleExprElementSyntax` nodes conform. Extension point to add
/// common methods to all `TupleExprElementSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol TupleExprElementSyntaxProtocol: SyntaxProtocol {}


public struct TupleExprElementSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case label
    case colon
    case expression
    case trailingComma
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `TupleExprElementSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .tupleExprElement else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `TupleExprElementSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .tupleExprElement)
    self._syntaxNode = Syntax(data)
  }

  public var label: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.label, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withLabel(value)
    }
  }

  /// Returns a copy of the receiver with its `label` replaced.
  /// - param newChild: The new `label` to replace the node's
  ///                   current `label`, if present.
  public func withLabel(
    _ newChild: TokenSyntax?) -> TupleExprElementSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.label)
    return TupleExprElementSyntax(newData)
  }
  public var colon: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.colon, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withColon(value)
    }
  }

  /// Returns a copy of the receiver with its `colon` replaced.
  /// - param newChild: The new `colon` to replace the node's
  ///                   current `colon`, if present.
  public func withColon(
    _ newChild: TokenSyntax?) -> TupleExprElementSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.colon)
    return TupleExprElementSyntax(newData)
  }
  public var expression: ExprSyntax {
    get {
      let childData = data.child(at: Cursor.expression, 
                                 parent: Syntax(self))
      return ExprSyntax(childData!)
    }
    set(value) {
      self = withExpression(value)
    }
  }

  /// Returns a copy of the receiver with its `expression` replaced.
  /// - param newChild: The new `expression` to replace the node's
  ///                   current `expression`, if present.
  public func withExpression(
    _ newChild: ExprSyntax?) -> TupleExprElementSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.expr)
    let newData = data.replacingChild(raw, at: Cursor.expression)
    return TupleExprElementSyntax(newData)
  }
  public var trailingComma: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.trailingComma, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withTrailingComma(value)
    }
  }

  /// Returns a copy of the receiver with its `trailingComma` replaced.
  /// - param newChild: The new `trailingComma` to replace the node's
  ///                   current `trailingComma`, if present.
  public func withTrailingComma(
    _ newChild: TokenSyntax?) -> TupleExprElementSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.trailingComma)
    return TupleExprElementSyntax(newData)
  }

  /// Returns a new `TupleExprElementSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> TupleExprElementSyntax {
    return TupleExprElementSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `TupleExprElementSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> TupleExprElementSyntax {
    return TupleExprElementSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `TupleExprElementSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> TupleExprElementSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `TupleExprElementSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> TupleExprElementSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `TupleExprElementSyntax` with all trivia removed.
  public func withoutTrivia() -> TupleExprElementSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `TupleExprElementSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `TupleExprElementSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `ArrayElementSyntax` nodes conform. Extension point to add
/// common methods to all `ArrayElementSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol ArrayElementSyntaxProtocol: SyntaxProtocol {}


public struct ArrayElementSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case expression
    case trailingComma
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `ArrayElementSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .arrayElement else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `ArrayElementSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .arrayElement)
    self._syntaxNode = Syntax(data)
  }

  public var expression: ExprSyntax {
    get {
      let childData = data.child(at: Cursor.expression, 
                                 parent: Syntax(self))
      return ExprSyntax(childData!)
    }
    set(value) {
      self = withExpression(value)
    }
  }

  /// Returns a copy of the receiver with its `expression` replaced.
  /// - param newChild: The new `expression` to replace the node's
  ///                   current `expression`, if present.
  public func withExpression(
    _ newChild: ExprSyntax?) -> ArrayElementSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.expr)
    let newData = data.replacingChild(raw, at: Cursor.expression)
    return ArrayElementSyntax(newData)
  }
  public var trailingComma: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.trailingComma, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withTrailingComma(value)
    }
  }

  /// Returns a copy of the receiver with its `trailingComma` replaced.
  /// - param newChild: The new `trailingComma` to replace the node's
  ///                   current `trailingComma`, if present.
  public func withTrailingComma(
    _ newChild: TokenSyntax?) -> ArrayElementSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.trailingComma)
    return ArrayElementSyntax(newData)
  }

  /// Returns a new `ArrayElementSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> ArrayElementSyntax {
    return ArrayElementSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `ArrayElementSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> ArrayElementSyntax {
    return ArrayElementSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `ArrayElementSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> ArrayElementSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `ArrayElementSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> ArrayElementSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `ArrayElementSyntax` with all trivia removed.
  public func withoutTrivia() -> ArrayElementSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `ArrayElementSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `ArrayElementSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `DictionaryElementSyntax` nodes conform. Extension point to add
/// common methods to all `DictionaryElementSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol DictionaryElementSyntaxProtocol: SyntaxProtocol {}


public struct DictionaryElementSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case keyExpression
    case colon
    case valueExpression
    case trailingComma
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `DictionaryElementSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .dictionaryElement else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `DictionaryElementSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .dictionaryElement)
    self._syntaxNode = Syntax(data)
  }

  public var keyExpression: ExprSyntax {
    get {
      let childData = data.child(at: Cursor.keyExpression, 
                                 parent: Syntax(self))
      return ExprSyntax(childData!)
    }
    set(value) {
      self = withKeyExpression(value)
    }
  }

  /// Returns a copy of the receiver with its `keyExpression` replaced.
  /// - param newChild: The new `keyExpression` to replace the node's
  ///                   current `keyExpression`, if present.
  public func withKeyExpression(
    _ newChild: ExprSyntax?) -> DictionaryElementSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.expr)
    let newData = data.replacingChild(raw, at: Cursor.keyExpression)
    return DictionaryElementSyntax(newData)
  }
  public var colon: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.colon, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withColon(value)
    }
  }

  /// Returns a copy of the receiver with its `colon` replaced.
  /// - param newChild: The new `colon` to replace the node's
  ///                   current `colon`, if present.
  public func withColon(
    _ newChild: TokenSyntax?) -> DictionaryElementSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.colon)
    let newData = data.replacingChild(raw, at: Cursor.colon)
    return DictionaryElementSyntax(newData)
  }
  public var valueExpression: ExprSyntax {
    get {
      let childData = data.child(at: Cursor.valueExpression, 
                                 parent: Syntax(self))
      return ExprSyntax(childData!)
    }
    set(value) {
      self = withValueExpression(value)
    }
  }

  /// Returns a copy of the receiver with its `valueExpression` replaced.
  /// - param newChild: The new `valueExpression` to replace the node's
  ///                   current `valueExpression`, if present.
  public func withValueExpression(
    _ newChild: ExprSyntax?) -> DictionaryElementSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.expr)
    let newData = data.replacingChild(raw, at: Cursor.valueExpression)
    return DictionaryElementSyntax(newData)
  }
  public var trailingComma: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.trailingComma, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withTrailingComma(value)
    }
  }

  /// Returns a copy of the receiver with its `trailingComma` replaced.
  /// - param newChild: The new `trailingComma` to replace the node's
  ///                   current `trailingComma`, if present.
  public func withTrailingComma(
    _ newChild: TokenSyntax?) -> DictionaryElementSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.trailingComma)
    return DictionaryElementSyntax(newData)
  }

  /// Returns a new `DictionaryElementSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> DictionaryElementSyntax {
    return DictionaryElementSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `DictionaryElementSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> DictionaryElementSyntax {
    return DictionaryElementSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `DictionaryElementSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> DictionaryElementSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `DictionaryElementSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> DictionaryElementSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `DictionaryElementSyntax` with all trivia removed.
  public func withoutTrivia() -> DictionaryElementSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `DictionaryElementSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `DictionaryElementSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `IntegerLiteralExprSyntax` nodes conform. Extension point to add
/// common methods to all `IntegerLiteralExprSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol IntegerLiteralExprSyntaxProtocol: ExprSyntaxProtocol {}


public struct IntegerLiteralExprSyntax: ExprSyntaxProtocol {
  enum Cursor: Int {
    case digits
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `IntegerLiteralExprSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .integerLiteralExpr else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `IntegerLiteralExprSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .integerLiteralExpr)
    self._syntaxNode = Syntax(data)
  }

  public var digits: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.digits, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withDigits(value)
    }
  }

  /// Returns a copy of the receiver with its `digits` replaced.
  /// - param newChild: The new `digits` to replace the node's
  ///                   current `digits`, if present.
  public func withDigits(
    _ newChild: TokenSyntax?) -> IntegerLiteralExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.integerLiteral(""))
    let newData = data.replacingChild(raw, at: Cursor.digits)
    return IntegerLiteralExprSyntax(newData)
  }

  /// Returns a new `IntegerLiteralExprSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> IntegerLiteralExprSyntax {
    return IntegerLiteralExprSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `IntegerLiteralExprSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> IntegerLiteralExprSyntax {
    return IntegerLiteralExprSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `IntegerLiteralExprSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> IntegerLiteralExprSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `IntegerLiteralExprSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> IntegerLiteralExprSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `IntegerLiteralExprSyntax` with all trivia removed.
  public func withoutTrivia() -> IntegerLiteralExprSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `IntegerLiteralExprSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `IntegerLiteralExprSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `BooleanLiteralExprSyntax` nodes conform. Extension point to add
/// common methods to all `BooleanLiteralExprSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol BooleanLiteralExprSyntaxProtocol: ExprSyntaxProtocol {}


public struct BooleanLiteralExprSyntax: ExprSyntaxProtocol {
  enum Cursor: Int {
    case booleanLiteral
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `BooleanLiteralExprSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .booleanLiteralExpr else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `BooleanLiteralExprSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .booleanLiteralExpr)
    self._syntaxNode = Syntax(data)
  }

  public var booleanLiteral: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.booleanLiteral, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withBooleanLiteral(value)
    }
  }

  /// Returns a copy of the receiver with its `booleanLiteral` replaced.
  /// - param newChild: The new `booleanLiteral` to replace the node's
  ///                   current `booleanLiteral`, if present.
  public func withBooleanLiteral(
    _ newChild: TokenSyntax?) -> BooleanLiteralExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.trueKeyword)
    let newData = data.replacingChild(raw, at: Cursor.booleanLiteral)
    return BooleanLiteralExprSyntax(newData)
  }

  /// Returns a new `BooleanLiteralExprSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> BooleanLiteralExprSyntax {
    return BooleanLiteralExprSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `BooleanLiteralExprSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> BooleanLiteralExprSyntax {
    return BooleanLiteralExprSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `BooleanLiteralExprSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> BooleanLiteralExprSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `BooleanLiteralExprSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> BooleanLiteralExprSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `BooleanLiteralExprSyntax` with all trivia removed.
  public func withoutTrivia() -> BooleanLiteralExprSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `BooleanLiteralExprSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `BooleanLiteralExprSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `TernaryExprSyntax` nodes conform. Extension point to add
/// common methods to all `TernaryExprSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol TernaryExprSyntaxProtocol: ExprSyntaxProtocol {}


public struct TernaryExprSyntax: ExprSyntaxProtocol {
  enum Cursor: Int {
    case conditionExpression
    case questionMark
    case firstChoice
    case colonMark
    case secondChoice
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `TernaryExprSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .ternaryExpr else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `TernaryExprSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .ternaryExpr)
    self._syntaxNode = Syntax(data)
  }

  public var conditionExpression: ExprSyntax {
    get {
      let childData = data.child(at: Cursor.conditionExpression, 
                                 parent: Syntax(self))
      return ExprSyntax(childData!)
    }
    set(value) {
      self = withConditionExpression(value)
    }
  }

  /// Returns a copy of the receiver with its `conditionExpression` replaced.
  /// - param newChild: The new `conditionExpression` to replace the node's
  ///                   current `conditionExpression`, if present.
  public func withConditionExpression(
    _ newChild: ExprSyntax?) -> TernaryExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.expr)
    let newData = data.replacingChild(raw, at: Cursor.conditionExpression)
    return TernaryExprSyntax(newData)
  }
  public var questionMark: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.questionMark, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withQuestionMark(value)
    }
  }

  /// Returns a copy of the receiver with its `questionMark` replaced.
  /// - param newChild: The new `questionMark` to replace the node's
  ///                   current `questionMark`, if present.
  public func withQuestionMark(
    _ newChild: TokenSyntax?) -> TernaryExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.infixQuestionMark)
    let newData = data.replacingChild(raw, at: Cursor.questionMark)
    return TernaryExprSyntax(newData)
  }
  public var firstChoice: ExprSyntax {
    get {
      let childData = data.child(at: Cursor.firstChoice, 
                                 parent: Syntax(self))
      return ExprSyntax(childData!)
    }
    set(value) {
      self = withFirstChoice(value)
    }
  }

  /// Returns a copy of the receiver with its `firstChoice` replaced.
  /// - param newChild: The new `firstChoice` to replace the node's
  ///                   current `firstChoice`, if present.
  public func withFirstChoice(
    _ newChild: ExprSyntax?) -> TernaryExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.expr)
    let newData = data.replacingChild(raw, at: Cursor.firstChoice)
    return TernaryExprSyntax(newData)
  }
  public var colonMark: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.colonMark, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withColonMark(value)
    }
  }

  /// Returns a copy of the receiver with its `colonMark` replaced.
  /// - param newChild: The new `colonMark` to replace the node's
  ///                   current `colonMark`, if present.
  public func withColonMark(
    _ newChild: TokenSyntax?) -> TernaryExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.colon)
    let newData = data.replacingChild(raw, at: Cursor.colonMark)
    return TernaryExprSyntax(newData)
  }
  public var secondChoice: ExprSyntax {
    get {
      let childData = data.child(at: Cursor.secondChoice, 
                                 parent: Syntax(self))
      return ExprSyntax(childData!)
    }
    set(value) {
      self = withSecondChoice(value)
    }
  }

  /// Returns a copy of the receiver with its `secondChoice` replaced.
  /// - param newChild: The new `secondChoice` to replace the node's
  ///                   current `secondChoice`, if present.
  public func withSecondChoice(
    _ newChild: ExprSyntax?) -> TernaryExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.expr)
    let newData = data.replacingChild(raw, at: Cursor.secondChoice)
    return TernaryExprSyntax(newData)
  }

  /// Returns a new `TernaryExprSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> TernaryExprSyntax {
    return TernaryExprSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `TernaryExprSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> TernaryExprSyntax {
    return TernaryExprSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `TernaryExprSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> TernaryExprSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `TernaryExprSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> TernaryExprSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `TernaryExprSyntax` with all trivia removed.
  public func withoutTrivia() -> TernaryExprSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `TernaryExprSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `TernaryExprSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `MemberAccessExprSyntax` nodes conform. Extension point to add
/// common methods to all `MemberAccessExprSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol MemberAccessExprSyntaxProtocol: ExprSyntaxProtocol {}


public struct MemberAccessExprSyntax: ExprSyntaxProtocol {
  enum Cursor: Int {
    case base
    case dot
    case name
    case declNameArguments
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `MemberAccessExprSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .memberAccessExpr else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `MemberAccessExprSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .memberAccessExpr)
    self._syntaxNode = Syntax(data)
  }

  public var base: ExprSyntax? {
    get {
      let childData = data.child(at: Cursor.base, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return ExprSyntax(childData!)
    }
    set(value) {
      self = withBase(value)
    }
  }

  /// Returns a copy of the receiver with its `base` replaced.
  /// - param newChild: The new `base` to replace the node's
  ///                   current `base`, if present.
  public func withBase(
    _ newChild: ExprSyntax?) -> MemberAccessExprSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.base)
    return MemberAccessExprSyntax(newData)
  }
  public var dot: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.dot, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withDot(value)
    }
  }

  /// Returns a copy of the receiver with its `dot` replaced.
  /// - param newChild: The new `dot` to replace the node's
  ///                   current `dot`, if present.
  public func withDot(
    _ newChild: TokenSyntax?) -> MemberAccessExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.period)
    let newData = data.replacingChild(raw, at: Cursor.dot)
    return MemberAccessExprSyntax(newData)
  }
  public var name: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.name, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withName(value)
    }
  }

  /// Returns a copy of the receiver with its `name` replaced.
  /// - param newChild: The new `name` to replace the node's
  ///                   current `name`, if present.
  public func withName(
    _ newChild: TokenSyntax?) -> MemberAccessExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.unknown(""))
    let newData = data.replacingChild(raw, at: Cursor.name)
    return MemberAccessExprSyntax(newData)
  }
  public var declNameArguments: DeclNameArgumentsSyntax? {
    get {
      let childData = data.child(at: Cursor.declNameArguments, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return DeclNameArgumentsSyntax(childData!)
    }
    set(value) {
      self = withDeclNameArguments(value)
    }
  }

  /// Returns a copy of the receiver with its `declNameArguments` replaced.
  /// - param newChild: The new `declNameArguments` to replace the node's
  ///                   current `declNameArguments`, if present.
  public func withDeclNameArguments(
    _ newChild: DeclNameArgumentsSyntax?) -> MemberAccessExprSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.declNameArguments)
    return MemberAccessExprSyntax(newData)
  }

  /// Returns a new `MemberAccessExprSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> MemberAccessExprSyntax {
    return MemberAccessExprSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `MemberAccessExprSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> MemberAccessExprSyntax {
    return MemberAccessExprSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `MemberAccessExprSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> MemberAccessExprSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `MemberAccessExprSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> MemberAccessExprSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `MemberAccessExprSyntax` with all trivia removed.
  public func withoutTrivia() -> MemberAccessExprSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `MemberAccessExprSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `MemberAccessExprSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `IsExprSyntax` nodes conform. Extension point to add
/// common methods to all `IsExprSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol IsExprSyntaxProtocol: ExprSyntaxProtocol {}


public struct IsExprSyntax: ExprSyntaxProtocol {
  enum Cursor: Int {
    case isTok
    case typeName
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `IsExprSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .isExpr else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `IsExprSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .isExpr)
    self._syntaxNode = Syntax(data)
  }

  public var isTok: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.isTok, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withIsTok(value)
    }
  }

  /// Returns a copy of the receiver with its `isTok` replaced.
  /// - param newChild: The new `isTok` to replace the node's
  ///                   current `isTok`, if present.
  public func withIsTok(
    _ newChild: TokenSyntax?) -> IsExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.isKeyword)
    let newData = data.replacingChild(raw, at: Cursor.isTok)
    return IsExprSyntax(newData)
  }
  public var typeName: TypeSyntax {
    get {
      let childData = data.child(at: Cursor.typeName, 
                                 parent: Syntax(self))
      return TypeSyntax(childData!)
    }
    set(value) {
      self = withTypeName(value)
    }
  }

  /// Returns a copy of the receiver with its `typeName` replaced.
  /// - param newChild: The new `typeName` to replace the node's
  ///                   current `typeName`, if present.
  public func withTypeName(
    _ newChild: TypeSyntax?) -> IsExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.type)
    let newData = data.replacingChild(raw, at: Cursor.typeName)
    return IsExprSyntax(newData)
  }

  /// Returns a new `IsExprSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> IsExprSyntax {
    return IsExprSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `IsExprSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> IsExprSyntax {
    return IsExprSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `IsExprSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> IsExprSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `IsExprSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> IsExprSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `IsExprSyntax` with all trivia removed.
  public func withoutTrivia() -> IsExprSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `IsExprSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `IsExprSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `AsExprSyntax` nodes conform. Extension point to add
/// common methods to all `AsExprSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol AsExprSyntaxProtocol: ExprSyntaxProtocol {}


public struct AsExprSyntax: ExprSyntaxProtocol {
  enum Cursor: Int {
    case asTok
    case questionOrExclamationMark
    case typeName
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `AsExprSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .asExpr else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `AsExprSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .asExpr)
    self._syntaxNode = Syntax(data)
  }

  public var asTok: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.asTok, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withAsTok(value)
    }
  }

  /// Returns a copy of the receiver with its `asTok` replaced.
  /// - param newChild: The new `asTok` to replace the node's
  ///                   current `asTok`, if present.
  public func withAsTok(
    _ newChild: TokenSyntax?) -> AsExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.asKeyword)
    let newData = data.replacingChild(raw, at: Cursor.asTok)
    return AsExprSyntax(newData)
  }
  public var questionOrExclamationMark: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.questionOrExclamationMark, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withQuestionOrExclamationMark(value)
    }
  }

  /// Returns a copy of the receiver with its `questionOrExclamationMark` replaced.
  /// - param newChild: The new `questionOrExclamationMark` to replace the node's
  ///                   current `questionOrExclamationMark`, if present.
  public func withQuestionOrExclamationMark(
    _ newChild: TokenSyntax?) -> AsExprSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.questionOrExclamationMark)
    return AsExprSyntax(newData)
  }
  public var typeName: TypeSyntax {
    get {
      let childData = data.child(at: Cursor.typeName, 
                                 parent: Syntax(self))
      return TypeSyntax(childData!)
    }
    set(value) {
      self = withTypeName(value)
    }
  }

  /// Returns a copy of the receiver with its `typeName` replaced.
  /// - param newChild: The new `typeName` to replace the node's
  ///                   current `typeName`, if present.
  public func withTypeName(
    _ newChild: TypeSyntax?) -> AsExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.type)
    let newData = data.replacingChild(raw, at: Cursor.typeName)
    return AsExprSyntax(newData)
  }

  /// Returns a new `AsExprSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> AsExprSyntax {
    return AsExprSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `AsExprSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> AsExprSyntax {
    return AsExprSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `AsExprSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> AsExprSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `AsExprSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> AsExprSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `AsExprSyntax` with all trivia removed.
  public func withoutTrivia() -> AsExprSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `AsExprSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `AsExprSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `TypeExprSyntax` nodes conform. Extension point to add
/// common methods to all `TypeExprSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol TypeExprSyntaxProtocol: ExprSyntaxProtocol {}


public struct TypeExprSyntax: ExprSyntaxProtocol {
  enum Cursor: Int {
    case type
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `TypeExprSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .typeExpr else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `TypeExprSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .typeExpr)
    self._syntaxNode = Syntax(data)
  }

  public var type: TypeSyntax {
    get {
      let childData = data.child(at: Cursor.type, 
                                 parent: Syntax(self))
      return TypeSyntax(childData!)
    }
    set(value) {
      self = withType(value)
    }
  }

  /// Returns a copy of the receiver with its `type` replaced.
  /// - param newChild: The new `type` to replace the node's
  ///                   current `type`, if present.
  public func withType(
    _ newChild: TypeSyntax?) -> TypeExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.type)
    let newData = data.replacingChild(raw, at: Cursor.type)
    return TypeExprSyntax(newData)
  }

  /// Returns a new `TypeExprSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> TypeExprSyntax {
    return TypeExprSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `TypeExprSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> TypeExprSyntax {
    return TypeExprSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `TypeExprSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> TypeExprSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `TypeExprSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> TypeExprSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `TypeExprSyntax` with all trivia removed.
  public func withoutTrivia() -> TypeExprSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `TypeExprSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `TypeExprSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `ClosureCaptureItemSyntax` nodes conform. Extension point to add
/// common methods to all `ClosureCaptureItemSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol ClosureCaptureItemSyntaxProtocol: SyntaxProtocol {}


public struct ClosureCaptureItemSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case specifier
    case name
    case assignToken
    case expression
    case trailingComma
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `ClosureCaptureItemSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .closureCaptureItem else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `ClosureCaptureItemSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .closureCaptureItem)
    self._syntaxNode = Syntax(data)
  }

  public var specifier: TokenListSyntax? {
    get {
      let childData = data.child(at: Cursor.specifier, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenListSyntax(childData!)
    }
    set(value) {
      self = withSpecifier(value)
    }
  }

  /// Adds the provided `SpecifierToken` to the node's `specifier`
  /// collection.
  /// - param element: The new `SpecifierToken` to add to the node's
  ///                  `specifier` collection.
  /// - returns: A copy of the receiver with the provided `SpecifierToken`
  ///            appended to its `specifier` collection.
  public func addSpecifierToken(_ element: TokenSyntax) -> ClosureCaptureItemSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.specifier] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.tokenList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.specifier)
    return ClosureCaptureItemSyntax(newData)
  }

  /// Returns a copy of the receiver with its `specifier` replaced.
  /// - param newChild: The new `specifier` to replace the node's
  ///                   current `specifier`, if present.
  public func withSpecifier(
    _ newChild: TokenListSyntax?) -> ClosureCaptureItemSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.specifier)
    return ClosureCaptureItemSyntax(newData)
  }
  public var name: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.name, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withName(value)
    }
  }

  /// Returns a copy of the receiver with its `name` replaced.
  /// - param newChild: The new `name` to replace the node's
  ///                   current `name`, if present.
  public func withName(
    _ newChild: TokenSyntax?) -> ClosureCaptureItemSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.name)
    return ClosureCaptureItemSyntax(newData)
  }
  public var assignToken: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.assignToken, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withAssignToken(value)
    }
  }

  /// Returns a copy of the receiver with its `assignToken` replaced.
  /// - param newChild: The new `assignToken` to replace the node's
  ///                   current `assignToken`, if present.
  public func withAssignToken(
    _ newChild: TokenSyntax?) -> ClosureCaptureItemSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.assignToken)
    return ClosureCaptureItemSyntax(newData)
  }
  public var expression: ExprSyntax {
    get {
      let childData = data.child(at: Cursor.expression, 
                                 parent: Syntax(self))
      return ExprSyntax(childData!)
    }
    set(value) {
      self = withExpression(value)
    }
  }

  /// Returns a copy of the receiver with its `expression` replaced.
  /// - param newChild: The new `expression` to replace the node's
  ///                   current `expression`, if present.
  public func withExpression(
    _ newChild: ExprSyntax?) -> ClosureCaptureItemSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.expr)
    let newData = data.replacingChild(raw, at: Cursor.expression)
    return ClosureCaptureItemSyntax(newData)
  }
  public var trailingComma: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.trailingComma, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withTrailingComma(value)
    }
  }

  /// Returns a copy of the receiver with its `trailingComma` replaced.
  /// - param newChild: The new `trailingComma` to replace the node's
  ///                   current `trailingComma`, if present.
  public func withTrailingComma(
    _ newChild: TokenSyntax?) -> ClosureCaptureItemSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.trailingComma)
    return ClosureCaptureItemSyntax(newData)
  }

  /// Returns a new `ClosureCaptureItemSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> ClosureCaptureItemSyntax {
    return ClosureCaptureItemSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `ClosureCaptureItemSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> ClosureCaptureItemSyntax {
    return ClosureCaptureItemSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `ClosureCaptureItemSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> ClosureCaptureItemSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `ClosureCaptureItemSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> ClosureCaptureItemSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `ClosureCaptureItemSyntax` with all trivia removed.
  public func withoutTrivia() -> ClosureCaptureItemSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `ClosureCaptureItemSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `ClosureCaptureItemSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `ClosureCaptureItemListSyntax` nodes conform. Extension point to add
/// common methods to all `ClosureCaptureItemListSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol ClosureCaptureItemListSyntaxProtocol: SyntaxProtocol {}

/// Protocol to which all `ClosureCaptureSignatureSyntax` nodes conform. Extension point to add
/// common methods to all `ClosureCaptureSignatureSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol ClosureCaptureSignatureSyntaxProtocol: SyntaxProtocol {}


public struct ClosureCaptureSignatureSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case leftSquare
    case items
    case rightSquare
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `ClosureCaptureSignatureSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .closureCaptureSignature else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `ClosureCaptureSignatureSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .closureCaptureSignature)
    self._syntaxNode = Syntax(data)
  }

  public var leftSquare: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.leftSquare, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withLeftSquare(value)
    }
  }

  /// Returns a copy of the receiver with its `leftSquare` replaced.
  /// - param newChild: The new `leftSquare` to replace the node's
  ///                   current `leftSquare`, if present.
  public func withLeftSquare(
    _ newChild: TokenSyntax?) -> ClosureCaptureSignatureSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.leftSquareBracket)
    let newData = data.replacingChild(raw, at: Cursor.leftSquare)
    return ClosureCaptureSignatureSyntax(newData)
  }
  public var items: ClosureCaptureItemListSyntax? {
    get {
      let childData = data.child(at: Cursor.items, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return ClosureCaptureItemListSyntax(childData!)
    }
    set(value) {
      self = withItems(value)
    }
  }

  /// Adds the provided `Item` to the node's `items`
  /// collection.
  /// - param element: The new `Item` to add to the node's
  ///                  `items` collection.
  /// - returns: A copy of the receiver with the provided `Item`
  ///            appended to its `items` collection.
  public func addItem(_ element: ClosureCaptureItemSyntax) -> ClosureCaptureSignatureSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.items] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.closureCaptureItemList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.items)
    return ClosureCaptureSignatureSyntax(newData)
  }

  /// Returns a copy of the receiver with its `items` replaced.
  /// - param newChild: The new `items` to replace the node's
  ///                   current `items`, if present.
  public func withItems(
    _ newChild: ClosureCaptureItemListSyntax?) -> ClosureCaptureSignatureSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.items)
    return ClosureCaptureSignatureSyntax(newData)
  }
  public var rightSquare: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.rightSquare, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withRightSquare(value)
    }
  }

  /// Returns a copy of the receiver with its `rightSquare` replaced.
  /// - param newChild: The new `rightSquare` to replace the node's
  ///                   current `rightSquare`, if present.
  public func withRightSquare(
    _ newChild: TokenSyntax?) -> ClosureCaptureSignatureSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.rightSquareBracket)
    let newData = data.replacingChild(raw, at: Cursor.rightSquare)
    return ClosureCaptureSignatureSyntax(newData)
  }

  /// Returns a new `ClosureCaptureSignatureSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> ClosureCaptureSignatureSyntax {
    return ClosureCaptureSignatureSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `ClosureCaptureSignatureSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> ClosureCaptureSignatureSyntax {
    return ClosureCaptureSignatureSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `ClosureCaptureSignatureSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> ClosureCaptureSignatureSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `ClosureCaptureSignatureSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> ClosureCaptureSignatureSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `ClosureCaptureSignatureSyntax` with all trivia removed.
  public func withoutTrivia() -> ClosureCaptureSignatureSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `ClosureCaptureSignatureSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `ClosureCaptureSignatureSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `ClosureParamSyntax` nodes conform. Extension point to add
/// common methods to all `ClosureParamSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol ClosureParamSyntaxProtocol: SyntaxProtocol {}


public struct ClosureParamSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case name
    case trailingComma
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `ClosureParamSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .closureParam else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `ClosureParamSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .closureParam)
    self._syntaxNode = Syntax(data)
  }

  public var name: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.name, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withName(value)
    }
  }

  /// Returns a copy of the receiver with its `name` replaced.
  /// - param newChild: The new `name` to replace the node's
  ///                   current `name`, if present.
  public func withName(
    _ newChild: TokenSyntax?) -> ClosureParamSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let newData = data.replacingChild(raw, at: Cursor.name)
    return ClosureParamSyntax(newData)
  }
  public var trailingComma: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.trailingComma, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withTrailingComma(value)
    }
  }

  /// Returns a copy of the receiver with its `trailingComma` replaced.
  /// - param newChild: The new `trailingComma` to replace the node's
  ///                   current `trailingComma`, if present.
  public func withTrailingComma(
    _ newChild: TokenSyntax?) -> ClosureParamSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.trailingComma)
    return ClosureParamSyntax(newData)
  }

  /// Returns a new `ClosureParamSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> ClosureParamSyntax {
    return ClosureParamSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `ClosureParamSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> ClosureParamSyntax {
    return ClosureParamSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `ClosureParamSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> ClosureParamSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `ClosureParamSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> ClosureParamSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `ClosureParamSyntax` with all trivia removed.
  public func withoutTrivia() -> ClosureParamSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `ClosureParamSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `ClosureParamSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `ClosureParamListSyntax` nodes conform. Extension point to add
/// common methods to all `ClosureParamListSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol ClosureParamListSyntaxProtocol: SyntaxProtocol {}

/// Protocol to which all `ClosureSignatureSyntax` nodes conform. Extension point to add
/// common methods to all `ClosureSignatureSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol ClosureSignatureSyntaxProtocol: SyntaxProtocol {}


public struct ClosureSignatureSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case capture
    case input
    case throwsTok
    case output
    case inTok
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `ClosureSignatureSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .closureSignature else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `ClosureSignatureSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .closureSignature)
    self._syntaxNode = Syntax(data)
  }

  public var capture: ClosureCaptureSignatureSyntax? {
    get {
      let childData = data.child(at: Cursor.capture, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return ClosureCaptureSignatureSyntax(childData!)
    }
    set(value) {
      self = withCapture(value)
    }
  }

  /// Returns a copy of the receiver with its `capture` replaced.
  /// - param newChild: The new `capture` to replace the node's
  ///                   current `capture`, if present.
  public func withCapture(
    _ newChild: ClosureCaptureSignatureSyntax?) -> ClosureSignatureSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.capture)
    return ClosureSignatureSyntax(newData)
  }
  public var input: Syntax? {
    get {
      let childData = data.child(at: Cursor.input, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return Syntax(childData!)
    }
    set(value) {
      self = withInput(value)
    }
  }

  /// Returns a copy of the receiver with its `input` replaced.
  /// - param newChild: The new `input` to replace the node's
  ///                   current `input`, if present.
  public func withInput(
    _ newChild: Syntax?) -> ClosureSignatureSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.input)
    return ClosureSignatureSyntax(newData)
  }
  public var throwsTok: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.throwsTok, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withThrowsTok(value)
    }
  }

  /// Returns a copy of the receiver with its `throwsTok` replaced.
  /// - param newChild: The new `throwsTok` to replace the node's
  ///                   current `throwsTok`, if present.
  public func withThrowsTok(
    _ newChild: TokenSyntax?) -> ClosureSignatureSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.throwsTok)
    return ClosureSignatureSyntax(newData)
  }
  public var output: ReturnClauseSyntax? {
    get {
      let childData = data.child(at: Cursor.output, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return ReturnClauseSyntax(childData!)
    }
    set(value) {
      self = withOutput(value)
    }
  }

  /// Returns a copy of the receiver with its `output` replaced.
  /// - param newChild: The new `output` to replace the node's
  ///                   current `output`, if present.
  public func withOutput(
    _ newChild: ReturnClauseSyntax?) -> ClosureSignatureSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.output)
    return ClosureSignatureSyntax(newData)
  }
  public var inTok: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.inTok, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withInTok(value)
    }
  }

  /// Returns a copy of the receiver with its `inTok` replaced.
  /// - param newChild: The new `inTok` to replace the node's
  ///                   current `inTok`, if present.
  public func withInTok(
    _ newChild: TokenSyntax?) -> ClosureSignatureSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.inKeyword)
    let newData = data.replacingChild(raw, at: Cursor.inTok)
    return ClosureSignatureSyntax(newData)
  }

  /// Returns a new `ClosureSignatureSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> ClosureSignatureSyntax {
    return ClosureSignatureSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `ClosureSignatureSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> ClosureSignatureSyntax {
    return ClosureSignatureSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `ClosureSignatureSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> ClosureSignatureSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `ClosureSignatureSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> ClosureSignatureSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `ClosureSignatureSyntax` with all trivia removed.
  public func withoutTrivia() -> ClosureSignatureSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `ClosureSignatureSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `ClosureSignatureSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `ClosureExprSyntax` nodes conform. Extension point to add
/// common methods to all `ClosureExprSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol ClosureExprSyntaxProtocol: ExprSyntaxProtocol {}


public struct ClosureExprSyntax: ExprSyntaxProtocol {
  enum Cursor: Int {
    case leftBrace
    case signature
    case statements
    case rightBrace
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `ClosureExprSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .closureExpr else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `ClosureExprSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .closureExpr)
    self._syntaxNode = Syntax(data)
  }

  public var leftBrace: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.leftBrace, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withLeftBrace(value)
    }
  }

  /// Returns a copy of the receiver with its `leftBrace` replaced.
  /// - param newChild: The new `leftBrace` to replace the node's
  ///                   current `leftBrace`, if present.
  public func withLeftBrace(
    _ newChild: TokenSyntax?) -> ClosureExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.leftBrace)
    let newData = data.replacingChild(raw, at: Cursor.leftBrace)
    return ClosureExprSyntax(newData)
  }
  public var signature: ClosureSignatureSyntax? {
    get {
      let childData = data.child(at: Cursor.signature, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return ClosureSignatureSyntax(childData!)
    }
    set(value) {
      self = withSignature(value)
    }
  }

  /// Returns a copy of the receiver with its `signature` replaced.
  /// - param newChild: The new `signature` to replace the node's
  ///                   current `signature`, if present.
  public func withSignature(
    _ newChild: ClosureSignatureSyntax?) -> ClosureExprSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.signature)
    return ClosureExprSyntax(newData)
  }
  public var statements: CodeBlockItemListSyntax {
    get {
      let childData = data.child(at: Cursor.statements, 
                                 parent: Syntax(self))
      return CodeBlockItemListSyntax(childData!)
    }
    set(value) {
      self = withStatements(value)
    }
  }

  /// Adds the provided `Statement` to the node's `statements`
  /// collection.
  /// - param element: The new `Statement` to add to the node's
  ///                  `statements` collection.
  /// - returns: A copy of the receiver with the provided `Statement`
  ///            appended to its `statements` collection.
  public func addStatement(_ element: CodeBlockItemSyntax) -> ClosureExprSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.statements] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.codeBlockItemList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.statements)
    return ClosureExprSyntax(newData)
  }

  /// Returns a copy of the receiver with its `statements` replaced.
  /// - param newChild: The new `statements` to replace the node's
  ///                   current `statements`, if present.
  public func withStatements(
    _ newChild: CodeBlockItemListSyntax?) -> ClosureExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.codeBlockItemList)
    let newData = data.replacingChild(raw, at: Cursor.statements)
    return ClosureExprSyntax(newData)
  }
  public var rightBrace: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.rightBrace, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withRightBrace(value)
    }
  }

  /// Returns a copy of the receiver with its `rightBrace` replaced.
  /// - param newChild: The new `rightBrace` to replace the node's
  ///                   current `rightBrace`, if present.
  public func withRightBrace(
    _ newChild: TokenSyntax?) -> ClosureExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.rightBrace)
    let newData = data.replacingChild(raw, at: Cursor.rightBrace)
    return ClosureExprSyntax(newData)
  }

  /// Returns a new `ClosureExprSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> ClosureExprSyntax {
    return ClosureExprSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `ClosureExprSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> ClosureExprSyntax {
    return ClosureExprSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `ClosureExprSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> ClosureExprSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `ClosureExprSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> ClosureExprSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `ClosureExprSyntax` with all trivia removed.
  public func withoutTrivia() -> ClosureExprSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `ClosureExprSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `ClosureExprSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `UnresolvedPatternExprSyntax` nodes conform. Extension point to add
/// common methods to all `UnresolvedPatternExprSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol UnresolvedPatternExprSyntaxProtocol: ExprSyntaxProtocol {}


public struct UnresolvedPatternExprSyntax: ExprSyntaxProtocol {
  enum Cursor: Int {
    case pattern
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `UnresolvedPatternExprSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .unresolvedPatternExpr else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `UnresolvedPatternExprSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .unresolvedPatternExpr)
    self._syntaxNode = Syntax(data)
  }

  public var pattern: PatternSyntax {
    get {
      let childData = data.child(at: Cursor.pattern, 
                                 parent: Syntax(self))
      return PatternSyntax(childData!)
    }
    set(value) {
      self = withPattern(value)
    }
  }

  /// Returns a copy of the receiver with its `pattern` replaced.
  /// - param newChild: The new `pattern` to replace the node's
  ///                   current `pattern`, if present.
  public func withPattern(
    _ newChild: PatternSyntax?) -> UnresolvedPatternExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.pattern)
    let newData = data.replacingChild(raw, at: Cursor.pattern)
    return UnresolvedPatternExprSyntax(newData)
  }

  /// Returns a new `UnresolvedPatternExprSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> UnresolvedPatternExprSyntax {
    return UnresolvedPatternExprSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `UnresolvedPatternExprSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> UnresolvedPatternExprSyntax {
    return UnresolvedPatternExprSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `UnresolvedPatternExprSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> UnresolvedPatternExprSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `UnresolvedPatternExprSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> UnresolvedPatternExprSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `UnresolvedPatternExprSyntax` with all trivia removed.
  public func withoutTrivia() -> UnresolvedPatternExprSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `UnresolvedPatternExprSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `UnresolvedPatternExprSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `FunctionCallExprSyntax` nodes conform. Extension point to add
/// common methods to all `FunctionCallExprSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol FunctionCallExprSyntaxProtocol: ExprSyntaxProtocol {}


public struct FunctionCallExprSyntax: ExprSyntaxProtocol {
  enum Cursor: Int {
    case calledExpression
    case leftParen
    case argumentList
    case rightParen
    case trailingClosure
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `FunctionCallExprSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .functionCallExpr else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `FunctionCallExprSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .functionCallExpr)
    self._syntaxNode = Syntax(data)
  }

  public var calledExpression: ExprSyntax {
    get {
      let childData = data.child(at: Cursor.calledExpression, 
                                 parent: Syntax(self))
      return ExprSyntax(childData!)
    }
    set(value) {
      self = withCalledExpression(value)
    }
  }

  /// Returns a copy of the receiver with its `calledExpression` replaced.
  /// - param newChild: The new `calledExpression` to replace the node's
  ///                   current `calledExpression`, if present.
  public func withCalledExpression(
    _ newChild: ExprSyntax?) -> FunctionCallExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.expr)
    let newData = data.replacingChild(raw, at: Cursor.calledExpression)
    return FunctionCallExprSyntax(newData)
  }
  public var leftParen: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.leftParen, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withLeftParen(value)
    }
  }

  /// Returns a copy of the receiver with its `leftParen` replaced.
  /// - param newChild: The new `leftParen` to replace the node's
  ///                   current `leftParen`, if present.
  public func withLeftParen(
    _ newChild: TokenSyntax?) -> FunctionCallExprSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.leftParen)
    return FunctionCallExprSyntax(newData)
  }
  public var argumentList: TupleExprElementListSyntax {
    get {
      let childData = data.child(at: Cursor.argumentList, 
                                 parent: Syntax(self))
      return TupleExprElementListSyntax(childData!)
    }
    set(value) {
      self = withArgumentList(value)
    }
  }

  /// Adds the provided `Argument` to the node's `argumentList`
  /// collection.
  /// - param element: The new `Argument` to add to the node's
  ///                  `argumentList` collection.
  /// - returns: A copy of the receiver with the provided `Argument`
  ///            appended to its `argumentList` collection.
  public func addArgument(_ element: TupleExprElementSyntax) -> FunctionCallExprSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.argumentList] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.tupleExprElementList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.argumentList)
    return FunctionCallExprSyntax(newData)
  }

  /// Returns a copy of the receiver with its `argumentList` replaced.
  /// - param newChild: The new `argumentList` to replace the node's
  ///                   current `argumentList`, if present.
  public func withArgumentList(
    _ newChild: TupleExprElementListSyntax?) -> FunctionCallExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.tupleExprElementList)
    let newData = data.replacingChild(raw, at: Cursor.argumentList)
    return FunctionCallExprSyntax(newData)
  }
  public var rightParen: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.rightParen, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withRightParen(value)
    }
  }

  /// Returns a copy of the receiver with its `rightParen` replaced.
  /// - param newChild: The new `rightParen` to replace the node's
  ///                   current `rightParen`, if present.
  public func withRightParen(
    _ newChild: TokenSyntax?) -> FunctionCallExprSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.rightParen)
    return FunctionCallExprSyntax(newData)
  }
  public var trailingClosure: ClosureExprSyntax? {
    get {
      let childData = data.child(at: Cursor.trailingClosure, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return ClosureExprSyntax(childData!)
    }
    set(value) {
      self = withTrailingClosure(value)
    }
  }

  /// Returns a copy of the receiver with its `trailingClosure` replaced.
  /// - param newChild: The new `trailingClosure` to replace the node's
  ///                   current `trailingClosure`, if present.
  public func withTrailingClosure(
    _ newChild: ClosureExprSyntax?) -> FunctionCallExprSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.trailingClosure)
    return FunctionCallExprSyntax(newData)
  }

  /// Returns a new `FunctionCallExprSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> FunctionCallExprSyntax {
    return FunctionCallExprSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `FunctionCallExprSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> FunctionCallExprSyntax {
    return FunctionCallExprSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `FunctionCallExprSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> FunctionCallExprSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `FunctionCallExprSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> FunctionCallExprSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `FunctionCallExprSyntax` with all trivia removed.
  public func withoutTrivia() -> FunctionCallExprSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `FunctionCallExprSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `FunctionCallExprSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `SubscriptExprSyntax` nodes conform. Extension point to add
/// common methods to all `SubscriptExprSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol SubscriptExprSyntaxProtocol: ExprSyntaxProtocol {}


public struct SubscriptExprSyntax: ExprSyntaxProtocol {
  enum Cursor: Int {
    case calledExpression
    case leftBracket
    case argumentList
    case rightBracket
    case trailingClosure
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `SubscriptExprSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .subscriptExpr else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `SubscriptExprSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .subscriptExpr)
    self._syntaxNode = Syntax(data)
  }

  public var calledExpression: ExprSyntax {
    get {
      let childData = data.child(at: Cursor.calledExpression, 
                                 parent: Syntax(self))
      return ExprSyntax(childData!)
    }
    set(value) {
      self = withCalledExpression(value)
    }
  }

  /// Returns a copy of the receiver with its `calledExpression` replaced.
  /// - param newChild: The new `calledExpression` to replace the node's
  ///                   current `calledExpression`, if present.
  public func withCalledExpression(
    _ newChild: ExprSyntax?) -> SubscriptExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.expr)
    let newData = data.replacingChild(raw, at: Cursor.calledExpression)
    return SubscriptExprSyntax(newData)
  }
  public var leftBracket: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.leftBracket, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withLeftBracket(value)
    }
  }

  /// Returns a copy of the receiver with its `leftBracket` replaced.
  /// - param newChild: The new `leftBracket` to replace the node's
  ///                   current `leftBracket`, if present.
  public func withLeftBracket(
    _ newChild: TokenSyntax?) -> SubscriptExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.leftSquareBracket)
    let newData = data.replacingChild(raw, at: Cursor.leftBracket)
    return SubscriptExprSyntax(newData)
  }
  public var argumentList: TupleExprElementListSyntax {
    get {
      let childData = data.child(at: Cursor.argumentList, 
                                 parent: Syntax(self))
      return TupleExprElementListSyntax(childData!)
    }
    set(value) {
      self = withArgumentList(value)
    }
  }

  /// Adds the provided `Argument` to the node's `argumentList`
  /// collection.
  /// - param element: The new `Argument` to add to the node's
  ///                  `argumentList` collection.
  /// - returns: A copy of the receiver with the provided `Argument`
  ///            appended to its `argumentList` collection.
  public func addArgument(_ element: TupleExprElementSyntax) -> SubscriptExprSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.argumentList] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.tupleExprElementList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.argumentList)
    return SubscriptExprSyntax(newData)
  }

  /// Returns a copy of the receiver with its `argumentList` replaced.
  /// - param newChild: The new `argumentList` to replace the node's
  ///                   current `argumentList`, if present.
  public func withArgumentList(
    _ newChild: TupleExprElementListSyntax?) -> SubscriptExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.tupleExprElementList)
    let newData = data.replacingChild(raw, at: Cursor.argumentList)
    return SubscriptExprSyntax(newData)
  }
  public var rightBracket: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.rightBracket, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withRightBracket(value)
    }
  }

  /// Returns a copy of the receiver with its `rightBracket` replaced.
  /// - param newChild: The new `rightBracket` to replace the node's
  ///                   current `rightBracket`, if present.
  public func withRightBracket(
    _ newChild: TokenSyntax?) -> SubscriptExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.rightSquareBracket)
    let newData = data.replacingChild(raw, at: Cursor.rightBracket)
    return SubscriptExprSyntax(newData)
  }
  public var trailingClosure: ClosureExprSyntax? {
    get {
      let childData = data.child(at: Cursor.trailingClosure, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return ClosureExprSyntax(childData!)
    }
    set(value) {
      self = withTrailingClosure(value)
    }
  }

  /// Returns a copy of the receiver with its `trailingClosure` replaced.
  /// - param newChild: The new `trailingClosure` to replace the node's
  ///                   current `trailingClosure`, if present.
  public func withTrailingClosure(
    _ newChild: ClosureExprSyntax?) -> SubscriptExprSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.trailingClosure)
    return SubscriptExprSyntax(newData)
  }

  /// Returns a new `SubscriptExprSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> SubscriptExprSyntax {
    return SubscriptExprSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `SubscriptExprSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> SubscriptExprSyntax {
    return SubscriptExprSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `SubscriptExprSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> SubscriptExprSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `SubscriptExprSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> SubscriptExprSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `SubscriptExprSyntax` with all trivia removed.
  public func withoutTrivia() -> SubscriptExprSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `SubscriptExprSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `SubscriptExprSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `OptionalChainingExprSyntax` nodes conform. Extension point to add
/// common methods to all `OptionalChainingExprSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol OptionalChainingExprSyntaxProtocol: ExprSyntaxProtocol {}


public struct OptionalChainingExprSyntax: ExprSyntaxProtocol {
  enum Cursor: Int {
    case expression
    case questionMark
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `OptionalChainingExprSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .optionalChainingExpr else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `OptionalChainingExprSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .optionalChainingExpr)
    self._syntaxNode = Syntax(data)
  }

  public var expression: ExprSyntax {
    get {
      let childData = data.child(at: Cursor.expression, 
                                 parent: Syntax(self))
      return ExprSyntax(childData!)
    }
    set(value) {
      self = withExpression(value)
    }
  }

  /// Returns a copy of the receiver with its `expression` replaced.
  /// - param newChild: The new `expression` to replace the node's
  ///                   current `expression`, if present.
  public func withExpression(
    _ newChild: ExprSyntax?) -> OptionalChainingExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.expr)
    let newData = data.replacingChild(raw, at: Cursor.expression)
    return OptionalChainingExprSyntax(newData)
  }
  public var questionMark: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.questionMark, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withQuestionMark(value)
    }
  }

  /// Returns a copy of the receiver with its `questionMark` replaced.
  /// - param newChild: The new `questionMark` to replace the node's
  ///                   current `questionMark`, if present.
  public func withQuestionMark(
    _ newChild: TokenSyntax?) -> OptionalChainingExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.postfixQuestionMark)
    let newData = data.replacingChild(raw, at: Cursor.questionMark)
    return OptionalChainingExprSyntax(newData)
  }

  /// Returns a new `OptionalChainingExprSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> OptionalChainingExprSyntax {
    return OptionalChainingExprSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `OptionalChainingExprSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> OptionalChainingExprSyntax {
    return OptionalChainingExprSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `OptionalChainingExprSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> OptionalChainingExprSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `OptionalChainingExprSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> OptionalChainingExprSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `OptionalChainingExprSyntax` with all trivia removed.
  public func withoutTrivia() -> OptionalChainingExprSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `OptionalChainingExprSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `OptionalChainingExprSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `ForcedValueExprSyntax` nodes conform. Extension point to add
/// common methods to all `ForcedValueExprSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol ForcedValueExprSyntaxProtocol: ExprSyntaxProtocol {}


public struct ForcedValueExprSyntax: ExprSyntaxProtocol {
  enum Cursor: Int {
    case expression
    case exclamationMark
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `ForcedValueExprSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .forcedValueExpr else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `ForcedValueExprSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .forcedValueExpr)
    self._syntaxNode = Syntax(data)
  }

  public var expression: ExprSyntax {
    get {
      let childData = data.child(at: Cursor.expression, 
                                 parent: Syntax(self))
      return ExprSyntax(childData!)
    }
    set(value) {
      self = withExpression(value)
    }
  }

  /// Returns a copy of the receiver with its `expression` replaced.
  /// - param newChild: The new `expression` to replace the node's
  ///                   current `expression`, if present.
  public func withExpression(
    _ newChild: ExprSyntax?) -> ForcedValueExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.expr)
    let newData = data.replacingChild(raw, at: Cursor.expression)
    return ForcedValueExprSyntax(newData)
  }
  public var exclamationMark: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.exclamationMark, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withExclamationMark(value)
    }
  }

  /// Returns a copy of the receiver with its `exclamationMark` replaced.
  /// - param newChild: The new `exclamationMark` to replace the node's
  ///                   current `exclamationMark`, if present.
  public func withExclamationMark(
    _ newChild: TokenSyntax?) -> ForcedValueExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.exclamationMark)
    let newData = data.replacingChild(raw, at: Cursor.exclamationMark)
    return ForcedValueExprSyntax(newData)
  }

  /// Returns a new `ForcedValueExprSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> ForcedValueExprSyntax {
    return ForcedValueExprSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `ForcedValueExprSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> ForcedValueExprSyntax {
    return ForcedValueExprSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `ForcedValueExprSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> ForcedValueExprSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `ForcedValueExprSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> ForcedValueExprSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `ForcedValueExprSyntax` with all trivia removed.
  public func withoutTrivia() -> ForcedValueExprSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `ForcedValueExprSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `ForcedValueExprSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `PostfixUnaryExprSyntax` nodes conform. Extension point to add
/// common methods to all `PostfixUnaryExprSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol PostfixUnaryExprSyntaxProtocol: ExprSyntaxProtocol {}


public struct PostfixUnaryExprSyntax: ExprSyntaxProtocol {
  enum Cursor: Int {
    case expression
    case operatorToken
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `PostfixUnaryExprSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .postfixUnaryExpr else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `PostfixUnaryExprSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .postfixUnaryExpr)
    self._syntaxNode = Syntax(data)
  }

  public var expression: ExprSyntax {
    get {
      let childData = data.child(at: Cursor.expression, 
                                 parent: Syntax(self))
      return ExprSyntax(childData!)
    }
    set(value) {
      self = withExpression(value)
    }
  }

  /// Returns a copy of the receiver with its `expression` replaced.
  /// - param newChild: The new `expression` to replace the node's
  ///                   current `expression`, if present.
  public func withExpression(
    _ newChild: ExprSyntax?) -> PostfixUnaryExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.expr)
    let newData = data.replacingChild(raw, at: Cursor.expression)
    return PostfixUnaryExprSyntax(newData)
  }
  public var operatorToken: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.operatorToken, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withOperatorToken(value)
    }
  }

  /// Returns a copy of the receiver with its `operatorToken` replaced.
  /// - param newChild: The new `operatorToken` to replace the node's
  ///                   current `operatorToken`, if present.
  public func withOperatorToken(
    _ newChild: TokenSyntax?) -> PostfixUnaryExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.postfixOperator(""))
    let newData = data.replacingChild(raw, at: Cursor.operatorToken)
    return PostfixUnaryExprSyntax(newData)
  }

  /// Returns a new `PostfixUnaryExprSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> PostfixUnaryExprSyntax {
    return PostfixUnaryExprSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `PostfixUnaryExprSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> PostfixUnaryExprSyntax {
    return PostfixUnaryExprSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `PostfixUnaryExprSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> PostfixUnaryExprSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `PostfixUnaryExprSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> PostfixUnaryExprSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `PostfixUnaryExprSyntax` with all trivia removed.
  public func withoutTrivia() -> PostfixUnaryExprSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `PostfixUnaryExprSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `PostfixUnaryExprSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `SpecializeExprSyntax` nodes conform. Extension point to add
/// common methods to all `SpecializeExprSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol SpecializeExprSyntaxProtocol: ExprSyntaxProtocol {}


public struct SpecializeExprSyntax: ExprSyntaxProtocol {
  enum Cursor: Int {
    case expression
    case genericArgumentClause
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `SpecializeExprSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .specializeExpr else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `SpecializeExprSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .specializeExpr)
    self._syntaxNode = Syntax(data)
  }

  public var expression: ExprSyntax {
    get {
      let childData = data.child(at: Cursor.expression, 
                                 parent: Syntax(self))
      return ExprSyntax(childData!)
    }
    set(value) {
      self = withExpression(value)
    }
  }

  /// Returns a copy of the receiver with its `expression` replaced.
  /// - param newChild: The new `expression` to replace the node's
  ///                   current `expression`, if present.
  public func withExpression(
    _ newChild: ExprSyntax?) -> SpecializeExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.expr)
    let newData = data.replacingChild(raw, at: Cursor.expression)
    return SpecializeExprSyntax(newData)
  }
  public var genericArgumentClause: GenericArgumentClauseSyntax {
    get {
      let childData = data.child(at: Cursor.genericArgumentClause, 
                                 parent: Syntax(self))
      return GenericArgumentClauseSyntax(childData!)
    }
    set(value) {
      self = withGenericArgumentClause(value)
    }
  }

  /// Returns a copy of the receiver with its `genericArgumentClause` replaced.
  /// - param newChild: The new `genericArgumentClause` to replace the node's
  ///                   current `genericArgumentClause`, if present.
  public func withGenericArgumentClause(
    _ newChild: GenericArgumentClauseSyntax?) -> SpecializeExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.genericArgumentClause)
    let newData = data.replacingChild(raw, at: Cursor.genericArgumentClause)
    return SpecializeExprSyntax(newData)
  }

  /// Returns a new `SpecializeExprSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> SpecializeExprSyntax {
    return SpecializeExprSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `SpecializeExprSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> SpecializeExprSyntax {
    return SpecializeExprSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `SpecializeExprSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> SpecializeExprSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `SpecializeExprSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> SpecializeExprSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `SpecializeExprSyntax` with all trivia removed.
  public func withoutTrivia() -> SpecializeExprSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `SpecializeExprSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `SpecializeExprSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `StringSegmentSyntax` nodes conform. Extension point to add
/// common methods to all `StringSegmentSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol StringSegmentSyntaxProtocol: SyntaxProtocol {}


public struct StringSegmentSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case content
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `StringSegmentSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .stringSegment else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `StringSegmentSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .stringSegment)
    self._syntaxNode = Syntax(data)
  }

  public var content: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.content, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withContent(value)
    }
  }

  /// Returns a copy of the receiver with its `content` replaced.
  /// - param newChild: The new `content` to replace the node's
  ///                   current `content`, if present.
  public func withContent(
    _ newChild: TokenSyntax?) -> StringSegmentSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.stringSegment(""))
    let newData = data.replacingChild(raw, at: Cursor.content)
    return StringSegmentSyntax(newData)
  }

  /// Returns a new `StringSegmentSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> StringSegmentSyntax {
    return StringSegmentSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `StringSegmentSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> StringSegmentSyntax {
    return StringSegmentSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `StringSegmentSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> StringSegmentSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `StringSegmentSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> StringSegmentSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `StringSegmentSyntax` with all trivia removed.
  public func withoutTrivia() -> StringSegmentSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `StringSegmentSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `StringSegmentSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `ExpressionSegmentSyntax` nodes conform. Extension point to add
/// common methods to all `ExpressionSegmentSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol ExpressionSegmentSyntaxProtocol: SyntaxProtocol {}


public struct ExpressionSegmentSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case backslash
    case delimiter
    case leftParen
    case expressions
    case rightParen
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `ExpressionSegmentSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .expressionSegment else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `ExpressionSegmentSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .expressionSegment)
    self._syntaxNode = Syntax(data)
  }

  public var backslash: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.backslash, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withBackslash(value)
    }
  }

  /// Returns a copy of the receiver with its `backslash` replaced.
  /// - param newChild: The new `backslash` to replace the node's
  ///                   current `backslash`, if present.
  public func withBackslash(
    _ newChild: TokenSyntax?) -> ExpressionSegmentSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.backslash)
    let newData = data.replacingChild(raw, at: Cursor.backslash)
    return ExpressionSegmentSyntax(newData)
  }
  public var delimiter: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.delimiter, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withDelimiter(value)
    }
  }

  /// Returns a copy of the receiver with its `delimiter` replaced.
  /// - param newChild: The new `delimiter` to replace the node's
  ///                   current `delimiter`, if present.
  public func withDelimiter(
    _ newChild: TokenSyntax?) -> ExpressionSegmentSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.delimiter)
    return ExpressionSegmentSyntax(newData)
  }
  public var leftParen: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.leftParen, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withLeftParen(value)
    }
  }

  /// Returns a copy of the receiver with its `leftParen` replaced.
  /// - param newChild: The new `leftParen` to replace the node's
  ///                   current `leftParen`, if present.
  public func withLeftParen(
    _ newChild: TokenSyntax?) -> ExpressionSegmentSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.leftParen)
    let newData = data.replacingChild(raw, at: Cursor.leftParen)
    return ExpressionSegmentSyntax(newData)
  }
  public var expressions: TupleExprElementListSyntax {
    get {
      let childData = data.child(at: Cursor.expressions, 
                                 parent: Syntax(self))
      return TupleExprElementListSyntax(childData!)
    }
    set(value) {
      self = withExpressions(value)
    }
  }

  /// Adds the provided `Expression` to the node's `expressions`
  /// collection.
  /// - param element: The new `Expression` to add to the node's
  ///                  `expressions` collection.
  /// - returns: A copy of the receiver with the provided `Expression`
  ///            appended to its `expressions` collection.
  public func addExpression(_ element: TupleExprElementSyntax) -> ExpressionSegmentSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.expressions] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.tupleExprElementList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.expressions)
    return ExpressionSegmentSyntax(newData)
  }

  /// Returns a copy of the receiver with its `expressions` replaced.
  /// - param newChild: The new `expressions` to replace the node's
  ///                   current `expressions`, if present.
  public func withExpressions(
    _ newChild: TupleExprElementListSyntax?) -> ExpressionSegmentSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.tupleExprElementList)
    let newData = data.replacingChild(raw, at: Cursor.expressions)
    return ExpressionSegmentSyntax(newData)
  }
  public var rightParen: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.rightParen, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withRightParen(value)
    }
  }

  /// Returns a copy of the receiver with its `rightParen` replaced.
  /// - param newChild: The new `rightParen` to replace the node's
  ///                   current `rightParen`, if present.
  public func withRightParen(
    _ newChild: TokenSyntax?) -> ExpressionSegmentSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.stringInterpolationAnchor)
    let newData = data.replacingChild(raw, at: Cursor.rightParen)
    return ExpressionSegmentSyntax(newData)
  }

  /// Returns a new `ExpressionSegmentSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> ExpressionSegmentSyntax {
    return ExpressionSegmentSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `ExpressionSegmentSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> ExpressionSegmentSyntax {
    return ExpressionSegmentSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `ExpressionSegmentSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> ExpressionSegmentSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `ExpressionSegmentSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> ExpressionSegmentSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `ExpressionSegmentSyntax` with all trivia removed.
  public func withoutTrivia() -> ExpressionSegmentSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `ExpressionSegmentSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `ExpressionSegmentSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `StringLiteralExprSyntax` nodes conform. Extension point to add
/// common methods to all `StringLiteralExprSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol StringLiteralExprSyntaxProtocol: ExprSyntaxProtocol {}


public struct StringLiteralExprSyntax: ExprSyntaxProtocol {
  enum Cursor: Int {
    case openDelimiter
    case openQuote
    case segments
    case closeQuote
    case closeDelimiter
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `StringLiteralExprSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .stringLiteralExpr else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `StringLiteralExprSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .stringLiteralExpr)
    self._syntaxNode = Syntax(data)
  }

  public var openDelimiter: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.openDelimiter, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withOpenDelimiter(value)
    }
  }

  /// Returns a copy of the receiver with its `openDelimiter` replaced.
  /// - param newChild: The new `openDelimiter` to replace the node's
  ///                   current `openDelimiter`, if present.
  public func withOpenDelimiter(
    _ newChild: TokenSyntax?) -> StringLiteralExprSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.openDelimiter)
    return StringLiteralExprSyntax(newData)
  }
  public var openQuote: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.openQuote, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withOpenQuote(value)
    }
  }

  /// Returns a copy of the receiver with its `openQuote` replaced.
  /// - param newChild: The new `openQuote` to replace the node's
  ///                   current `openQuote`, if present.
  public func withOpenQuote(
    _ newChild: TokenSyntax?) -> StringLiteralExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.stringQuote)
    let newData = data.replacingChild(raw, at: Cursor.openQuote)
    return StringLiteralExprSyntax(newData)
  }
  public var segments: StringLiteralSegmentsSyntax {
    get {
      let childData = data.child(at: Cursor.segments, 
                                 parent: Syntax(self))
      return StringLiteralSegmentsSyntax(childData!)
    }
    set(value) {
      self = withSegments(value)
    }
  }

  /// Adds the provided `Segment` to the node's `segments`
  /// collection.
  /// - param element: The new `Segment` to add to the node's
  ///                  `segments` collection.
  /// - returns: A copy of the receiver with the provided `Segment`
  ///            appended to its `segments` collection.
  public func addSegment(_ element: Syntax) -> StringLiteralExprSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.segments] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.stringLiteralSegments,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.segments)
    return StringLiteralExprSyntax(newData)
  }

  /// Returns a copy of the receiver with its `segments` replaced.
  /// - param newChild: The new `segments` to replace the node's
  ///                   current `segments`, if present.
  public func withSegments(
    _ newChild: StringLiteralSegmentsSyntax?) -> StringLiteralExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.stringLiteralSegments)
    let newData = data.replacingChild(raw, at: Cursor.segments)
    return StringLiteralExprSyntax(newData)
  }
  public var closeQuote: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.closeQuote, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withCloseQuote(value)
    }
  }

  /// Returns a copy of the receiver with its `closeQuote` replaced.
  /// - param newChild: The new `closeQuote` to replace the node's
  ///                   current `closeQuote`, if present.
  public func withCloseQuote(
    _ newChild: TokenSyntax?) -> StringLiteralExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.stringQuote)
    let newData = data.replacingChild(raw, at: Cursor.closeQuote)
    return StringLiteralExprSyntax(newData)
  }
  public var closeDelimiter: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.closeDelimiter, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withCloseDelimiter(value)
    }
  }

  /// Returns a copy of the receiver with its `closeDelimiter` replaced.
  /// - param newChild: The new `closeDelimiter` to replace the node's
  ///                   current `closeDelimiter`, if present.
  public func withCloseDelimiter(
    _ newChild: TokenSyntax?) -> StringLiteralExprSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.closeDelimiter)
    return StringLiteralExprSyntax(newData)
  }

  /// Returns a new `StringLiteralExprSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> StringLiteralExprSyntax {
    return StringLiteralExprSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `StringLiteralExprSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> StringLiteralExprSyntax {
    return StringLiteralExprSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `StringLiteralExprSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> StringLiteralExprSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `StringLiteralExprSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> StringLiteralExprSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `StringLiteralExprSyntax` with all trivia removed.
  public func withoutTrivia() -> StringLiteralExprSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `StringLiteralExprSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `StringLiteralExprSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `KeyPathExprSyntax` nodes conform. Extension point to add
/// common methods to all `KeyPathExprSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol KeyPathExprSyntaxProtocol: ExprSyntaxProtocol {}


public struct KeyPathExprSyntax: ExprSyntaxProtocol {
  enum Cursor: Int {
    case backslash
    case rootExpr
    case expression
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `KeyPathExprSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .keyPathExpr else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `KeyPathExprSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .keyPathExpr)
    self._syntaxNode = Syntax(data)
  }

  public var backslash: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.backslash, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withBackslash(value)
    }
  }

  /// Returns a copy of the receiver with its `backslash` replaced.
  /// - param newChild: The new `backslash` to replace the node's
  ///                   current `backslash`, if present.
  public func withBackslash(
    _ newChild: TokenSyntax?) -> KeyPathExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.backslash)
    let newData = data.replacingChild(raw, at: Cursor.backslash)
    return KeyPathExprSyntax(newData)
  }
  public var rootExpr: ExprSyntax? {
    get {
      let childData = data.child(at: Cursor.rootExpr, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return ExprSyntax(childData!)
    }
    set(value) {
      self = withRootExpr(value)
    }
  }

  /// Returns a copy of the receiver with its `rootExpr` replaced.
  /// - param newChild: The new `rootExpr` to replace the node's
  ///                   current `rootExpr`, if present.
  public func withRootExpr(
    _ newChild: ExprSyntax?) -> KeyPathExprSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.rootExpr)
    return KeyPathExprSyntax(newData)
  }
  public var expression: ExprSyntax {
    get {
      let childData = data.child(at: Cursor.expression, 
                                 parent: Syntax(self))
      return ExprSyntax(childData!)
    }
    set(value) {
      self = withExpression(value)
    }
  }

  /// Returns a copy of the receiver with its `expression` replaced.
  /// - param newChild: The new `expression` to replace the node's
  ///                   current `expression`, if present.
  public func withExpression(
    _ newChild: ExprSyntax?) -> KeyPathExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.expr)
    let newData = data.replacingChild(raw, at: Cursor.expression)
    return KeyPathExprSyntax(newData)
  }

  /// Returns a new `KeyPathExprSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> KeyPathExprSyntax {
    return KeyPathExprSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `KeyPathExprSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> KeyPathExprSyntax {
    return KeyPathExprSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `KeyPathExprSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> KeyPathExprSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `KeyPathExprSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> KeyPathExprSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `KeyPathExprSyntax` with all trivia removed.
  public func withoutTrivia() -> KeyPathExprSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `KeyPathExprSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `KeyPathExprSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `KeyPathBaseExprSyntax` nodes conform. Extension point to add
/// common methods to all `KeyPathBaseExprSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol KeyPathBaseExprSyntaxProtocol: ExprSyntaxProtocol {}


public struct KeyPathBaseExprSyntax: ExprSyntaxProtocol {
  enum Cursor: Int {
    case period
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `KeyPathBaseExprSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .keyPathBaseExpr else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `KeyPathBaseExprSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .keyPathBaseExpr)
    self._syntaxNode = Syntax(data)
  }

  public var period: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.period, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withPeriod(value)
    }
  }

  /// Returns a copy of the receiver with its `period` replaced.
  /// - param newChild: The new `period` to replace the node's
  ///                   current `period`, if present.
  public func withPeriod(
    _ newChild: TokenSyntax?) -> KeyPathBaseExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.period)
    let newData = data.replacingChild(raw, at: Cursor.period)
    return KeyPathBaseExprSyntax(newData)
  }

  /// Returns a new `KeyPathBaseExprSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> KeyPathBaseExprSyntax {
    return KeyPathBaseExprSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `KeyPathBaseExprSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> KeyPathBaseExprSyntax {
    return KeyPathBaseExprSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `KeyPathBaseExprSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> KeyPathBaseExprSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `KeyPathBaseExprSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> KeyPathBaseExprSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `KeyPathBaseExprSyntax` with all trivia removed.
  public func withoutTrivia() -> KeyPathBaseExprSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `KeyPathBaseExprSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `KeyPathBaseExprSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `ObjcNamePieceSyntax` nodes conform. Extension point to add
/// common methods to all `ObjcNamePieceSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol ObjcNamePieceSyntaxProtocol: SyntaxProtocol {}


public struct ObjcNamePieceSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case name
    case dot
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `ObjcNamePieceSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .objcNamePiece else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `ObjcNamePieceSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .objcNamePiece)
    self._syntaxNode = Syntax(data)
  }

  public var name: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.name, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withName(value)
    }
  }

  /// Returns a copy of the receiver with its `name` replaced.
  /// - param newChild: The new `name` to replace the node's
  ///                   current `name`, if present.
  public func withName(
    _ newChild: TokenSyntax?) -> ObjcNamePieceSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let newData = data.replacingChild(raw, at: Cursor.name)
    return ObjcNamePieceSyntax(newData)
  }
  public var dot: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.dot, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withDot(value)
    }
  }

  /// Returns a copy of the receiver with its `dot` replaced.
  /// - param newChild: The new `dot` to replace the node's
  ///                   current `dot`, if present.
  public func withDot(
    _ newChild: TokenSyntax?) -> ObjcNamePieceSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.dot)
    return ObjcNamePieceSyntax(newData)
  }

  /// Returns a new `ObjcNamePieceSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> ObjcNamePieceSyntax {
    return ObjcNamePieceSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `ObjcNamePieceSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> ObjcNamePieceSyntax {
    return ObjcNamePieceSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `ObjcNamePieceSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> ObjcNamePieceSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `ObjcNamePieceSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> ObjcNamePieceSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `ObjcNamePieceSyntax` with all trivia removed.
  public func withoutTrivia() -> ObjcNamePieceSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `ObjcNamePieceSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `ObjcNamePieceSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `ObjcNameSyntax` nodes conform. Extension point to add
/// common methods to all `ObjcNameSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol ObjcNameSyntaxProtocol: SyntaxProtocol {}

/// Protocol to which all `ObjcKeyPathExprSyntax` nodes conform. Extension point to add
/// common methods to all `ObjcKeyPathExprSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol ObjcKeyPathExprSyntaxProtocol: ExprSyntaxProtocol {}


public struct ObjcKeyPathExprSyntax: ExprSyntaxProtocol {
  enum Cursor: Int {
    case keyPath
    case leftParen
    case name
    case rightParen
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `ObjcKeyPathExprSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .objcKeyPathExpr else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `ObjcKeyPathExprSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .objcKeyPathExpr)
    self._syntaxNode = Syntax(data)
  }

  public var keyPath: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.keyPath, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withKeyPath(value)
    }
  }

  /// Returns a copy of the receiver with its `keyPath` replaced.
  /// - param newChild: The new `keyPath` to replace the node's
  ///                   current `keyPath`, if present.
  public func withKeyPath(
    _ newChild: TokenSyntax?) -> ObjcKeyPathExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.poundKeyPathKeyword)
    let newData = data.replacingChild(raw, at: Cursor.keyPath)
    return ObjcKeyPathExprSyntax(newData)
  }
  public var leftParen: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.leftParen, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withLeftParen(value)
    }
  }

  /// Returns a copy of the receiver with its `leftParen` replaced.
  /// - param newChild: The new `leftParen` to replace the node's
  ///                   current `leftParen`, if present.
  public func withLeftParen(
    _ newChild: TokenSyntax?) -> ObjcKeyPathExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.leftParen)
    let newData = data.replacingChild(raw, at: Cursor.leftParen)
    return ObjcKeyPathExprSyntax(newData)
  }
  public var name: ObjcNameSyntax {
    get {
      let childData = data.child(at: Cursor.name, 
                                 parent: Syntax(self))
      return ObjcNameSyntax(childData!)
    }
    set(value) {
      self = withName(value)
    }
  }

  /// Adds the provided `NamePiece` to the node's `name`
  /// collection.
  /// - param element: The new `NamePiece` to add to the node's
  ///                  `name` collection.
  /// - returns: A copy of the receiver with the provided `NamePiece`
  ///            appended to its `name` collection.
  public func addNamePiece(_ element: ObjcNamePieceSyntax) -> ObjcKeyPathExprSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.name] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.objcName,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.name)
    return ObjcKeyPathExprSyntax(newData)
  }

  /// Returns a copy of the receiver with its `name` replaced.
  /// - param newChild: The new `name` to replace the node's
  ///                   current `name`, if present.
  public func withName(
    _ newChild: ObjcNameSyntax?) -> ObjcKeyPathExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.objcName)
    let newData = data.replacingChild(raw, at: Cursor.name)
    return ObjcKeyPathExprSyntax(newData)
  }
  public var rightParen: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.rightParen, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withRightParen(value)
    }
  }

  /// Returns a copy of the receiver with its `rightParen` replaced.
  /// - param newChild: The new `rightParen` to replace the node's
  ///                   current `rightParen`, if present.
  public func withRightParen(
    _ newChild: TokenSyntax?) -> ObjcKeyPathExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.rightParen)
    let newData = data.replacingChild(raw, at: Cursor.rightParen)
    return ObjcKeyPathExprSyntax(newData)
  }

  /// Returns a new `ObjcKeyPathExprSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> ObjcKeyPathExprSyntax {
    return ObjcKeyPathExprSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `ObjcKeyPathExprSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> ObjcKeyPathExprSyntax {
    return ObjcKeyPathExprSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `ObjcKeyPathExprSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> ObjcKeyPathExprSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `ObjcKeyPathExprSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> ObjcKeyPathExprSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `ObjcKeyPathExprSyntax` with all trivia removed.
  public func withoutTrivia() -> ObjcKeyPathExprSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `ObjcKeyPathExprSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `ObjcKeyPathExprSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `ObjcSelectorExprSyntax` nodes conform. Extension point to add
/// common methods to all `ObjcSelectorExprSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol ObjcSelectorExprSyntaxProtocol: ExprSyntaxProtocol {}


public struct ObjcSelectorExprSyntax: ExprSyntaxProtocol {
  enum Cursor: Int {
    case poundSelector
    case leftParen
    case kind
    case colon
    case name
    case rightParen
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `ObjcSelectorExprSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .objcSelectorExpr else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `ObjcSelectorExprSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .objcSelectorExpr)
    self._syntaxNode = Syntax(data)
  }

  public var poundSelector: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.poundSelector, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withPoundSelector(value)
    }
  }

  /// Returns a copy of the receiver with its `poundSelector` replaced.
  /// - param newChild: The new `poundSelector` to replace the node's
  ///                   current `poundSelector`, if present.
  public func withPoundSelector(
    _ newChild: TokenSyntax?) -> ObjcSelectorExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.poundSelectorKeyword)
    let newData = data.replacingChild(raw, at: Cursor.poundSelector)
    return ObjcSelectorExprSyntax(newData)
  }
  public var leftParen: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.leftParen, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withLeftParen(value)
    }
  }

  /// Returns a copy of the receiver with its `leftParen` replaced.
  /// - param newChild: The new `leftParen` to replace the node's
  ///                   current `leftParen`, if present.
  public func withLeftParen(
    _ newChild: TokenSyntax?) -> ObjcSelectorExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.leftParen)
    let newData = data.replacingChild(raw, at: Cursor.leftParen)
    return ObjcSelectorExprSyntax(newData)
  }
  public var kind: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.kind, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withKind(value)
    }
  }

  /// Returns a copy of the receiver with its `kind` replaced.
  /// - param newChild: The new `kind` to replace the node's
  ///                   current `kind`, if present.
  public func withKind(
    _ newChild: TokenSyntax?) -> ObjcSelectorExprSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.kind)
    return ObjcSelectorExprSyntax(newData)
  }
  public var colon: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.colon, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withColon(value)
    }
  }

  /// Returns a copy of the receiver with its `colon` replaced.
  /// - param newChild: The new `colon` to replace the node's
  ///                   current `colon`, if present.
  public func withColon(
    _ newChild: TokenSyntax?) -> ObjcSelectorExprSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.colon)
    return ObjcSelectorExprSyntax(newData)
  }
  public var name: ExprSyntax {
    get {
      let childData = data.child(at: Cursor.name, 
                                 parent: Syntax(self))
      return ExprSyntax(childData!)
    }
    set(value) {
      self = withName(value)
    }
  }

  /// Returns a copy of the receiver with its `name` replaced.
  /// - param newChild: The new `name` to replace the node's
  ///                   current `name`, if present.
  public func withName(
    _ newChild: ExprSyntax?) -> ObjcSelectorExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.expr)
    let newData = data.replacingChild(raw, at: Cursor.name)
    return ObjcSelectorExprSyntax(newData)
  }
  public var rightParen: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.rightParen, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withRightParen(value)
    }
  }

  /// Returns a copy of the receiver with its `rightParen` replaced.
  /// - param newChild: The new `rightParen` to replace the node's
  ///                   current `rightParen`, if present.
  public func withRightParen(
    _ newChild: TokenSyntax?) -> ObjcSelectorExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.rightParen)
    let newData = data.replacingChild(raw, at: Cursor.rightParen)
    return ObjcSelectorExprSyntax(newData)
  }

  /// Returns a new `ObjcSelectorExprSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> ObjcSelectorExprSyntax {
    return ObjcSelectorExprSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `ObjcSelectorExprSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> ObjcSelectorExprSyntax {
    return ObjcSelectorExprSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `ObjcSelectorExprSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> ObjcSelectorExprSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `ObjcSelectorExprSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> ObjcSelectorExprSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `ObjcSelectorExprSyntax` with all trivia removed.
  public func withoutTrivia() -> ObjcSelectorExprSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `ObjcSelectorExprSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `ObjcSelectorExprSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `EditorPlaceholderExprSyntax` nodes conform. Extension point to add
/// common methods to all `EditorPlaceholderExprSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol EditorPlaceholderExprSyntaxProtocol: ExprSyntaxProtocol {}


public struct EditorPlaceholderExprSyntax: ExprSyntaxProtocol {
  enum Cursor: Int {
    case identifier
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `EditorPlaceholderExprSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .editorPlaceholderExpr else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `EditorPlaceholderExprSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .editorPlaceholderExpr)
    self._syntaxNode = Syntax(data)
  }

  public var identifier: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.identifier, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withIdentifier(value)
    }
  }

  /// Returns a copy of the receiver with its `identifier` replaced.
  /// - param newChild: The new `identifier` to replace the node's
  ///                   current `identifier`, if present.
  public func withIdentifier(
    _ newChild: TokenSyntax?) -> EditorPlaceholderExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let newData = data.replacingChild(raw, at: Cursor.identifier)
    return EditorPlaceholderExprSyntax(newData)
  }

  /// Returns a new `EditorPlaceholderExprSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> EditorPlaceholderExprSyntax {
    return EditorPlaceholderExprSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `EditorPlaceholderExprSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> EditorPlaceholderExprSyntax {
    return EditorPlaceholderExprSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `EditorPlaceholderExprSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> EditorPlaceholderExprSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `EditorPlaceholderExprSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> EditorPlaceholderExprSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `EditorPlaceholderExprSyntax` with all trivia removed.
  public func withoutTrivia() -> EditorPlaceholderExprSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `EditorPlaceholderExprSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `EditorPlaceholderExprSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `ObjectLiteralExprSyntax` nodes conform. Extension point to add
/// common methods to all `ObjectLiteralExprSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol ObjectLiteralExprSyntaxProtocol: ExprSyntaxProtocol {}


public struct ObjectLiteralExprSyntax: ExprSyntaxProtocol {
  enum Cursor: Int {
    case identifier
    case leftParen
    case arguments
    case rightParen
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `ObjectLiteralExprSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .objectLiteralExpr else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `ObjectLiteralExprSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .objectLiteralExpr)
    self._syntaxNode = Syntax(data)
  }

  public var identifier: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.identifier, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withIdentifier(value)
    }
  }

  /// Returns a copy of the receiver with its `identifier` replaced.
  /// - param newChild: The new `identifier` to replace the node's
  ///                   current `identifier`, if present.
  public func withIdentifier(
    _ newChild: TokenSyntax?) -> ObjectLiteralExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.poundColorLiteralKeyword)
    let newData = data.replacingChild(raw, at: Cursor.identifier)
    return ObjectLiteralExprSyntax(newData)
  }
  public var leftParen: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.leftParen, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withLeftParen(value)
    }
  }

  /// Returns a copy of the receiver with its `leftParen` replaced.
  /// - param newChild: The new `leftParen` to replace the node's
  ///                   current `leftParen`, if present.
  public func withLeftParen(
    _ newChild: TokenSyntax?) -> ObjectLiteralExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.leftParen)
    let newData = data.replacingChild(raw, at: Cursor.leftParen)
    return ObjectLiteralExprSyntax(newData)
  }
  public var arguments: TupleExprElementListSyntax {
    get {
      let childData = data.child(at: Cursor.arguments, 
                                 parent: Syntax(self))
      return TupleExprElementListSyntax(childData!)
    }
    set(value) {
      self = withArguments(value)
    }
  }

  /// Adds the provided `Argument` to the node's `arguments`
  /// collection.
  /// - param element: The new `Argument` to add to the node's
  ///                  `arguments` collection.
  /// - returns: A copy of the receiver with the provided `Argument`
  ///            appended to its `arguments` collection.
  public func addArgument(_ element: TupleExprElementSyntax) -> ObjectLiteralExprSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.arguments] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.tupleExprElementList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.arguments)
    return ObjectLiteralExprSyntax(newData)
  }

  /// Returns a copy of the receiver with its `arguments` replaced.
  /// - param newChild: The new `arguments` to replace the node's
  ///                   current `arguments`, if present.
  public func withArguments(
    _ newChild: TupleExprElementListSyntax?) -> ObjectLiteralExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.tupleExprElementList)
    let newData = data.replacingChild(raw, at: Cursor.arguments)
    return ObjectLiteralExprSyntax(newData)
  }
  public var rightParen: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.rightParen, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withRightParen(value)
    }
  }

  /// Returns a copy of the receiver with its `rightParen` replaced.
  /// - param newChild: The new `rightParen` to replace the node's
  ///                   current `rightParen`, if present.
  public func withRightParen(
    _ newChild: TokenSyntax?) -> ObjectLiteralExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.rightParen)
    let newData = data.replacingChild(raw, at: Cursor.rightParen)
    return ObjectLiteralExprSyntax(newData)
  }

  /// Returns a new `ObjectLiteralExprSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> ObjectLiteralExprSyntax {
    return ObjectLiteralExprSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `ObjectLiteralExprSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> ObjectLiteralExprSyntax {
    return ObjectLiteralExprSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `ObjectLiteralExprSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> ObjectLiteralExprSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `ObjectLiteralExprSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> ObjectLiteralExprSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `ObjectLiteralExprSyntax` with all trivia removed.
  public func withoutTrivia() -> ObjectLiteralExprSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `ObjectLiteralExprSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `ObjectLiteralExprSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `TypeInitializerClauseSyntax` nodes conform. Extension point to add
/// common methods to all `TypeInitializerClauseSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol TypeInitializerClauseSyntaxProtocol: SyntaxProtocol {}


public struct TypeInitializerClauseSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case equal
    case value
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `TypeInitializerClauseSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .typeInitializerClause else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `TypeInitializerClauseSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .typeInitializerClause)
    self._syntaxNode = Syntax(data)
  }

  public var equal: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.equal, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withEqual(value)
    }
  }

  /// Returns a copy of the receiver with its `equal` replaced.
  /// - param newChild: The new `equal` to replace the node's
  ///                   current `equal`, if present.
  public func withEqual(
    _ newChild: TokenSyntax?) -> TypeInitializerClauseSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.equal)
    let newData = data.replacingChild(raw, at: Cursor.equal)
    return TypeInitializerClauseSyntax(newData)
  }
  public var value: TypeSyntax {
    get {
      let childData = data.child(at: Cursor.value, 
                                 parent: Syntax(self))
      return TypeSyntax(childData!)
    }
    set(value) {
      self = withValue(value)
    }
  }

  /// Returns a copy of the receiver with its `value` replaced.
  /// - param newChild: The new `value` to replace the node's
  ///                   current `value`, if present.
  public func withValue(
    _ newChild: TypeSyntax?) -> TypeInitializerClauseSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.type)
    let newData = data.replacingChild(raw, at: Cursor.value)
    return TypeInitializerClauseSyntax(newData)
  }

  /// Returns a new `TypeInitializerClauseSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> TypeInitializerClauseSyntax {
    return TypeInitializerClauseSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `TypeInitializerClauseSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> TypeInitializerClauseSyntax {
    return TypeInitializerClauseSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `TypeInitializerClauseSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> TypeInitializerClauseSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `TypeInitializerClauseSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> TypeInitializerClauseSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `TypeInitializerClauseSyntax` with all trivia removed.
  public func withoutTrivia() -> TypeInitializerClauseSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `TypeInitializerClauseSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `TypeInitializerClauseSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `TypealiasDeclSyntax` nodes conform. Extension point to add
/// common methods to all `TypealiasDeclSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol TypealiasDeclSyntaxProtocol: DeclSyntaxProtocol {}


public struct TypealiasDeclSyntax: DeclSyntaxProtocol {
  enum Cursor: Int {
    case attributes
    case modifiers
    case typealiasKeyword
    case identifier
    case genericParameterClause
    case initializer
    case genericWhereClause
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `TypealiasDeclSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .typealiasDecl else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `TypealiasDeclSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .typealiasDecl)
    self._syntaxNode = Syntax(data)
  }

  public var attributes: AttributeListSyntax? {
    get {
      let childData = data.child(at: Cursor.attributes, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return AttributeListSyntax(childData!)
    }
    set(value) {
      self = withAttributes(value)
    }
  }

  /// Adds the provided `Attribute` to the node's `attributes`
  /// collection.
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  public func addAttribute(_ element: Syntax) -> TypealiasDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.attributes] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.attributeList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.attributes)
    return TypealiasDeclSyntax(newData)
  }

  /// Returns a copy of the receiver with its `attributes` replaced.
  /// - param newChild: The new `attributes` to replace the node's
  ///                   current `attributes`, if present.
  public func withAttributes(
    _ newChild: AttributeListSyntax?) -> TypealiasDeclSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.attributes)
    return TypealiasDeclSyntax(newData)
  }
  public var modifiers: ModifierListSyntax? {
    get {
      let childData = data.child(at: Cursor.modifiers, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return ModifierListSyntax(childData!)
    }
    set(value) {
      self = withModifiers(value)
    }
  }

  /// Adds the provided `Modifier` to the node's `modifiers`
  /// collection.
  /// - param element: The new `Modifier` to add to the node's
  ///                  `modifiers` collection.
  /// - returns: A copy of the receiver with the provided `Modifier`
  ///            appended to its `modifiers` collection.
  public func addModifier(_ element: DeclModifierSyntax) -> TypealiasDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.modifiers] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.modifierList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.modifiers)
    return TypealiasDeclSyntax(newData)
  }

  /// Returns a copy of the receiver with its `modifiers` replaced.
  /// - param newChild: The new `modifiers` to replace the node's
  ///                   current `modifiers`, if present.
  public func withModifiers(
    _ newChild: ModifierListSyntax?) -> TypealiasDeclSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.modifiers)
    return TypealiasDeclSyntax(newData)
  }
  public var typealiasKeyword: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.typealiasKeyword, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withTypealiasKeyword(value)
    }
  }

  /// Returns a copy of the receiver with its `typealiasKeyword` replaced.
  /// - param newChild: The new `typealiasKeyword` to replace the node's
  ///                   current `typealiasKeyword`, if present.
  public func withTypealiasKeyword(
    _ newChild: TokenSyntax?) -> TypealiasDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.typealiasKeyword)
    let newData = data.replacingChild(raw, at: Cursor.typealiasKeyword)
    return TypealiasDeclSyntax(newData)
  }
  public var identifier: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.identifier, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withIdentifier(value)
    }
  }

  /// Returns a copy of the receiver with its `identifier` replaced.
  /// - param newChild: The new `identifier` to replace the node's
  ///                   current `identifier`, if present.
  public func withIdentifier(
    _ newChild: TokenSyntax?) -> TypealiasDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let newData = data.replacingChild(raw, at: Cursor.identifier)
    return TypealiasDeclSyntax(newData)
  }
  public var genericParameterClause: GenericParameterClauseSyntax? {
    get {
      let childData = data.child(at: Cursor.genericParameterClause, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return GenericParameterClauseSyntax(childData!)
    }
    set(value) {
      self = withGenericParameterClause(value)
    }
  }

  /// Returns a copy of the receiver with its `genericParameterClause` replaced.
  /// - param newChild: The new `genericParameterClause` to replace the node's
  ///                   current `genericParameterClause`, if present.
  public func withGenericParameterClause(
    _ newChild: GenericParameterClauseSyntax?) -> TypealiasDeclSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.genericParameterClause)
    return TypealiasDeclSyntax(newData)
  }
  public var initializer: TypeInitializerClauseSyntax? {
    get {
      let childData = data.child(at: Cursor.initializer, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TypeInitializerClauseSyntax(childData!)
    }
    set(value) {
      self = withInitializer(value)
    }
  }

  /// Returns a copy of the receiver with its `initializer` replaced.
  /// - param newChild: The new `initializer` to replace the node's
  ///                   current `initializer`, if present.
  public func withInitializer(
    _ newChild: TypeInitializerClauseSyntax?) -> TypealiasDeclSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.initializer)
    return TypealiasDeclSyntax(newData)
  }
  public var genericWhereClause: GenericWhereClauseSyntax? {
    get {
      let childData = data.child(at: Cursor.genericWhereClause, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return GenericWhereClauseSyntax(childData!)
    }
    set(value) {
      self = withGenericWhereClause(value)
    }
  }

  /// Returns a copy of the receiver with its `genericWhereClause` replaced.
  /// - param newChild: The new `genericWhereClause` to replace the node's
  ///                   current `genericWhereClause`, if present.
  public func withGenericWhereClause(
    _ newChild: GenericWhereClauseSyntax?) -> TypealiasDeclSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.genericWhereClause)
    return TypealiasDeclSyntax(newData)
  }

  /// Returns a new `TypealiasDeclSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> TypealiasDeclSyntax {
    return TypealiasDeclSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `TypealiasDeclSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> TypealiasDeclSyntax {
    return TypealiasDeclSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `TypealiasDeclSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> TypealiasDeclSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `TypealiasDeclSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> TypealiasDeclSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `TypealiasDeclSyntax` with all trivia removed.
  public func withoutTrivia() -> TypealiasDeclSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `TypealiasDeclSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `TypealiasDeclSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `AssociatedtypeDeclSyntax` nodes conform. Extension point to add
/// common methods to all `AssociatedtypeDeclSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol AssociatedtypeDeclSyntaxProtocol: DeclSyntaxProtocol {}


public struct AssociatedtypeDeclSyntax: DeclSyntaxProtocol {
  enum Cursor: Int {
    case attributes
    case modifiers
    case associatedtypeKeyword
    case identifier
    case inheritanceClause
    case initializer
    case genericWhereClause
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `AssociatedtypeDeclSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .associatedtypeDecl else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `AssociatedtypeDeclSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .associatedtypeDecl)
    self._syntaxNode = Syntax(data)
  }

  public var attributes: AttributeListSyntax? {
    get {
      let childData = data.child(at: Cursor.attributes, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return AttributeListSyntax(childData!)
    }
    set(value) {
      self = withAttributes(value)
    }
  }

  /// Adds the provided `Attribute` to the node's `attributes`
  /// collection.
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  public func addAttribute(_ element: Syntax) -> AssociatedtypeDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.attributes] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.attributeList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.attributes)
    return AssociatedtypeDeclSyntax(newData)
  }

  /// Returns a copy of the receiver with its `attributes` replaced.
  /// - param newChild: The new `attributes` to replace the node's
  ///                   current `attributes`, if present.
  public func withAttributes(
    _ newChild: AttributeListSyntax?) -> AssociatedtypeDeclSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.attributes)
    return AssociatedtypeDeclSyntax(newData)
  }
  public var modifiers: ModifierListSyntax? {
    get {
      let childData = data.child(at: Cursor.modifiers, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return ModifierListSyntax(childData!)
    }
    set(value) {
      self = withModifiers(value)
    }
  }

  /// Adds the provided `Modifier` to the node's `modifiers`
  /// collection.
  /// - param element: The new `Modifier` to add to the node's
  ///                  `modifiers` collection.
  /// - returns: A copy of the receiver with the provided `Modifier`
  ///            appended to its `modifiers` collection.
  public func addModifier(_ element: DeclModifierSyntax) -> AssociatedtypeDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.modifiers] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.modifierList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.modifiers)
    return AssociatedtypeDeclSyntax(newData)
  }

  /// Returns a copy of the receiver with its `modifiers` replaced.
  /// - param newChild: The new `modifiers` to replace the node's
  ///                   current `modifiers`, if present.
  public func withModifiers(
    _ newChild: ModifierListSyntax?) -> AssociatedtypeDeclSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.modifiers)
    return AssociatedtypeDeclSyntax(newData)
  }
  public var associatedtypeKeyword: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.associatedtypeKeyword, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withAssociatedtypeKeyword(value)
    }
  }

  /// Returns a copy of the receiver with its `associatedtypeKeyword` replaced.
  /// - param newChild: The new `associatedtypeKeyword` to replace the node's
  ///                   current `associatedtypeKeyword`, if present.
  public func withAssociatedtypeKeyword(
    _ newChild: TokenSyntax?) -> AssociatedtypeDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.associatedtypeKeyword)
    let newData = data.replacingChild(raw, at: Cursor.associatedtypeKeyword)
    return AssociatedtypeDeclSyntax(newData)
  }
  public var identifier: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.identifier, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withIdentifier(value)
    }
  }

  /// Returns a copy of the receiver with its `identifier` replaced.
  /// - param newChild: The new `identifier` to replace the node's
  ///                   current `identifier`, if present.
  public func withIdentifier(
    _ newChild: TokenSyntax?) -> AssociatedtypeDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let newData = data.replacingChild(raw, at: Cursor.identifier)
    return AssociatedtypeDeclSyntax(newData)
  }
  public var inheritanceClause: TypeInheritanceClauseSyntax? {
    get {
      let childData = data.child(at: Cursor.inheritanceClause, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TypeInheritanceClauseSyntax(childData!)
    }
    set(value) {
      self = withInheritanceClause(value)
    }
  }

  /// Returns a copy of the receiver with its `inheritanceClause` replaced.
  /// - param newChild: The new `inheritanceClause` to replace the node's
  ///                   current `inheritanceClause`, if present.
  public func withInheritanceClause(
    _ newChild: TypeInheritanceClauseSyntax?) -> AssociatedtypeDeclSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.inheritanceClause)
    return AssociatedtypeDeclSyntax(newData)
  }
  public var initializer: TypeInitializerClauseSyntax? {
    get {
      let childData = data.child(at: Cursor.initializer, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TypeInitializerClauseSyntax(childData!)
    }
    set(value) {
      self = withInitializer(value)
    }
  }

  /// Returns a copy of the receiver with its `initializer` replaced.
  /// - param newChild: The new `initializer` to replace the node's
  ///                   current `initializer`, if present.
  public func withInitializer(
    _ newChild: TypeInitializerClauseSyntax?) -> AssociatedtypeDeclSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.initializer)
    return AssociatedtypeDeclSyntax(newData)
  }
  public var genericWhereClause: GenericWhereClauseSyntax? {
    get {
      let childData = data.child(at: Cursor.genericWhereClause, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return GenericWhereClauseSyntax(childData!)
    }
    set(value) {
      self = withGenericWhereClause(value)
    }
  }

  /// Returns a copy of the receiver with its `genericWhereClause` replaced.
  /// - param newChild: The new `genericWhereClause` to replace the node's
  ///                   current `genericWhereClause`, if present.
  public func withGenericWhereClause(
    _ newChild: GenericWhereClauseSyntax?) -> AssociatedtypeDeclSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.genericWhereClause)
    return AssociatedtypeDeclSyntax(newData)
  }

  /// Returns a new `AssociatedtypeDeclSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> AssociatedtypeDeclSyntax {
    return AssociatedtypeDeclSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `AssociatedtypeDeclSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> AssociatedtypeDeclSyntax {
    return AssociatedtypeDeclSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `AssociatedtypeDeclSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> AssociatedtypeDeclSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `AssociatedtypeDeclSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> AssociatedtypeDeclSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `AssociatedtypeDeclSyntax` with all trivia removed.
  public func withoutTrivia() -> AssociatedtypeDeclSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `AssociatedtypeDeclSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `AssociatedtypeDeclSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `FunctionParameterListSyntax` nodes conform. Extension point to add
/// common methods to all `FunctionParameterListSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol FunctionParameterListSyntaxProtocol: SyntaxProtocol {}

/// Protocol to which all `ParameterClauseSyntax` nodes conform. Extension point to add
/// common methods to all `ParameterClauseSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol ParameterClauseSyntaxProtocol: SyntaxProtocol {}


public struct ParameterClauseSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case leftParen
    case parameterList
    case rightParen
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `ParameterClauseSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .parameterClause else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `ParameterClauseSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .parameterClause)
    self._syntaxNode = Syntax(data)
  }

  public var leftParen: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.leftParen, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withLeftParen(value)
    }
  }

  /// Returns a copy of the receiver with its `leftParen` replaced.
  /// - param newChild: The new `leftParen` to replace the node's
  ///                   current `leftParen`, if present.
  public func withLeftParen(
    _ newChild: TokenSyntax?) -> ParameterClauseSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.leftParen)
    let newData = data.replacingChild(raw, at: Cursor.leftParen)
    return ParameterClauseSyntax(newData)
  }
  public var parameterList: FunctionParameterListSyntax {
    get {
      let childData = data.child(at: Cursor.parameterList, 
                                 parent: Syntax(self))
      return FunctionParameterListSyntax(childData!)
    }
    set(value) {
      self = withParameterList(value)
    }
  }

  /// Adds the provided `Parameter` to the node's `parameterList`
  /// collection.
  /// - param element: The new `Parameter` to add to the node's
  ///                  `parameterList` collection.
  /// - returns: A copy of the receiver with the provided `Parameter`
  ///            appended to its `parameterList` collection.
  public func addParameter(_ element: FunctionParameterSyntax) -> ParameterClauseSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.parameterList] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.functionParameterList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.parameterList)
    return ParameterClauseSyntax(newData)
  }

  /// Returns a copy of the receiver with its `parameterList` replaced.
  /// - param newChild: The new `parameterList` to replace the node's
  ///                   current `parameterList`, if present.
  public func withParameterList(
    _ newChild: FunctionParameterListSyntax?) -> ParameterClauseSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.functionParameterList)
    let newData = data.replacingChild(raw, at: Cursor.parameterList)
    return ParameterClauseSyntax(newData)
  }
  public var rightParen: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.rightParen, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withRightParen(value)
    }
  }

  /// Returns a copy of the receiver with its `rightParen` replaced.
  /// - param newChild: The new `rightParen` to replace the node's
  ///                   current `rightParen`, if present.
  public func withRightParen(
    _ newChild: TokenSyntax?) -> ParameterClauseSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.rightParen)
    let newData = data.replacingChild(raw, at: Cursor.rightParen)
    return ParameterClauseSyntax(newData)
  }

  /// Returns a new `ParameterClauseSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> ParameterClauseSyntax {
    return ParameterClauseSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `ParameterClauseSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> ParameterClauseSyntax {
    return ParameterClauseSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `ParameterClauseSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> ParameterClauseSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `ParameterClauseSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> ParameterClauseSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `ParameterClauseSyntax` with all trivia removed.
  public func withoutTrivia() -> ParameterClauseSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `ParameterClauseSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `ParameterClauseSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `ReturnClauseSyntax` nodes conform. Extension point to add
/// common methods to all `ReturnClauseSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol ReturnClauseSyntaxProtocol: SyntaxProtocol {}


public struct ReturnClauseSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case arrow
    case returnType
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `ReturnClauseSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .returnClause else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `ReturnClauseSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .returnClause)
    self._syntaxNode = Syntax(data)
  }

  public var arrow: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.arrow, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withArrow(value)
    }
  }

  /// Returns a copy of the receiver with its `arrow` replaced.
  /// - param newChild: The new `arrow` to replace the node's
  ///                   current `arrow`, if present.
  public func withArrow(
    _ newChild: TokenSyntax?) -> ReturnClauseSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.arrow)
    let newData = data.replacingChild(raw, at: Cursor.arrow)
    return ReturnClauseSyntax(newData)
  }
  public var returnType: TypeSyntax {
    get {
      let childData = data.child(at: Cursor.returnType, 
                                 parent: Syntax(self))
      return TypeSyntax(childData!)
    }
    set(value) {
      self = withReturnType(value)
    }
  }

  /// Returns a copy of the receiver with its `returnType` replaced.
  /// - param newChild: The new `returnType` to replace the node's
  ///                   current `returnType`, if present.
  public func withReturnType(
    _ newChild: TypeSyntax?) -> ReturnClauseSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.type)
    let newData = data.replacingChild(raw, at: Cursor.returnType)
    return ReturnClauseSyntax(newData)
  }

  /// Returns a new `ReturnClauseSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> ReturnClauseSyntax {
    return ReturnClauseSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `ReturnClauseSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> ReturnClauseSyntax {
    return ReturnClauseSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `ReturnClauseSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> ReturnClauseSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `ReturnClauseSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> ReturnClauseSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `ReturnClauseSyntax` with all trivia removed.
  public func withoutTrivia() -> ReturnClauseSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `ReturnClauseSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `ReturnClauseSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `FunctionSignatureSyntax` nodes conform. Extension point to add
/// common methods to all `FunctionSignatureSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol FunctionSignatureSyntaxProtocol: SyntaxProtocol {}


public struct FunctionSignatureSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case input
    case throwsOrRethrowsKeyword
    case output
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `FunctionSignatureSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .functionSignature else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `FunctionSignatureSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .functionSignature)
    self._syntaxNode = Syntax(data)
  }

  public var input: ParameterClauseSyntax {
    get {
      let childData = data.child(at: Cursor.input, 
                                 parent: Syntax(self))
      return ParameterClauseSyntax(childData!)
    }
    set(value) {
      self = withInput(value)
    }
  }

  /// Returns a copy of the receiver with its `input` replaced.
  /// - param newChild: The new `input` to replace the node's
  ///                   current `input`, if present.
  public func withInput(
    _ newChild: ParameterClauseSyntax?) -> FunctionSignatureSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.parameterClause)
    let newData = data.replacingChild(raw, at: Cursor.input)
    return FunctionSignatureSyntax(newData)
  }
  public var throwsOrRethrowsKeyword: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.throwsOrRethrowsKeyword, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withThrowsOrRethrowsKeyword(value)
    }
  }

  /// Returns a copy of the receiver with its `throwsOrRethrowsKeyword` replaced.
  /// - param newChild: The new `throwsOrRethrowsKeyword` to replace the node's
  ///                   current `throwsOrRethrowsKeyword`, if present.
  public func withThrowsOrRethrowsKeyword(
    _ newChild: TokenSyntax?) -> FunctionSignatureSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.throwsOrRethrowsKeyword)
    return FunctionSignatureSyntax(newData)
  }
  public var output: ReturnClauseSyntax? {
    get {
      let childData = data.child(at: Cursor.output, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return ReturnClauseSyntax(childData!)
    }
    set(value) {
      self = withOutput(value)
    }
  }

  /// Returns a copy of the receiver with its `output` replaced.
  /// - param newChild: The new `output` to replace the node's
  ///                   current `output`, if present.
  public func withOutput(
    _ newChild: ReturnClauseSyntax?) -> FunctionSignatureSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.output)
    return FunctionSignatureSyntax(newData)
  }

  /// Returns a new `FunctionSignatureSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> FunctionSignatureSyntax {
    return FunctionSignatureSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `FunctionSignatureSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> FunctionSignatureSyntax {
    return FunctionSignatureSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `FunctionSignatureSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> FunctionSignatureSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `FunctionSignatureSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> FunctionSignatureSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `FunctionSignatureSyntax` with all trivia removed.
  public func withoutTrivia() -> FunctionSignatureSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `FunctionSignatureSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `FunctionSignatureSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `IfConfigClauseSyntax` nodes conform. Extension point to add
/// common methods to all `IfConfigClauseSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol IfConfigClauseSyntaxProtocol: SyntaxProtocol {}


public struct IfConfigClauseSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case poundKeyword
    case condition
    case elements
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `IfConfigClauseSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .ifConfigClause else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `IfConfigClauseSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .ifConfigClause)
    self._syntaxNode = Syntax(data)
  }

  public var poundKeyword: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.poundKeyword, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withPoundKeyword(value)
    }
  }

  /// Returns a copy of the receiver with its `poundKeyword` replaced.
  /// - param newChild: The new `poundKeyword` to replace the node's
  ///                   current `poundKeyword`, if present.
  public func withPoundKeyword(
    _ newChild: TokenSyntax?) -> IfConfigClauseSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.poundIfKeyword)
    let newData = data.replacingChild(raw, at: Cursor.poundKeyword)
    return IfConfigClauseSyntax(newData)
  }
  public var condition: ExprSyntax? {
    get {
      let childData = data.child(at: Cursor.condition, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return ExprSyntax(childData!)
    }
    set(value) {
      self = withCondition(value)
    }
  }

  /// Returns a copy of the receiver with its `condition` replaced.
  /// - param newChild: The new `condition` to replace the node's
  ///                   current `condition`, if present.
  public func withCondition(
    _ newChild: ExprSyntax?) -> IfConfigClauseSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.condition)
    return IfConfigClauseSyntax(newData)
  }
  public var elements: Syntax {
    get {
      let childData = data.child(at: Cursor.elements, 
                                 parent: Syntax(self))
      return Syntax(childData!)
    }
    set(value) {
      self = withElements(value)
    }
  }

  /// Returns a copy of the receiver with its `elements` replaced.
  /// - param newChild: The new `elements` to replace the node's
  ///                   current `elements`, if present.
  public func withElements(
    _ newChild: Syntax?) -> IfConfigClauseSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.unknown)
    let newData = data.replacingChild(raw, at: Cursor.elements)
    return IfConfigClauseSyntax(newData)
  }

  /// Returns a new `IfConfigClauseSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> IfConfigClauseSyntax {
    return IfConfigClauseSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `IfConfigClauseSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> IfConfigClauseSyntax {
    return IfConfigClauseSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `IfConfigClauseSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> IfConfigClauseSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `IfConfigClauseSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> IfConfigClauseSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `IfConfigClauseSyntax` with all trivia removed.
  public func withoutTrivia() -> IfConfigClauseSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `IfConfigClauseSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `IfConfigClauseSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `IfConfigClauseListSyntax` nodes conform. Extension point to add
/// common methods to all `IfConfigClauseListSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol IfConfigClauseListSyntaxProtocol: SyntaxProtocol {}

/// Protocol to which all `IfConfigDeclSyntax` nodes conform. Extension point to add
/// common methods to all `IfConfigDeclSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol IfConfigDeclSyntaxProtocol: DeclSyntaxProtocol {}


public struct IfConfigDeclSyntax: DeclSyntaxProtocol {
  enum Cursor: Int {
    case clauses
    case poundEndif
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `IfConfigDeclSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .ifConfigDecl else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `IfConfigDeclSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .ifConfigDecl)
    self._syntaxNode = Syntax(data)
  }

  public var clauses: IfConfigClauseListSyntax {
    get {
      let childData = data.child(at: Cursor.clauses, 
                                 parent: Syntax(self))
      return IfConfigClauseListSyntax(childData!)
    }
    set(value) {
      self = withClauses(value)
    }
  }

  /// Adds the provided `Clause` to the node's `clauses`
  /// collection.
  /// - param element: The new `Clause` to add to the node's
  ///                  `clauses` collection.
  /// - returns: A copy of the receiver with the provided `Clause`
  ///            appended to its `clauses` collection.
  public func addClause(_ element: IfConfigClauseSyntax) -> IfConfigDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.clauses] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.ifConfigClauseList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.clauses)
    return IfConfigDeclSyntax(newData)
  }

  /// Returns a copy of the receiver with its `clauses` replaced.
  /// - param newChild: The new `clauses` to replace the node's
  ///                   current `clauses`, if present.
  public func withClauses(
    _ newChild: IfConfigClauseListSyntax?) -> IfConfigDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.ifConfigClauseList)
    let newData = data.replacingChild(raw, at: Cursor.clauses)
    return IfConfigDeclSyntax(newData)
  }
  public var poundEndif: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.poundEndif, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withPoundEndif(value)
    }
  }

  /// Returns a copy of the receiver with its `poundEndif` replaced.
  /// - param newChild: The new `poundEndif` to replace the node's
  ///                   current `poundEndif`, if present.
  public func withPoundEndif(
    _ newChild: TokenSyntax?) -> IfConfigDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.poundEndifKeyword)
    let newData = data.replacingChild(raw, at: Cursor.poundEndif)
    return IfConfigDeclSyntax(newData)
  }

  /// Returns a new `IfConfigDeclSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> IfConfigDeclSyntax {
    return IfConfigDeclSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `IfConfigDeclSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> IfConfigDeclSyntax {
    return IfConfigDeclSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `IfConfigDeclSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> IfConfigDeclSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `IfConfigDeclSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> IfConfigDeclSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `IfConfigDeclSyntax` with all trivia removed.
  public func withoutTrivia() -> IfConfigDeclSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `IfConfigDeclSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `IfConfigDeclSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `PoundErrorDeclSyntax` nodes conform. Extension point to add
/// common methods to all `PoundErrorDeclSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol PoundErrorDeclSyntaxProtocol: DeclSyntaxProtocol {}


public struct PoundErrorDeclSyntax: DeclSyntaxProtocol {
  enum Cursor: Int {
    case poundError
    case leftParen
    case message
    case rightParen
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `PoundErrorDeclSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .poundErrorDecl else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `PoundErrorDeclSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .poundErrorDecl)
    self._syntaxNode = Syntax(data)
  }

  public var poundError: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.poundError, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withPoundError(value)
    }
  }

  /// Returns a copy of the receiver with its `poundError` replaced.
  /// - param newChild: The new `poundError` to replace the node's
  ///                   current `poundError`, if present.
  public func withPoundError(
    _ newChild: TokenSyntax?) -> PoundErrorDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.poundErrorKeyword)
    let newData = data.replacingChild(raw, at: Cursor.poundError)
    return PoundErrorDeclSyntax(newData)
  }
  public var leftParen: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.leftParen, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withLeftParen(value)
    }
  }

  /// Returns a copy of the receiver with its `leftParen` replaced.
  /// - param newChild: The new `leftParen` to replace the node's
  ///                   current `leftParen`, if present.
  public func withLeftParen(
    _ newChild: TokenSyntax?) -> PoundErrorDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.leftParen)
    let newData = data.replacingChild(raw, at: Cursor.leftParen)
    return PoundErrorDeclSyntax(newData)
  }
  public var message: StringLiteralExprSyntax {
    get {
      let childData = data.child(at: Cursor.message, 
                                 parent: Syntax(self))
      return StringLiteralExprSyntax(childData!)
    }
    set(value) {
      self = withMessage(value)
    }
  }

  /// Returns a copy of the receiver with its `message` replaced.
  /// - param newChild: The new `message` to replace the node's
  ///                   current `message`, if present.
  public func withMessage(
    _ newChild: StringLiteralExprSyntax?) -> PoundErrorDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.stringLiteralExpr)
    let newData = data.replacingChild(raw, at: Cursor.message)
    return PoundErrorDeclSyntax(newData)
  }
  public var rightParen: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.rightParen, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withRightParen(value)
    }
  }

  /// Returns a copy of the receiver with its `rightParen` replaced.
  /// - param newChild: The new `rightParen` to replace the node's
  ///                   current `rightParen`, if present.
  public func withRightParen(
    _ newChild: TokenSyntax?) -> PoundErrorDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.rightParen)
    let newData = data.replacingChild(raw, at: Cursor.rightParen)
    return PoundErrorDeclSyntax(newData)
  }

  /// Returns a new `PoundErrorDeclSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> PoundErrorDeclSyntax {
    return PoundErrorDeclSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `PoundErrorDeclSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> PoundErrorDeclSyntax {
    return PoundErrorDeclSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `PoundErrorDeclSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> PoundErrorDeclSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `PoundErrorDeclSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> PoundErrorDeclSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `PoundErrorDeclSyntax` with all trivia removed.
  public func withoutTrivia() -> PoundErrorDeclSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `PoundErrorDeclSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `PoundErrorDeclSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `PoundWarningDeclSyntax` nodes conform. Extension point to add
/// common methods to all `PoundWarningDeclSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol PoundWarningDeclSyntaxProtocol: DeclSyntaxProtocol {}


public struct PoundWarningDeclSyntax: DeclSyntaxProtocol {
  enum Cursor: Int {
    case poundWarning
    case leftParen
    case message
    case rightParen
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `PoundWarningDeclSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .poundWarningDecl else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `PoundWarningDeclSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .poundWarningDecl)
    self._syntaxNode = Syntax(data)
  }

  public var poundWarning: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.poundWarning, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withPoundWarning(value)
    }
  }

  /// Returns a copy of the receiver with its `poundWarning` replaced.
  /// - param newChild: The new `poundWarning` to replace the node's
  ///                   current `poundWarning`, if present.
  public func withPoundWarning(
    _ newChild: TokenSyntax?) -> PoundWarningDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.poundWarningKeyword)
    let newData = data.replacingChild(raw, at: Cursor.poundWarning)
    return PoundWarningDeclSyntax(newData)
  }
  public var leftParen: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.leftParen, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withLeftParen(value)
    }
  }

  /// Returns a copy of the receiver with its `leftParen` replaced.
  /// - param newChild: The new `leftParen` to replace the node's
  ///                   current `leftParen`, if present.
  public func withLeftParen(
    _ newChild: TokenSyntax?) -> PoundWarningDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.leftParen)
    let newData = data.replacingChild(raw, at: Cursor.leftParen)
    return PoundWarningDeclSyntax(newData)
  }
  public var message: StringLiteralExprSyntax {
    get {
      let childData = data.child(at: Cursor.message, 
                                 parent: Syntax(self))
      return StringLiteralExprSyntax(childData!)
    }
    set(value) {
      self = withMessage(value)
    }
  }

  /// Returns a copy of the receiver with its `message` replaced.
  /// - param newChild: The new `message` to replace the node's
  ///                   current `message`, if present.
  public func withMessage(
    _ newChild: StringLiteralExprSyntax?) -> PoundWarningDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.stringLiteralExpr)
    let newData = data.replacingChild(raw, at: Cursor.message)
    return PoundWarningDeclSyntax(newData)
  }
  public var rightParen: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.rightParen, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withRightParen(value)
    }
  }

  /// Returns a copy of the receiver with its `rightParen` replaced.
  /// - param newChild: The new `rightParen` to replace the node's
  ///                   current `rightParen`, if present.
  public func withRightParen(
    _ newChild: TokenSyntax?) -> PoundWarningDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.rightParen)
    let newData = data.replacingChild(raw, at: Cursor.rightParen)
    return PoundWarningDeclSyntax(newData)
  }

  /// Returns a new `PoundWarningDeclSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> PoundWarningDeclSyntax {
    return PoundWarningDeclSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `PoundWarningDeclSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> PoundWarningDeclSyntax {
    return PoundWarningDeclSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `PoundWarningDeclSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> PoundWarningDeclSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `PoundWarningDeclSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> PoundWarningDeclSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `PoundWarningDeclSyntax` with all trivia removed.
  public func withoutTrivia() -> PoundWarningDeclSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `PoundWarningDeclSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `PoundWarningDeclSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `PoundSourceLocationSyntax` nodes conform. Extension point to add
/// common methods to all `PoundSourceLocationSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol PoundSourceLocationSyntaxProtocol: DeclSyntaxProtocol {}


public struct PoundSourceLocationSyntax: DeclSyntaxProtocol {
  enum Cursor: Int {
    case poundSourceLocation
    case leftParen
    case args
    case rightParen
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `PoundSourceLocationSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .poundSourceLocation else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `PoundSourceLocationSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .poundSourceLocation)
    self._syntaxNode = Syntax(data)
  }

  public var poundSourceLocation: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.poundSourceLocation, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withPoundSourceLocation(value)
    }
  }

  /// Returns a copy of the receiver with its `poundSourceLocation` replaced.
  /// - param newChild: The new `poundSourceLocation` to replace the node's
  ///                   current `poundSourceLocation`, if present.
  public func withPoundSourceLocation(
    _ newChild: TokenSyntax?) -> PoundSourceLocationSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.poundSourceLocationKeyword)
    let newData = data.replacingChild(raw, at: Cursor.poundSourceLocation)
    return PoundSourceLocationSyntax(newData)
  }
  public var leftParen: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.leftParen, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withLeftParen(value)
    }
  }

  /// Returns a copy of the receiver with its `leftParen` replaced.
  /// - param newChild: The new `leftParen` to replace the node's
  ///                   current `leftParen`, if present.
  public func withLeftParen(
    _ newChild: TokenSyntax?) -> PoundSourceLocationSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.leftParen)
    let newData = data.replacingChild(raw, at: Cursor.leftParen)
    return PoundSourceLocationSyntax(newData)
  }
  public var args: PoundSourceLocationArgsSyntax? {
    get {
      let childData = data.child(at: Cursor.args, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return PoundSourceLocationArgsSyntax(childData!)
    }
    set(value) {
      self = withArgs(value)
    }
  }

  /// Returns a copy of the receiver with its `args` replaced.
  /// - param newChild: The new `args` to replace the node's
  ///                   current `args`, if present.
  public func withArgs(
    _ newChild: PoundSourceLocationArgsSyntax?) -> PoundSourceLocationSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.args)
    return PoundSourceLocationSyntax(newData)
  }
  public var rightParen: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.rightParen, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withRightParen(value)
    }
  }

  /// Returns a copy of the receiver with its `rightParen` replaced.
  /// - param newChild: The new `rightParen` to replace the node's
  ///                   current `rightParen`, if present.
  public func withRightParen(
    _ newChild: TokenSyntax?) -> PoundSourceLocationSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.rightParen)
    let newData = data.replacingChild(raw, at: Cursor.rightParen)
    return PoundSourceLocationSyntax(newData)
  }

  /// Returns a new `PoundSourceLocationSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> PoundSourceLocationSyntax {
    return PoundSourceLocationSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `PoundSourceLocationSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> PoundSourceLocationSyntax {
    return PoundSourceLocationSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `PoundSourceLocationSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> PoundSourceLocationSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `PoundSourceLocationSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> PoundSourceLocationSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `PoundSourceLocationSyntax` with all trivia removed.
  public func withoutTrivia() -> PoundSourceLocationSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `PoundSourceLocationSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `PoundSourceLocationSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `PoundSourceLocationArgsSyntax` nodes conform. Extension point to add
/// common methods to all `PoundSourceLocationArgsSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol PoundSourceLocationArgsSyntaxProtocol: SyntaxProtocol {}


public struct PoundSourceLocationArgsSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case fileArgLabel
    case fileArgColon
    case fileName
    case comma
    case lineArgLabel
    case lineArgColon
    case lineNumber
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `PoundSourceLocationArgsSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .poundSourceLocationArgs else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `PoundSourceLocationArgsSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .poundSourceLocationArgs)
    self._syntaxNode = Syntax(data)
  }

  public var fileArgLabel: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.fileArgLabel, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withFileArgLabel(value)
    }
  }

  /// Returns a copy of the receiver with its `fileArgLabel` replaced.
  /// - param newChild: The new `fileArgLabel` to replace the node's
  ///                   current `fileArgLabel`, if present.
  public func withFileArgLabel(
    _ newChild: TokenSyntax?) -> PoundSourceLocationArgsSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let newData = data.replacingChild(raw, at: Cursor.fileArgLabel)
    return PoundSourceLocationArgsSyntax(newData)
  }
  public var fileArgColon: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.fileArgColon, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withFileArgColon(value)
    }
  }

  /// Returns a copy of the receiver with its `fileArgColon` replaced.
  /// - param newChild: The new `fileArgColon` to replace the node's
  ///                   current `fileArgColon`, if present.
  public func withFileArgColon(
    _ newChild: TokenSyntax?) -> PoundSourceLocationArgsSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.colon)
    let newData = data.replacingChild(raw, at: Cursor.fileArgColon)
    return PoundSourceLocationArgsSyntax(newData)
  }
  public var fileName: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.fileName, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withFileName(value)
    }
  }

  /// Returns a copy of the receiver with its `fileName` replaced.
  /// - param newChild: The new `fileName` to replace the node's
  ///                   current `fileName`, if present.
  public func withFileName(
    _ newChild: TokenSyntax?) -> PoundSourceLocationArgsSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.stringLiteral(""))
    let newData = data.replacingChild(raw, at: Cursor.fileName)
    return PoundSourceLocationArgsSyntax(newData)
  }
  public var comma: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.comma, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withComma(value)
    }
  }

  /// Returns a copy of the receiver with its `comma` replaced.
  /// - param newChild: The new `comma` to replace the node's
  ///                   current `comma`, if present.
  public func withComma(
    _ newChild: TokenSyntax?) -> PoundSourceLocationArgsSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.comma)
    let newData = data.replacingChild(raw, at: Cursor.comma)
    return PoundSourceLocationArgsSyntax(newData)
  }
  public var lineArgLabel: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.lineArgLabel, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withLineArgLabel(value)
    }
  }

  /// Returns a copy of the receiver with its `lineArgLabel` replaced.
  /// - param newChild: The new `lineArgLabel` to replace the node's
  ///                   current `lineArgLabel`, if present.
  public func withLineArgLabel(
    _ newChild: TokenSyntax?) -> PoundSourceLocationArgsSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let newData = data.replacingChild(raw, at: Cursor.lineArgLabel)
    return PoundSourceLocationArgsSyntax(newData)
  }
  public var lineArgColon: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.lineArgColon, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withLineArgColon(value)
    }
  }

  /// Returns a copy of the receiver with its `lineArgColon` replaced.
  /// - param newChild: The new `lineArgColon` to replace the node's
  ///                   current `lineArgColon`, if present.
  public func withLineArgColon(
    _ newChild: TokenSyntax?) -> PoundSourceLocationArgsSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.colon)
    let newData = data.replacingChild(raw, at: Cursor.lineArgColon)
    return PoundSourceLocationArgsSyntax(newData)
  }
  public var lineNumber: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.lineNumber, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withLineNumber(value)
    }
  }

  /// Returns a copy of the receiver with its `lineNumber` replaced.
  /// - param newChild: The new `lineNumber` to replace the node's
  ///                   current `lineNumber`, if present.
  public func withLineNumber(
    _ newChild: TokenSyntax?) -> PoundSourceLocationArgsSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.integerLiteral(""))
    let newData = data.replacingChild(raw, at: Cursor.lineNumber)
    return PoundSourceLocationArgsSyntax(newData)
  }

  /// Returns a new `PoundSourceLocationArgsSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> PoundSourceLocationArgsSyntax {
    return PoundSourceLocationArgsSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `PoundSourceLocationArgsSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> PoundSourceLocationArgsSyntax {
    return PoundSourceLocationArgsSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `PoundSourceLocationArgsSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> PoundSourceLocationArgsSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `PoundSourceLocationArgsSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> PoundSourceLocationArgsSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `PoundSourceLocationArgsSyntax` with all trivia removed.
  public func withoutTrivia() -> PoundSourceLocationArgsSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `PoundSourceLocationArgsSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `PoundSourceLocationArgsSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `DeclModifierSyntax` nodes conform. Extension point to add
/// common methods to all `DeclModifierSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol DeclModifierSyntaxProtocol: SyntaxProtocol {}


public struct DeclModifierSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case name
    case detailLeftParen
    case detail
    case detailRightParen
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `DeclModifierSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .declModifier else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `DeclModifierSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .declModifier)
    self._syntaxNode = Syntax(data)
  }

  public var name: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.name, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withName(value)
    }
  }

  /// Returns a copy of the receiver with its `name` replaced.
  /// - param newChild: The new `name` to replace the node's
  ///                   current `name`, if present.
  public func withName(
    _ newChild: TokenSyntax?) -> DeclModifierSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.unknown(""))
    let newData = data.replacingChild(raw, at: Cursor.name)
    return DeclModifierSyntax(newData)
  }
  public var detailLeftParen: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.detailLeftParen, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withDetailLeftParen(value)
    }
  }

  /// Returns a copy of the receiver with its `detailLeftParen` replaced.
  /// - param newChild: The new `detailLeftParen` to replace the node's
  ///                   current `detailLeftParen`, if present.
  public func withDetailLeftParen(
    _ newChild: TokenSyntax?) -> DeclModifierSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.detailLeftParen)
    return DeclModifierSyntax(newData)
  }
  public var detail: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.detail, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withDetail(value)
    }
  }

  /// Returns a copy of the receiver with its `detail` replaced.
  /// - param newChild: The new `detail` to replace the node's
  ///                   current `detail`, if present.
  public func withDetail(
    _ newChild: TokenSyntax?) -> DeclModifierSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.detail)
    return DeclModifierSyntax(newData)
  }
  public var detailRightParen: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.detailRightParen, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withDetailRightParen(value)
    }
  }

  /// Returns a copy of the receiver with its `detailRightParen` replaced.
  /// - param newChild: The new `detailRightParen` to replace the node's
  ///                   current `detailRightParen`, if present.
  public func withDetailRightParen(
    _ newChild: TokenSyntax?) -> DeclModifierSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.detailRightParen)
    return DeclModifierSyntax(newData)
  }

  /// Returns a new `DeclModifierSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> DeclModifierSyntax {
    return DeclModifierSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `DeclModifierSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> DeclModifierSyntax {
    return DeclModifierSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `DeclModifierSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> DeclModifierSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `DeclModifierSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> DeclModifierSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `DeclModifierSyntax` with all trivia removed.
  public func withoutTrivia() -> DeclModifierSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `DeclModifierSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `DeclModifierSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `InheritedTypeSyntax` nodes conform. Extension point to add
/// common methods to all `InheritedTypeSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol InheritedTypeSyntaxProtocol: SyntaxProtocol {}


public struct InheritedTypeSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case typeName
    case trailingComma
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `InheritedTypeSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .inheritedType else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `InheritedTypeSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .inheritedType)
    self._syntaxNode = Syntax(data)
  }

  public var typeName: TypeSyntax {
    get {
      let childData = data.child(at: Cursor.typeName, 
                                 parent: Syntax(self))
      return TypeSyntax(childData!)
    }
    set(value) {
      self = withTypeName(value)
    }
  }

  /// Returns a copy of the receiver with its `typeName` replaced.
  /// - param newChild: The new `typeName` to replace the node's
  ///                   current `typeName`, if present.
  public func withTypeName(
    _ newChild: TypeSyntax?) -> InheritedTypeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.type)
    let newData = data.replacingChild(raw, at: Cursor.typeName)
    return InheritedTypeSyntax(newData)
  }
  public var trailingComma: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.trailingComma, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withTrailingComma(value)
    }
  }

  /// Returns a copy of the receiver with its `trailingComma` replaced.
  /// - param newChild: The new `trailingComma` to replace the node's
  ///                   current `trailingComma`, if present.
  public func withTrailingComma(
    _ newChild: TokenSyntax?) -> InheritedTypeSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.trailingComma)
    return InheritedTypeSyntax(newData)
  }

  /// Returns a new `InheritedTypeSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> InheritedTypeSyntax {
    return InheritedTypeSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `InheritedTypeSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> InheritedTypeSyntax {
    return InheritedTypeSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `InheritedTypeSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> InheritedTypeSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `InheritedTypeSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> InheritedTypeSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `InheritedTypeSyntax` with all trivia removed.
  public func withoutTrivia() -> InheritedTypeSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `InheritedTypeSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `InheritedTypeSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `InheritedTypeListSyntax` nodes conform. Extension point to add
/// common methods to all `InheritedTypeListSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol InheritedTypeListSyntaxProtocol: SyntaxProtocol {}

/// Protocol to which all `TypeInheritanceClauseSyntax` nodes conform. Extension point to add
/// common methods to all `TypeInheritanceClauseSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol TypeInheritanceClauseSyntaxProtocol: SyntaxProtocol {}


public struct TypeInheritanceClauseSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case colon
    case inheritedTypeCollection
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `TypeInheritanceClauseSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .typeInheritanceClause else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `TypeInheritanceClauseSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .typeInheritanceClause)
    self._syntaxNode = Syntax(data)
  }

  public var colon: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.colon, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withColon(value)
    }
  }

  /// Returns a copy of the receiver with its `colon` replaced.
  /// - param newChild: The new `colon` to replace the node's
  ///                   current `colon`, if present.
  public func withColon(
    _ newChild: TokenSyntax?) -> TypeInheritanceClauseSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.colon)
    let newData = data.replacingChild(raw, at: Cursor.colon)
    return TypeInheritanceClauseSyntax(newData)
  }
  public var inheritedTypeCollection: InheritedTypeListSyntax {
    get {
      let childData = data.child(at: Cursor.inheritedTypeCollection, 
                                 parent: Syntax(self))
      return InheritedTypeListSyntax(childData!)
    }
    set(value) {
      self = withInheritedTypeCollection(value)
    }
  }

  /// Adds the provided `InheritedType` to the node's `inheritedTypeCollection`
  /// collection.
  /// - param element: The new `InheritedType` to add to the node's
  ///                  `inheritedTypeCollection` collection.
  /// - returns: A copy of the receiver with the provided `InheritedType`
  ///            appended to its `inheritedTypeCollection` collection.
  public func addInheritedType(_ element: InheritedTypeSyntax) -> TypeInheritanceClauseSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.inheritedTypeCollection] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.inheritedTypeList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.inheritedTypeCollection)
    return TypeInheritanceClauseSyntax(newData)
  }

  /// Returns a copy of the receiver with its `inheritedTypeCollection` replaced.
  /// - param newChild: The new `inheritedTypeCollection` to replace the node's
  ///                   current `inheritedTypeCollection`, if present.
  public func withInheritedTypeCollection(
    _ newChild: InheritedTypeListSyntax?) -> TypeInheritanceClauseSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.inheritedTypeList)
    let newData = data.replacingChild(raw, at: Cursor.inheritedTypeCollection)
    return TypeInheritanceClauseSyntax(newData)
  }

  /// Returns a new `TypeInheritanceClauseSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> TypeInheritanceClauseSyntax {
    return TypeInheritanceClauseSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `TypeInheritanceClauseSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> TypeInheritanceClauseSyntax {
    return TypeInheritanceClauseSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `TypeInheritanceClauseSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> TypeInheritanceClauseSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `TypeInheritanceClauseSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> TypeInheritanceClauseSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `TypeInheritanceClauseSyntax` with all trivia removed.
  public func withoutTrivia() -> TypeInheritanceClauseSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `TypeInheritanceClauseSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `TypeInheritanceClauseSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `ClassDeclSyntax` nodes conform. Extension point to add
/// common methods to all `ClassDeclSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol ClassDeclSyntaxProtocol: DeclSyntaxProtocol {}


public struct ClassDeclSyntax: DeclSyntaxProtocol {
  enum Cursor: Int {
    case attributes
    case modifiers
    case classKeyword
    case identifier
    case genericParameterClause
    case inheritanceClause
    case genericWhereClause
    case members
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `ClassDeclSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .classDecl else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `ClassDeclSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .classDecl)
    self._syntaxNode = Syntax(data)
  }

  public var attributes: AttributeListSyntax? {
    get {
      let childData = data.child(at: Cursor.attributes, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return AttributeListSyntax(childData!)
    }
    set(value) {
      self = withAttributes(value)
    }
  }

  /// Adds the provided `Attribute` to the node's `attributes`
  /// collection.
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  public func addAttribute(_ element: Syntax) -> ClassDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.attributes] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.attributeList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.attributes)
    return ClassDeclSyntax(newData)
  }

  /// Returns a copy of the receiver with its `attributes` replaced.
  /// - param newChild: The new `attributes` to replace the node's
  ///                   current `attributes`, if present.
  public func withAttributes(
    _ newChild: AttributeListSyntax?) -> ClassDeclSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.attributes)
    return ClassDeclSyntax(newData)
  }
  public var modifiers: ModifierListSyntax? {
    get {
      let childData = data.child(at: Cursor.modifiers, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return ModifierListSyntax(childData!)
    }
    set(value) {
      self = withModifiers(value)
    }
  }

  /// Adds the provided `Modifier` to the node's `modifiers`
  /// collection.
  /// - param element: The new `Modifier` to add to the node's
  ///                  `modifiers` collection.
  /// - returns: A copy of the receiver with the provided `Modifier`
  ///            appended to its `modifiers` collection.
  public func addModifier(_ element: DeclModifierSyntax) -> ClassDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.modifiers] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.modifierList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.modifiers)
    return ClassDeclSyntax(newData)
  }

  /// Returns a copy of the receiver with its `modifiers` replaced.
  /// - param newChild: The new `modifiers` to replace the node's
  ///                   current `modifiers`, if present.
  public func withModifiers(
    _ newChild: ModifierListSyntax?) -> ClassDeclSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.modifiers)
    return ClassDeclSyntax(newData)
  }
  public var classKeyword: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.classKeyword, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withClassKeyword(value)
    }
  }

  /// Returns a copy of the receiver with its `classKeyword` replaced.
  /// - param newChild: The new `classKeyword` to replace the node's
  ///                   current `classKeyword`, if present.
  public func withClassKeyword(
    _ newChild: TokenSyntax?) -> ClassDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.classKeyword)
    let newData = data.replacingChild(raw, at: Cursor.classKeyword)
    return ClassDeclSyntax(newData)
  }
  public var identifier: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.identifier, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withIdentifier(value)
    }
  }

  /// Returns a copy of the receiver with its `identifier` replaced.
  /// - param newChild: The new `identifier` to replace the node's
  ///                   current `identifier`, if present.
  public func withIdentifier(
    _ newChild: TokenSyntax?) -> ClassDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let newData = data.replacingChild(raw, at: Cursor.identifier)
    return ClassDeclSyntax(newData)
  }
  public var genericParameterClause: GenericParameterClauseSyntax? {
    get {
      let childData = data.child(at: Cursor.genericParameterClause, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return GenericParameterClauseSyntax(childData!)
    }
    set(value) {
      self = withGenericParameterClause(value)
    }
  }

  /// Returns a copy of the receiver with its `genericParameterClause` replaced.
  /// - param newChild: The new `genericParameterClause` to replace the node's
  ///                   current `genericParameterClause`, if present.
  public func withGenericParameterClause(
    _ newChild: GenericParameterClauseSyntax?) -> ClassDeclSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.genericParameterClause)
    return ClassDeclSyntax(newData)
  }
  public var inheritanceClause: TypeInheritanceClauseSyntax? {
    get {
      let childData = data.child(at: Cursor.inheritanceClause, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TypeInheritanceClauseSyntax(childData!)
    }
    set(value) {
      self = withInheritanceClause(value)
    }
  }

  /// Returns a copy of the receiver with its `inheritanceClause` replaced.
  /// - param newChild: The new `inheritanceClause` to replace the node's
  ///                   current `inheritanceClause`, if present.
  public func withInheritanceClause(
    _ newChild: TypeInheritanceClauseSyntax?) -> ClassDeclSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.inheritanceClause)
    return ClassDeclSyntax(newData)
  }
  public var genericWhereClause: GenericWhereClauseSyntax? {
    get {
      let childData = data.child(at: Cursor.genericWhereClause, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return GenericWhereClauseSyntax(childData!)
    }
    set(value) {
      self = withGenericWhereClause(value)
    }
  }

  /// Returns a copy of the receiver with its `genericWhereClause` replaced.
  /// - param newChild: The new `genericWhereClause` to replace the node's
  ///                   current `genericWhereClause`, if present.
  public func withGenericWhereClause(
    _ newChild: GenericWhereClauseSyntax?) -> ClassDeclSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.genericWhereClause)
    return ClassDeclSyntax(newData)
  }
  public var members: MemberDeclBlockSyntax {
    get {
      let childData = data.child(at: Cursor.members, 
                                 parent: Syntax(self))
      return MemberDeclBlockSyntax(childData!)
    }
    set(value) {
      self = withMembers(value)
    }
  }

  /// Returns a copy of the receiver with its `members` replaced.
  /// - param newChild: The new `members` to replace the node's
  ///                   current `members`, if present.
  public func withMembers(
    _ newChild: MemberDeclBlockSyntax?) -> ClassDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.memberDeclBlock)
    let newData = data.replacingChild(raw, at: Cursor.members)
    return ClassDeclSyntax(newData)
  }

  /// Returns a new `ClassDeclSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> ClassDeclSyntax {
    return ClassDeclSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `ClassDeclSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> ClassDeclSyntax {
    return ClassDeclSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `ClassDeclSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> ClassDeclSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `ClassDeclSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> ClassDeclSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `ClassDeclSyntax` with all trivia removed.
  public func withoutTrivia() -> ClassDeclSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `ClassDeclSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `ClassDeclSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `StructDeclSyntax` nodes conform. Extension point to add
/// common methods to all `StructDeclSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol StructDeclSyntaxProtocol: DeclSyntaxProtocol {}


public struct StructDeclSyntax: DeclSyntaxProtocol {
  enum Cursor: Int {
    case attributes
    case modifiers
    case structKeyword
    case identifier
    case genericParameterClause
    case inheritanceClause
    case genericWhereClause
    case members
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `StructDeclSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .structDecl else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `StructDeclSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .structDecl)
    self._syntaxNode = Syntax(data)
  }

  public var attributes: AttributeListSyntax? {
    get {
      let childData = data.child(at: Cursor.attributes, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return AttributeListSyntax(childData!)
    }
    set(value) {
      self = withAttributes(value)
    }
  }

  /// Adds the provided `Attribute` to the node's `attributes`
  /// collection.
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  public func addAttribute(_ element: Syntax) -> StructDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.attributes] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.attributeList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.attributes)
    return StructDeclSyntax(newData)
  }

  /// Returns a copy of the receiver with its `attributes` replaced.
  /// - param newChild: The new `attributes` to replace the node's
  ///                   current `attributes`, if present.
  public func withAttributes(
    _ newChild: AttributeListSyntax?) -> StructDeclSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.attributes)
    return StructDeclSyntax(newData)
  }
  public var modifiers: ModifierListSyntax? {
    get {
      let childData = data.child(at: Cursor.modifiers, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return ModifierListSyntax(childData!)
    }
    set(value) {
      self = withModifiers(value)
    }
  }

  /// Adds the provided `Modifier` to the node's `modifiers`
  /// collection.
  /// - param element: The new `Modifier` to add to the node's
  ///                  `modifiers` collection.
  /// - returns: A copy of the receiver with the provided `Modifier`
  ///            appended to its `modifiers` collection.
  public func addModifier(_ element: DeclModifierSyntax) -> StructDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.modifiers] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.modifierList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.modifiers)
    return StructDeclSyntax(newData)
  }

  /// Returns a copy of the receiver with its `modifiers` replaced.
  /// - param newChild: The new `modifiers` to replace the node's
  ///                   current `modifiers`, if present.
  public func withModifiers(
    _ newChild: ModifierListSyntax?) -> StructDeclSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.modifiers)
    return StructDeclSyntax(newData)
  }
  public var structKeyword: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.structKeyword, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withStructKeyword(value)
    }
  }

  /// Returns a copy of the receiver with its `structKeyword` replaced.
  /// - param newChild: The new `structKeyword` to replace the node's
  ///                   current `structKeyword`, if present.
  public func withStructKeyword(
    _ newChild: TokenSyntax?) -> StructDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.structKeyword)
    let newData = data.replacingChild(raw, at: Cursor.structKeyword)
    return StructDeclSyntax(newData)
  }
  public var identifier: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.identifier, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withIdentifier(value)
    }
  }

  /// Returns a copy of the receiver with its `identifier` replaced.
  /// - param newChild: The new `identifier` to replace the node's
  ///                   current `identifier`, if present.
  public func withIdentifier(
    _ newChild: TokenSyntax?) -> StructDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let newData = data.replacingChild(raw, at: Cursor.identifier)
    return StructDeclSyntax(newData)
  }
  public var genericParameterClause: GenericParameterClauseSyntax? {
    get {
      let childData = data.child(at: Cursor.genericParameterClause, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return GenericParameterClauseSyntax(childData!)
    }
    set(value) {
      self = withGenericParameterClause(value)
    }
  }

  /// Returns a copy of the receiver with its `genericParameterClause` replaced.
  /// - param newChild: The new `genericParameterClause` to replace the node's
  ///                   current `genericParameterClause`, if present.
  public func withGenericParameterClause(
    _ newChild: GenericParameterClauseSyntax?) -> StructDeclSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.genericParameterClause)
    return StructDeclSyntax(newData)
  }
  public var inheritanceClause: TypeInheritanceClauseSyntax? {
    get {
      let childData = data.child(at: Cursor.inheritanceClause, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TypeInheritanceClauseSyntax(childData!)
    }
    set(value) {
      self = withInheritanceClause(value)
    }
  }

  /// Returns a copy of the receiver with its `inheritanceClause` replaced.
  /// - param newChild: The new `inheritanceClause` to replace the node's
  ///                   current `inheritanceClause`, if present.
  public func withInheritanceClause(
    _ newChild: TypeInheritanceClauseSyntax?) -> StructDeclSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.inheritanceClause)
    return StructDeclSyntax(newData)
  }
  public var genericWhereClause: GenericWhereClauseSyntax? {
    get {
      let childData = data.child(at: Cursor.genericWhereClause, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return GenericWhereClauseSyntax(childData!)
    }
    set(value) {
      self = withGenericWhereClause(value)
    }
  }

  /// Returns a copy of the receiver with its `genericWhereClause` replaced.
  /// - param newChild: The new `genericWhereClause` to replace the node's
  ///                   current `genericWhereClause`, if present.
  public func withGenericWhereClause(
    _ newChild: GenericWhereClauseSyntax?) -> StructDeclSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.genericWhereClause)
    return StructDeclSyntax(newData)
  }
  public var members: MemberDeclBlockSyntax {
    get {
      let childData = data.child(at: Cursor.members, 
                                 parent: Syntax(self))
      return MemberDeclBlockSyntax(childData!)
    }
    set(value) {
      self = withMembers(value)
    }
  }

  /// Returns a copy of the receiver with its `members` replaced.
  /// - param newChild: The new `members` to replace the node's
  ///                   current `members`, if present.
  public func withMembers(
    _ newChild: MemberDeclBlockSyntax?) -> StructDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.memberDeclBlock)
    let newData = data.replacingChild(raw, at: Cursor.members)
    return StructDeclSyntax(newData)
  }

  /// Returns a new `StructDeclSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> StructDeclSyntax {
    return StructDeclSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `StructDeclSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> StructDeclSyntax {
    return StructDeclSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `StructDeclSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> StructDeclSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `StructDeclSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> StructDeclSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `StructDeclSyntax` with all trivia removed.
  public func withoutTrivia() -> StructDeclSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `StructDeclSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `StructDeclSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `ProtocolDeclSyntax` nodes conform. Extension point to add
/// common methods to all `ProtocolDeclSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol ProtocolDeclSyntaxProtocol: DeclSyntaxProtocol {}


public struct ProtocolDeclSyntax: DeclSyntaxProtocol {
  enum Cursor: Int {
    case attributes
    case modifiers
    case protocolKeyword
    case identifier
    case inheritanceClause
    case genericWhereClause
    case members
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `ProtocolDeclSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .protocolDecl else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `ProtocolDeclSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .protocolDecl)
    self._syntaxNode = Syntax(data)
  }

  public var attributes: AttributeListSyntax? {
    get {
      let childData = data.child(at: Cursor.attributes, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return AttributeListSyntax(childData!)
    }
    set(value) {
      self = withAttributes(value)
    }
  }

  /// Adds the provided `Attribute` to the node's `attributes`
  /// collection.
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  public func addAttribute(_ element: Syntax) -> ProtocolDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.attributes] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.attributeList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.attributes)
    return ProtocolDeclSyntax(newData)
  }

  /// Returns a copy of the receiver with its `attributes` replaced.
  /// - param newChild: The new `attributes` to replace the node's
  ///                   current `attributes`, if present.
  public func withAttributes(
    _ newChild: AttributeListSyntax?) -> ProtocolDeclSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.attributes)
    return ProtocolDeclSyntax(newData)
  }
  public var modifiers: ModifierListSyntax? {
    get {
      let childData = data.child(at: Cursor.modifiers, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return ModifierListSyntax(childData!)
    }
    set(value) {
      self = withModifiers(value)
    }
  }

  /// Adds the provided `Modifier` to the node's `modifiers`
  /// collection.
  /// - param element: The new `Modifier` to add to the node's
  ///                  `modifiers` collection.
  /// - returns: A copy of the receiver with the provided `Modifier`
  ///            appended to its `modifiers` collection.
  public func addModifier(_ element: DeclModifierSyntax) -> ProtocolDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.modifiers] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.modifierList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.modifiers)
    return ProtocolDeclSyntax(newData)
  }

  /// Returns a copy of the receiver with its `modifiers` replaced.
  /// - param newChild: The new `modifiers` to replace the node's
  ///                   current `modifiers`, if present.
  public func withModifiers(
    _ newChild: ModifierListSyntax?) -> ProtocolDeclSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.modifiers)
    return ProtocolDeclSyntax(newData)
  }
  public var protocolKeyword: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.protocolKeyword, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withProtocolKeyword(value)
    }
  }

  /// Returns a copy of the receiver with its `protocolKeyword` replaced.
  /// - param newChild: The new `protocolKeyword` to replace the node's
  ///                   current `protocolKeyword`, if present.
  public func withProtocolKeyword(
    _ newChild: TokenSyntax?) -> ProtocolDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.protocolKeyword)
    let newData = data.replacingChild(raw, at: Cursor.protocolKeyword)
    return ProtocolDeclSyntax(newData)
  }
  public var identifier: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.identifier, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withIdentifier(value)
    }
  }

  /// Returns a copy of the receiver with its `identifier` replaced.
  /// - param newChild: The new `identifier` to replace the node's
  ///                   current `identifier`, if present.
  public func withIdentifier(
    _ newChild: TokenSyntax?) -> ProtocolDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let newData = data.replacingChild(raw, at: Cursor.identifier)
    return ProtocolDeclSyntax(newData)
  }
  public var inheritanceClause: TypeInheritanceClauseSyntax? {
    get {
      let childData = data.child(at: Cursor.inheritanceClause, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TypeInheritanceClauseSyntax(childData!)
    }
    set(value) {
      self = withInheritanceClause(value)
    }
  }

  /// Returns a copy of the receiver with its `inheritanceClause` replaced.
  /// - param newChild: The new `inheritanceClause` to replace the node's
  ///                   current `inheritanceClause`, if present.
  public func withInheritanceClause(
    _ newChild: TypeInheritanceClauseSyntax?) -> ProtocolDeclSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.inheritanceClause)
    return ProtocolDeclSyntax(newData)
  }
  public var genericWhereClause: GenericWhereClauseSyntax? {
    get {
      let childData = data.child(at: Cursor.genericWhereClause, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return GenericWhereClauseSyntax(childData!)
    }
    set(value) {
      self = withGenericWhereClause(value)
    }
  }

  /// Returns a copy of the receiver with its `genericWhereClause` replaced.
  /// - param newChild: The new `genericWhereClause` to replace the node's
  ///                   current `genericWhereClause`, if present.
  public func withGenericWhereClause(
    _ newChild: GenericWhereClauseSyntax?) -> ProtocolDeclSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.genericWhereClause)
    return ProtocolDeclSyntax(newData)
  }
  public var members: MemberDeclBlockSyntax {
    get {
      let childData = data.child(at: Cursor.members, 
                                 parent: Syntax(self))
      return MemberDeclBlockSyntax(childData!)
    }
    set(value) {
      self = withMembers(value)
    }
  }

  /// Returns a copy of the receiver with its `members` replaced.
  /// - param newChild: The new `members` to replace the node's
  ///                   current `members`, if present.
  public func withMembers(
    _ newChild: MemberDeclBlockSyntax?) -> ProtocolDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.memberDeclBlock)
    let newData = data.replacingChild(raw, at: Cursor.members)
    return ProtocolDeclSyntax(newData)
  }

  /// Returns a new `ProtocolDeclSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> ProtocolDeclSyntax {
    return ProtocolDeclSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `ProtocolDeclSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> ProtocolDeclSyntax {
    return ProtocolDeclSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `ProtocolDeclSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> ProtocolDeclSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `ProtocolDeclSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> ProtocolDeclSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `ProtocolDeclSyntax` with all trivia removed.
  public func withoutTrivia() -> ProtocolDeclSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `ProtocolDeclSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `ProtocolDeclSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `ExtensionDeclSyntax` nodes conform. Extension point to add
/// common methods to all `ExtensionDeclSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol ExtensionDeclSyntaxProtocol: DeclSyntaxProtocol {}


public struct ExtensionDeclSyntax: DeclSyntaxProtocol {
  enum Cursor: Int {
    case attributes
    case modifiers
    case extensionKeyword
    case extendedType
    case inheritanceClause
    case genericWhereClause
    case members
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `ExtensionDeclSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .extensionDecl else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `ExtensionDeclSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .extensionDecl)
    self._syntaxNode = Syntax(data)
  }

  public var attributes: AttributeListSyntax? {
    get {
      let childData = data.child(at: Cursor.attributes, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return AttributeListSyntax(childData!)
    }
    set(value) {
      self = withAttributes(value)
    }
  }

  /// Adds the provided `Attribute` to the node's `attributes`
  /// collection.
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  public func addAttribute(_ element: Syntax) -> ExtensionDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.attributes] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.attributeList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.attributes)
    return ExtensionDeclSyntax(newData)
  }

  /// Returns a copy of the receiver with its `attributes` replaced.
  /// - param newChild: The new `attributes` to replace the node's
  ///                   current `attributes`, if present.
  public func withAttributes(
    _ newChild: AttributeListSyntax?) -> ExtensionDeclSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.attributes)
    return ExtensionDeclSyntax(newData)
  }
  public var modifiers: ModifierListSyntax? {
    get {
      let childData = data.child(at: Cursor.modifiers, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return ModifierListSyntax(childData!)
    }
    set(value) {
      self = withModifiers(value)
    }
  }

  /// Adds the provided `Modifier` to the node's `modifiers`
  /// collection.
  /// - param element: The new `Modifier` to add to the node's
  ///                  `modifiers` collection.
  /// - returns: A copy of the receiver with the provided `Modifier`
  ///            appended to its `modifiers` collection.
  public func addModifier(_ element: DeclModifierSyntax) -> ExtensionDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.modifiers] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.modifierList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.modifiers)
    return ExtensionDeclSyntax(newData)
  }

  /// Returns a copy of the receiver with its `modifiers` replaced.
  /// - param newChild: The new `modifiers` to replace the node's
  ///                   current `modifiers`, if present.
  public func withModifiers(
    _ newChild: ModifierListSyntax?) -> ExtensionDeclSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.modifiers)
    return ExtensionDeclSyntax(newData)
  }
  public var extensionKeyword: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.extensionKeyword, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withExtensionKeyword(value)
    }
  }

  /// Returns a copy of the receiver with its `extensionKeyword` replaced.
  /// - param newChild: The new `extensionKeyword` to replace the node's
  ///                   current `extensionKeyword`, if present.
  public func withExtensionKeyword(
    _ newChild: TokenSyntax?) -> ExtensionDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.extensionKeyword)
    let newData = data.replacingChild(raw, at: Cursor.extensionKeyword)
    return ExtensionDeclSyntax(newData)
  }
  public var extendedType: TypeSyntax {
    get {
      let childData = data.child(at: Cursor.extendedType, 
                                 parent: Syntax(self))
      return TypeSyntax(childData!)
    }
    set(value) {
      self = withExtendedType(value)
    }
  }

  /// Returns a copy of the receiver with its `extendedType` replaced.
  /// - param newChild: The new `extendedType` to replace the node's
  ///                   current `extendedType`, if present.
  public func withExtendedType(
    _ newChild: TypeSyntax?) -> ExtensionDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.type)
    let newData = data.replacingChild(raw, at: Cursor.extendedType)
    return ExtensionDeclSyntax(newData)
  }
  public var inheritanceClause: TypeInheritanceClauseSyntax? {
    get {
      let childData = data.child(at: Cursor.inheritanceClause, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TypeInheritanceClauseSyntax(childData!)
    }
    set(value) {
      self = withInheritanceClause(value)
    }
  }

  /// Returns a copy of the receiver with its `inheritanceClause` replaced.
  /// - param newChild: The new `inheritanceClause` to replace the node's
  ///                   current `inheritanceClause`, if present.
  public func withInheritanceClause(
    _ newChild: TypeInheritanceClauseSyntax?) -> ExtensionDeclSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.inheritanceClause)
    return ExtensionDeclSyntax(newData)
  }
  public var genericWhereClause: GenericWhereClauseSyntax? {
    get {
      let childData = data.child(at: Cursor.genericWhereClause, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return GenericWhereClauseSyntax(childData!)
    }
    set(value) {
      self = withGenericWhereClause(value)
    }
  }

  /// Returns a copy of the receiver with its `genericWhereClause` replaced.
  /// - param newChild: The new `genericWhereClause` to replace the node's
  ///                   current `genericWhereClause`, if present.
  public func withGenericWhereClause(
    _ newChild: GenericWhereClauseSyntax?) -> ExtensionDeclSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.genericWhereClause)
    return ExtensionDeclSyntax(newData)
  }
  public var members: MemberDeclBlockSyntax {
    get {
      let childData = data.child(at: Cursor.members, 
                                 parent: Syntax(self))
      return MemberDeclBlockSyntax(childData!)
    }
    set(value) {
      self = withMembers(value)
    }
  }

  /// Returns a copy of the receiver with its `members` replaced.
  /// - param newChild: The new `members` to replace the node's
  ///                   current `members`, if present.
  public func withMembers(
    _ newChild: MemberDeclBlockSyntax?) -> ExtensionDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.memberDeclBlock)
    let newData = data.replacingChild(raw, at: Cursor.members)
    return ExtensionDeclSyntax(newData)
  }

  /// Returns a new `ExtensionDeclSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> ExtensionDeclSyntax {
    return ExtensionDeclSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `ExtensionDeclSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> ExtensionDeclSyntax {
    return ExtensionDeclSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `ExtensionDeclSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> ExtensionDeclSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `ExtensionDeclSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> ExtensionDeclSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `ExtensionDeclSyntax` with all trivia removed.
  public func withoutTrivia() -> ExtensionDeclSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `ExtensionDeclSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `ExtensionDeclSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `MemberDeclBlockSyntax` nodes conform. Extension point to add
/// common methods to all `MemberDeclBlockSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol MemberDeclBlockSyntaxProtocol: SyntaxProtocol {}


public struct MemberDeclBlockSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case leftBrace
    case members
    case rightBrace
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `MemberDeclBlockSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .memberDeclBlock else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `MemberDeclBlockSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .memberDeclBlock)
    self._syntaxNode = Syntax(data)
  }

  public var leftBrace: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.leftBrace, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withLeftBrace(value)
    }
  }

  /// Returns a copy of the receiver with its `leftBrace` replaced.
  /// - param newChild: The new `leftBrace` to replace the node's
  ///                   current `leftBrace`, if present.
  public func withLeftBrace(
    _ newChild: TokenSyntax?) -> MemberDeclBlockSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.leftBrace)
    let newData = data.replacingChild(raw, at: Cursor.leftBrace)
    return MemberDeclBlockSyntax(newData)
  }
  public var members: MemberDeclListSyntax {
    get {
      let childData = data.child(at: Cursor.members, 
                                 parent: Syntax(self))
      return MemberDeclListSyntax(childData!)
    }
    set(value) {
      self = withMembers(value)
    }
  }

  /// Adds the provided `Member` to the node's `members`
  /// collection.
  /// - param element: The new `Member` to add to the node's
  ///                  `members` collection.
  /// - returns: A copy of the receiver with the provided `Member`
  ///            appended to its `members` collection.
  public func addMember(_ element: MemberDeclListItemSyntax) -> MemberDeclBlockSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.members] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.memberDeclList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.members)
    return MemberDeclBlockSyntax(newData)
  }

  /// Returns a copy of the receiver with its `members` replaced.
  /// - param newChild: The new `members` to replace the node's
  ///                   current `members`, if present.
  public func withMembers(
    _ newChild: MemberDeclListSyntax?) -> MemberDeclBlockSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.memberDeclList)
    let newData = data.replacingChild(raw, at: Cursor.members)
    return MemberDeclBlockSyntax(newData)
  }
  public var rightBrace: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.rightBrace, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withRightBrace(value)
    }
  }

  /// Returns a copy of the receiver with its `rightBrace` replaced.
  /// - param newChild: The new `rightBrace` to replace the node's
  ///                   current `rightBrace`, if present.
  public func withRightBrace(
    _ newChild: TokenSyntax?) -> MemberDeclBlockSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.rightBrace)
    let newData = data.replacingChild(raw, at: Cursor.rightBrace)
    return MemberDeclBlockSyntax(newData)
  }

  /// Returns a new `MemberDeclBlockSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> MemberDeclBlockSyntax {
    return MemberDeclBlockSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `MemberDeclBlockSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> MemberDeclBlockSyntax {
    return MemberDeclBlockSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `MemberDeclBlockSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> MemberDeclBlockSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `MemberDeclBlockSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> MemberDeclBlockSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `MemberDeclBlockSyntax` with all trivia removed.
  public func withoutTrivia() -> MemberDeclBlockSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `MemberDeclBlockSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `MemberDeclBlockSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `MemberDeclListSyntax` nodes conform. Extension point to add
/// common methods to all `MemberDeclListSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol MemberDeclListSyntaxProtocol: SyntaxProtocol {}

/// Protocol to which all `MemberDeclListItemSyntax` nodes conform. Extension point to add
/// common methods to all `MemberDeclListItemSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol MemberDeclListItemSyntaxProtocol: SyntaxProtocol {}


/// 
/// A member declaration of a type consisting of a declaration and an          optional semicolon;
/// 
public struct MemberDeclListItemSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case decl
    case semicolon
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `MemberDeclListItemSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .memberDeclListItem else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `MemberDeclListItemSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .memberDeclListItem)
    self._syntaxNode = Syntax(data)
  }

  /// The declaration of the type member.
  public var decl: DeclSyntax {
    get {
      let childData = data.child(at: Cursor.decl, 
                                 parent: Syntax(self))
      return DeclSyntax(childData!)
    }
    set(value) {
      self = withDecl(value)
    }
  }

  /// Returns a copy of the receiver with its `decl` replaced.
  /// - param newChild: The new `decl` to replace the node's
  ///                   current `decl`, if present.
  public func withDecl(
    _ newChild: DeclSyntax?) -> MemberDeclListItemSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.decl)
    let newData = data.replacingChild(raw, at: Cursor.decl)
    return MemberDeclListItemSyntax(newData)
  }
  /// An optional trailing semicolon.
  public var semicolon: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.semicolon, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withSemicolon(value)
    }
  }

  /// Returns a copy of the receiver with its `semicolon` replaced.
  /// - param newChild: The new `semicolon` to replace the node's
  ///                   current `semicolon`, if present.
  public func withSemicolon(
    _ newChild: TokenSyntax?) -> MemberDeclListItemSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.semicolon)
    return MemberDeclListItemSyntax(newData)
  }

  /// Returns a new `MemberDeclListItemSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> MemberDeclListItemSyntax {
    return MemberDeclListItemSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `MemberDeclListItemSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> MemberDeclListItemSyntax {
    return MemberDeclListItemSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `MemberDeclListItemSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> MemberDeclListItemSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `MemberDeclListItemSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> MemberDeclListItemSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `MemberDeclListItemSyntax` with all trivia removed.
  public func withoutTrivia() -> MemberDeclListItemSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `MemberDeclListItemSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `MemberDeclListItemSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `SourceFileSyntax` nodes conform. Extension point to add
/// common methods to all `SourceFileSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol SourceFileSyntaxProtocol: SyntaxProtocol {}


public struct SourceFileSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case statements
    case eofToken
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `SourceFileSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .sourceFile else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `SourceFileSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .sourceFile)
    self._syntaxNode = Syntax(data)
  }

  public var statements: CodeBlockItemListSyntax {
    get {
      let childData = data.child(at: Cursor.statements, 
                                 parent: Syntax(self))
      return CodeBlockItemListSyntax(childData!)
    }
    set(value) {
      self = withStatements(value)
    }
  }

  /// Adds the provided `Statement` to the node's `statements`
  /// collection.
  /// - param element: The new `Statement` to add to the node's
  ///                  `statements` collection.
  /// - returns: A copy of the receiver with the provided `Statement`
  ///            appended to its `statements` collection.
  public func addStatement(_ element: CodeBlockItemSyntax) -> SourceFileSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.statements] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.codeBlockItemList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.statements)
    return SourceFileSyntax(newData)
  }

  /// Returns a copy of the receiver with its `statements` replaced.
  /// - param newChild: The new `statements` to replace the node's
  ///                   current `statements`, if present.
  public func withStatements(
    _ newChild: CodeBlockItemListSyntax?) -> SourceFileSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.codeBlockItemList)
    let newData = data.replacingChild(raw, at: Cursor.statements)
    return SourceFileSyntax(newData)
  }
  public var eofToken: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.eofToken, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withEOFToken(value)
    }
  }

  /// Returns a copy of the receiver with its `eofToken` replaced.
  /// - param newChild: The new `eofToken` to replace the node's
  ///                   current `eofToken`, if present.
  public func withEOFToken(
    _ newChild: TokenSyntax?) -> SourceFileSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.unknown(""))
    let newData = data.replacingChild(raw, at: Cursor.eofToken)
    return SourceFileSyntax(newData)
  }

  /// Returns a new `SourceFileSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> SourceFileSyntax {
    return SourceFileSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `SourceFileSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> SourceFileSyntax {
    return SourceFileSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `SourceFileSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> SourceFileSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `SourceFileSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> SourceFileSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `SourceFileSyntax` with all trivia removed.
  public func withoutTrivia() -> SourceFileSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `SourceFileSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `SourceFileSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `InitializerClauseSyntax` nodes conform. Extension point to add
/// common methods to all `InitializerClauseSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol InitializerClauseSyntaxProtocol: SyntaxProtocol {}


public struct InitializerClauseSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case equal
    case value
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `InitializerClauseSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .initializerClause else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `InitializerClauseSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .initializerClause)
    self._syntaxNode = Syntax(data)
  }

  public var equal: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.equal, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withEqual(value)
    }
  }

  /// Returns a copy of the receiver with its `equal` replaced.
  /// - param newChild: The new `equal` to replace the node's
  ///                   current `equal`, if present.
  public func withEqual(
    _ newChild: TokenSyntax?) -> InitializerClauseSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.equal)
    let newData = data.replacingChild(raw, at: Cursor.equal)
    return InitializerClauseSyntax(newData)
  }
  public var value: ExprSyntax {
    get {
      let childData = data.child(at: Cursor.value, 
                                 parent: Syntax(self))
      return ExprSyntax(childData!)
    }
    set(value) {
      self = withValue(value)
    }
  }

  /// Returns a copy of the receiver with its `value` replaced.
  /// - param newChild: The new `value` to replace the node's
  ///                   current `value`, if present.
  public func withValue(
    _ newChild: ExprSyntax?) -> InitializerClauseSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.expr)
    let newData = data.replacingChild(raw, at: Cursor.value)
    return InitializerClauseSyntax(newData)
  }

  /// Returns a new `InitializerClauseSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> InitializerClauseSyntax {
    return InitializerClauseSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `InitializerClauseSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> InitializerClauseSyntax {
    return InitializerClauseSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `InitializerClauseSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> InitializerClauseSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `InitializerClauseSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> InitializerClauseSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `InitializerClauseSyntax` with all trivia removed.
  public func withoutTrivia() -> InitializerClauseSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `InitializerClauseSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `InitializerClauseSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `FunctionParameterSyntax` nodes conform. Extension point to add
/// common methods to all `FunctionParameterSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol FunctionParameterSyntaxProtocol: SyntaxProtocol {}


public struct FunctionParameterSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case attributes
    case firstName
    case secondName
    case colon
    case type
    case ellipsis
    case defaultArgument
    case trailingComma
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `FunctionParameterSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .functionParameter else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `FunctionParameterSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .functionParameter)
    self._syntaxNode = Syntax(data)
  }

  public var attributes: AttributeListSyntax? {
    get {
      let childData = data.child(at: Cursor.attributes, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return AttributeListSyntax(childData!)
    }
    set(value) {
      self = withAttributes(value)
    }
  }

  /// Adds the provided `Attribute` to the node's `attributes`
  /// collection.
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  public func addAttribute(_ element: Syntax) -> FunctionParameterSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.attributes] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.attributeList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.attributes)
    return FunctionParameterSyntax(newData)
  }

  /// Returns a copy of the receiver with its `attributes` replaced.
  /// - param newChild: The new `attributes` to replace the node's
  ///                   current `attributes`, if present.
  public func withAttributes(
    _ newChild: AttributeListSyntax?) -> FunctionParameterSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.attributes)
    return FunctionParameterSyntax(newData)
  }
  public var firstName: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.firstName, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withFirstName(value)
    }
  }

  /// Returns a copy of the receiver with its `firstName` replaced.
  /// - param newChild: The new `firstName` to replace the node's
  ///                   current `firstName`, if present.
  public func withFirstName(
    _ newChild: TokenSyntax?) -> FunctionParameterSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.firstName)
    return FunctionParameterSyntax(newData)
  }
  public var secondName: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.secondName, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withSecondName(value)
    }
  }

  /// Returns a copy of the receiver with its `secondName` replaced.
  /// - param newChild: The new `secondName` to replace the node's
  ///                   current `secondName`, if present.
  public func withSecondName(
    _ newChild: TokenSyntax?) -> FunctionParameterSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.secondName)
    return FunctionParameterSyntax(newData)
  }
  public var colon: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.colon, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withColon(value)
    }
  }

  /// Returns a copy of the receiver with its `colon` replaced.
  /// - param newChild: The new `colon` to replace the node's
  ///                   current `colon`, if present.
  public func withColon(
    _ newChild: TokenSyntax?) -> FunctionParameterSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.colon)
    return FunctionParameterSyntax(newData)
  }
  public var type: TypeSyntax? {
    get {
      let childData = data.child(at: Cursor.type, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TypeSyntax(childData!)
    }
    set(value) {
      self = withType(value)
    }
  }

  /// Returns a copy of the receiver with its `type` replaced.
  /// - param newChild: The new `type` to replace the node's
  ///                   current `type`, if present.
  public func withType(
    _ newChild: TypeSyntax?) -> FunctionParameterSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.type)
    return FunctionParameterSyntax(newData)
  }
  public var ellipsis: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.ellipsis, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withEllipsis(value)
    }
  }

  /// Returns a copy of the receiver with its `ellipsis` replaced.
  /// - param newChild: The new `ellipsis` to replace the node's
  ///                   current `ellipsis`, if present.
  public func withEllipsis(
    _ newChild: TokenSyntax?) -> FunctionParameterSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.ellipsis)
    return FunctionParameterSyntax(newData)
  }
  public var defaultArgument: InitializerClauseSyntax? {
    get {
      let childData = data.child(at: Cursor.defaultArgument, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return InitializerClauseSyntax(childData!)
    }
    set(value) {
      self = withDefaultArgument(value)
    }
  }

  /// Returns a copy of the receiver with its `defaultArgument` replaced.
  /// - param newChild: The new `defaultArgument` to replace the node's
  ///                   current `defaultArgument`, if present.
  public func withDefaultArgument(
    _ newChild: InitializerClauseSyntax?) -> FunctionParameterSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.defaultArgument)
    return FunctionParameterSyntax(newData)
  }
  public var trailingComma: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.trailingComma, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withTrailingComma(value)
    }
  }

  /// Returns a copy of the receiver with its `trailingComma` replaced.
  /// - param newChild: The new `trailingComma` to replace the node's
  ///                   current `trailingComma`, if present.
  public func withTrailingComma(
    _ newChild: TokenSyntax?) -> FunctionParameterSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.trailingComma)
    return FunctionParameterSyntax(newData)
  }

  /// Returns a new `FunctionParameterSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> FunctionParameterSyntax {
    return FunctionParameterSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `FunctionParameterSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> FunctionParameterSyntax {
    return FunctionParameterSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `FunctionParameterSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> FunctionParameterSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `FunctionParameterSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> FunctionParameterSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `FunctionParameterSyntax` with all trivia removed.
  public func withoutTrivia() -> FunctionParameterSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `FunctionParameterSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `FunctionParameterSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `ModifierListSyntax` nodes conform. Extension point to add
/// common methods to all `ModifierListSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol ModifierListSyntaxProtocol: SyntaxProtocol {}

/// Protocol to which all `FunctionDeclSyntax` nodes conform. Extension point to add
/// common methods to all `FunctionDeclSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol FunctionDeclSyntaxProtocol: DeclSyntaxProtocol {}


public struct FunctionDeclSyntax: DeclSyntaxProtocol {
  enum Cursor: Int {
    case attributes
    case modifiers
    case funcKeyword
    case identifier
    case genericParameterClause
    case signature
    case genericWhereClause
    case body
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `FunctionDeclSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .functionDecl else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `FunctionDeclSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .functionDecl)
    self._syntaxNode = Syntax(data)
  }

  public var attributes: AttributeListSyntax? {
    get {
      let childData = data.child(at: Cursor.attributes, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return AttributeListSyntax(childData!)
    }
    set(value) {
      self = withAttributes(value)
    }
  }

  /// Adds the provided `Attribute` to the node's `attributes`
  /// collection.
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  public func addAttribute(_ element: Syntax) -> FunctionDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.attributes] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.attributeList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.attributes)
    return FunctionDeclSyntax(newData)
  }

  /// Returns a copy of the receiver with its `attributes` replaced.
  /// - param newChild: The new `attributes` to replace the node's
  ///                   current `attributes`, if present.
  public func withAttributes(
    _ newChild: AttributeListSyntax?) -> FunctionDeclSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.attributes)
    return FunctionDeclSyntax(newData)
  }
  public var modifiers: ModifierListSyntax? {
    get {
      let childData = data.child(at: Cursor.modifiers, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return ModifierListSyntax(childData!)
    }
    set(value) {
      self = withModifiers(value)
    }
  }

  /// Adds the provided `Modifier` to the node's `modifiers`
  /// collection.
  /// - param element: The new `Modifier` to add to the node's
  ///                  `modifiers` collection.
  /// - returns: A copy of the receiver with the provided `Modifier`
  ///            appended to its `modifiers` collection.
  public func addModifier(_ element: DeclModifierSyntax) -> FunctionDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.modifiers] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.modifierList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.modifiers)
    return FunctionDeclSyntax(newData)
  }

  /// Returns a copy of the receiver with its `modifiers` replaced.
  /// - param newChild: The new `modifiers` to replace the node's
  ///                   current `modifiers`, if present.
  public func withModifiers(
    _ newChild: ModifierListSyntax?) -> FunctionDeclSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.modifiers)
    return FunctionDeclSyntax(newData)
  }
  public var funcKeyword: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.funcKeyword, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withFuncKeyword(value)
    }
  }

  /// Returns a copy of the receiver with its `funcKeyword` replaced.
  /// - param newChild: The new `funcKeyword` to replace the node's
  ///                   current `funcKeyword`, if present.
  public func withFuncKeyword(
    _ newChild: TokenSyntax?) -> FunctionDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.funcKeyword)
    let newData = data.replacingChild(raw, at: Cursor.funcKeyword)
    return FunctionDeclSyntax(newData)
  }
  public var identifier: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.identifier, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withIdentifier(value)
    }
  }

  /// Returns a copy of the receiver with its `identifier` replaced.
  /// - param newChild: The new `identifier` to replace the node's
  ///                   current `identifier`, if present.
  public func withIdentifier(
    _ newChild: TokenSyntax?) -> FunctionDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let newData = data.replacingChild(raw, at: Cursor.identifier)
    return FunctionDeclSyntax(newData)
  }
  public var genericParameterClause: GenericParameterClauseSyntax? {
    get {
      let childData = data.child(at: Cursor.genericParameterClause, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return GenericParameterClauseSyntax(childData!)
    }
    set(value) {
      self = withGenericParameterClause(value)
    }
  }

  /// Returns a copy of the receiver with its `genericParameterClause` replaced.
  /// - param newChild: The new `genericParameterClause` to replace the node's
  ///                   current `genericParameterClause`, if present.
  public func withGenericParameterClause(
    _ newChild: GenericParameterClauseSyntax?) -> FunctionDeclSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.genericParameterClause)
    return FunctionDeclSyntax(newData)
  }
  public var signature: FunctionSignatureSyntax {
    get {
      let childData = data.child(at: Cursor.signature, 
                                 parent: Syntax(self))
      return FunctionSignatureSyntax(childData!)
    }
    set(value) {
      self = withSignature(value)
    }
  }

  /// Returns a copy of the receiver with its `signature` replaced.
  /// - param newChild: The new `signature` to replace the node's
  ///                   current `signature`, if present.
  public func withSignature(
    _ newChild: FunctionSignatureSyntax?) -> FunctionDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.functionSignature)
    let newData = data.replacingChild(raw, at: Cursor.signature)
    return FunctionDeclSyntax(newData)
  }
  public var genericWhereClause: GenericWhereClauseSyntax? {
    get {
      let childData = data.child(at: Cursor.genericWhereClause, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return GenericWhereClauseSyntax(childData!)
    }
    set(value) {
      self = withGenericWhereClause(value)
    }
  }

  /// Returns a copy of the receiver with its `genericWhereClause` replaced.
  /// - param newChild: The new `genericWhereClause` to replace the node's
  ///                   current `genericWhereClause`, if present.
  public func withGenericWhereClause(
    _ newChild: GenericWhereClauseSyntax?) -> FunctionDeclSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.genericWhereClause)
    return FunctionDeclSyntax(newData)
  }
  public var body: CodeBlockSyntax? {
    get {
      let childData = data.child(at: Cursor.body, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return CodeBlockSyntax(childData!)
    }
    set(value) {
      self = withBody(value)
    }
  }

  /// Returns a copy of the receiver with its `body` replaced.
  /// - param newChild: The new `body` to replace the node's
  ///                   current `body`, if present.
  public func withBody(
    _ newChild: CodeBlockSyntax?) -> FunctionDeclSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.body)
    return FunctionDeclSyntax(newData)
  }

  /// Returns a new `FunctionDeclSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> FunctionDeclSyntax {
    return FunctionDeclSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `FunctionDeclSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> FunctionDeclSyntax {
    return FunctionDeclSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `FunctionDeclSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> FunctionDeclSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `FunctionDeclSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> FunctionDeclSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `FunctionDeclSyntax` with all trivia removed.
  public func withoutTrivia() -> FunctionDeclSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `FunctionDeclSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `FunctionDeclSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `InitializerDeclSyntax` nodes conform. Extension point to add
/// common methods to all `InitializerDeclSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol InitializerDeclSyntaxProtocol: DeclSyntaxProtocol {}


public struct InitializerDeclSyntax: DeclSyntaxProtocol {
  enum Cursor: Int {
    case attributes
    case modifiers
    case initKeyword
    case optionalMark
    case genericParameterClause
    case parameters
    case throwsOrRethrowsKeyword
    case genericWhereClause
    case body
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `InitializerDeclSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .initializerDecl else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `InitializerDeclSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .initializerDecl)
    self._syntaxNode = Syntax(data)
  }

  public var attributes: AttributeListSyntax? {
    get {
      let childData = data.child(at: Cursor.attributes, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return AttributeListSyntax(childData!)
    }
    set(value) {
      self = withAttributes(value)
    }
  }

  /// Adds the provided `Attribute` to the node's `attributes`
  /// collection.
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  public func addAttribute(_ element: Syntax) -> InitializerDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.attributes] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.attributeList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.attributes)
    return InitializerDeclSyntax(newData)
  }

  /// Returns a copy of the receiver with its `attributes` replaced.
  /// - param newChild: The new `attributes` to replace the node's
  ///                   current `attributes`, if present.
  public func withAttributes(
    _ newChild: AttributeListSyntax?) -> InitializerDeclSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.attributes)
    return InitializerDeclSyntax(newData)
  }
  public var modifiers: ModifierListSyntax? {
    get {
      let childData = data.child(at: Cursor.modifiers, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return ModifierListSyntax(childData!)
    }
    set(value) {
      self = withModifiers(value)
    }
  }

  /// Adds the provided `Modifier` to the node's `modifiers`
  /// collection.
  /// - param element: The new `Modifier` to add to the node's
  ///                  `modifiers` collection.
  /// - returns: A copy of the receiver with the provided `Modifier`
  ///            appended to its `modifiers` collection.
  public func addModifier(_ element: DeclModifierSyntax) -> InitializerDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.modifiers] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.modifierList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.modifiers)
    return InitializerDeclSyntax(newData)
  }

  /// Returns a copy of the receiver with its `modifiers` replaced.
  /// - param newChild: The new `modifiers` to replace the node's
  ///                   current `modifiers`, if present.
  public func withModifiers(
    _ newChild: ModifierListSyntax?) -> InitializerDeclSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.modifiers)
    return InitializerDeclSyntax(newData)
  }
  public var initKeyword: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.initKeyword, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withInitKeyword(value)
    }
  }

  /// Returns a copy of the receiver with its `initKeyword` replaced.
  /// - param newChild: The new `initKeyword` to replace the node's
  ///                   current `initKeyword`, if present.
  public func withInitKeyword(
    _ newChild: TokenSyntax?) -> InitializerDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.initKeyword)
    let newData = data.replacingChild(raw, at: Cursor.initKeyword)
    return InitializerDeclSyntax(newData)
  }
  public var optionalMark: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.optionalMark, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withOptionalMark(value)
    }
  }

  /// Returns a copy of the receiver with its `optionalMark` replaced.
  /// - param newChild: The new `optionalMark` to replace the node's
  ///                   current `optionalMark`, if present.
  public func withOptionalMark(
    _ newChild: TokenSyntax?) -> InitializerDeclSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.optionalMark)
    return InitializerDeclSyntax(newData)
  }
  public var genericParameterClause: GenericParameterClauseSyntax? {
    get {
      let childData = data.child(at: Cursor.genericParameterClause, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return GenericParameterClauseSyntax(childData!)
    }
    set(value) {
      self = withGenericParameterClause(value)
    }
  }

  /// Returns a copy of the receiver with its `genericParameterClause` replaced.
  /// - param newChild: The new `genericParameterClause` to replace the node's
  ///                   current `genericParameterClause`, if present.
  public func withGenericParameterClause(
    _ newChild: GenericParameterClauseSyntax?) -> InitializerDeclSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.genericParameterClause)
    return InitializerDeclSyntax(newData)
  }
  public var parameters: ParameterClauseSyntax {
    get {
      let childData = data.child(at: Cursor.parameters, 
                                 parent: Syntax(self))
      return ParameterClauseSyntax(childData!)
    }
    set(value) {
      self = withParameters(value)
    }
  }

  /// Returns a copy of the receiver with its `parameters` replaced.
  /// - param newChild: The new `parameters` to replace the node's
  ///                   current `parameters`, if present.
  public func withParameters(
    _ newChild: ParameterClauseSyntax?) -> InitializerDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.parameterClause)
    let newData = data.replacingChild(raw, at: Cursor.parameters)
    return InitializerDeclSyntax(newData)
  }
  public var throwsOrRethrowsKeyword: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.throwsOrRethrowsKeyword, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withThrowsOrRethrowsKeyword(value)
    }
  }

  /// Returns a copy of the receiver with its `throwsOrRethrowsKeyword` replaced.
  /// - param newChild: The new `throwsOrRethrowsKeyword` to replace the node's
  ///                   current `throwsOrRethrowsKeyword`, if present.
  public func withThrowsOrRethrowsKeyword(
    _ newChild: TokenSyntax?) -> InitializerDeclSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.throwsOrRethrowsKeyword)
    return InitializerDeclSyntax(newData)
  }
  public var genericWhereClause: GenericWhereClauseSyntax? {
    get {
      let childData = data.child(at: Cursor.genericWhereClause, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return GenericWhereClauseSyntax(childData!)
    }
    set(value) {
      self = withGenericWhereClause(value)
    }
  }

  /// Returns a copy of the receiver with its `genericWhereClause` replaced.
  /// - param newChild: The new `genericWhereClause` to replace the node's
  ///                   current `genericWhereClause`, if present.
  public func withGenericWhereClause(
    _ newChild: GenericWhereClauseSyntax?) -> InitializerDeclSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.genericWhereClause)
    return InitializerDeclSyntax(newData)
  }
  public var body: CodeBlockSyntax? {
    get {
      let childData = data.child(at: Cursor.body, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return CodeBlockSyntax(childData!)
    }
    set(value) {
      self = withBody(value)
    }
  }

  /// Returns a copy of the receiver with its `body` replaced.
  /// - param newChild: The new `body` to replace the node's
  ///                   current `body`, if present.
  public func withBody(
    _ newChild: CodeBlockSyntax?) -> InitializerDeclSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.body)
    return InitializerDeclSyntax(newData)
  }

  /// Returns a new `InitializerDeclSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> InitializerDeclSyntax {
    return InitializerDeclSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `InitializerDeclSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> InitializerDeclSyntax {
    return InitializerDeclSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `InitializerDeclSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> InitializerDeclSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `InitializerDeclSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> InitializerDeclSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `InitializerDeclSyntax` with all trivia removed.
  public func withoutTrivia() -> InitializerDeclSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `InitializerDeclSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `InitializerDeclSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `DeinitializerDeclSyntax` nodes conform. Extension point to add
/// common methods to all `DeinitializerDeclSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol DeinitializerDeclSyntaxProtocol: DeclSyntaxProtocol {}


public struct DeinitializerDeclSyntax: DeclSyntaxProtocol {
  enum Cursor: Int {
    case attributes
    case modifiers
    case deinitKeyword
    case body
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `DeinitializerDeclSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .deinitializerDecl else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `DeinitializerDeclSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .deinitializerDecl)
    self._syntaxNode = Syntax(data)
  }

  public var attributes: AttributeListSyntax? {
    get {
      let childData = data.child(at: Cursor.attributes, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return AttributeListSyntax(childData!)
    }
    set(value) {
      self = withAttributes(value)
    }
  }

  /// Adds the provided `Attribute` to the node's `attributes`
  /// collection.
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  public func addAttribute(_ element: Syntax) -> DeinitializerDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.attributes] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.attributeList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.attributes)
    return DeinitializerDeclSyntax(newData)
  }

  /// Returns a copy of the receiver with its `attributes` replaced.
  /// - param newChild: The new `attributes` to replace the node's
  ///                   current `attributes`, if present.
  public func withAttributes(
    _ newChild: AttributeListSyntax?) -> DeinitializerDeclSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.attributes)
    return DeinitializerDeclSyntax(newData)
  }
  public var modifiers: ModifierListSyntax? {
    get {
      let childData = data.child(at: Cursor.modifiers, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return ModifierListSyntax(childData!)
    }
    set(value) {
      self = withModifiers(value)
    }
  }

  /// Adds the provided `Modifier` to the node's `modifiers`
  /// collection.
  /// - param element: The new `Modifier` to add to the node's
  ///                  `modifiers` collection.
  /// - returns: A copy of the receiver with the provided `Modifier`
  ///            appended to its `modifiers` collection.
  public func addModifier(_ element: DeclModifierSyntax) -> DeinitializerDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.modifiers] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.modifierList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.modifiers)
    return DeinitializerDeclSyntax(newData)
  }

  /// Returns a copy of the receiver with its `modifiers` replaced.
  /// - param newChild: The new `modifiers` to replace the node's
  ///                   current `modifiers`, if present.
  public func withModifiers(
    _ newChild: ModifierListSyntax?) -> DeinitializerDeclSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.modifiers)
    return DeinitializerDeclSyntax(newData)
  }
  public var deinitKeyword: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.deinitKeyword, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withDeinitKeyword(value)
    }
  }

  /// Returns a copy of the receiver with its `deinitKeyword` replaced.
  /// - param newChild: The new `deinitKeyword` to replace the node's
  ///                   current `deinitKeyword`, if present.
  public func withDeinitKeyword(
    _ newChild: TokenSyntax?) -> DeinitializerDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.deinitKeyword)
    let newData = data.replacingChild(raw, at: Cursor.deinitKeyword)
    return DeinitializerDeclSyntax(newData)
  }
  public var body: CodeBlockSyntax {
    get {
      let childData = data.child(at: Cursor.body, 
                                 parent: Syntax(self))
      return CodeBlockSyntax(childData!)
    }
    set(value) {
      self = withBody(value)
    }
  }

  /// Returns a copy of the receiver with its `body` replaced.
  /// - param newChild: The new `body` to replace the node's
  ///                   current `body`, if present.
  public func withBody(
    _ newChild: CodeBlockSyntax?) -> DeinitializerDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.codeBlock)
    let newData = data.replacingChild(raw, at: Cursor.body)
    return DeinitializerDeclSyntax(newData)
  }

  /// Returns a new `DeinitializerDeclSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> DeinitializerDeclSyntax {
    return DeinitializerDeclSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `DeinitializerDeclSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> DeinitializerDeclSyntax {
    return DeinitializerDeclSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `DeinitializerDeclSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> DeinitializerDeclSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `DeinitializerDeclSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> DeinitializerDeclSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `DeinitializerDeclSyntax` with all trivia removed.
  public func withoutTrivia() -> DeinitializerDeclSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `DeinitializerDeclSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `DeinitializerDeclSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `SubscriptDeclSyntax` nodes conform. Extension point to add
/// common methods to all `SubscriptDeclSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol SubscriptDeclSyntaxProtocol: DeclSyntaxProtocol {}


public struct SubscriptDeclSyntax: DeclSyntaxProtocol {
  enum Cursor: Int {
    case attributes
    case modifiers
    case subscriptKeyword
    case genericParameterClause
    case indices
    case result
    case genericWhereClause
    case accessor
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `SubscriptDeclSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .subscriptDecl else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `SubscriptDeclSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .subscriptDecl)
    self._syntaxNode = Syntax(data)
  }

  public var attributes: AttributeListSyntax? {
    get {
      let childData = data.child(at: Cursor.attributes, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return AttributeListSyntax(childData!)
    }
    set(value) {
      self = withAttributes(value)
    }
  }

  /// Adds the provided `Attribute` to the node's `attributes`
  /// collection.
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  public func addAttribute(_ element: Syntax) -> SubscriptDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.attributes] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.attributeList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.attributes)
    return SubscriptDeclSyntax(newData)
  }

  /// Returns a copy of the receiver with its `attributes` replaced.
  /// - param newChild: The new `attributes` to replace the node's
  ///                   current `attributes`, if present.
  public func withAttributes(
    _ newChild: AttributeListSyntax?) -> SubscriptDeclSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.attributes)
    return SubscriptDeclSyntax(newData)
  }
  public var modifiers: ModifierListSyntax? {
    get {
      let childData = data.child(at: Cursor.modifiers, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return ModifierListSyntax(childData!)
    }
    set(value) {
      self = withModifiers(value)
    }
  }

  /// Adds the provided `Modifier` to the node's `modifiers`
  /// collection.
  /// - param element: The new `Modifier` to add to the node's
  ///                  `modifiers` collection.
  /// - returns: A copy of the receiver with the provided `Modifier`
  ///            appended to its `modifiers` collection.
  public func addModifier(_ element: DeclModifierSyntax) -> SubscriptDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.modifiers] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.modifierList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.modifiers)
    return SubscriptDeclSyntax(newData)
  }

  /// Returns a copy of the receiver with its `modifiers` replaced.
  /// - param newChild: The new `modifiers` to replace the node's
  ///                   current `modifiers`, if present.
  public func withModifiers(
    _ newChild: ModifierListSyntax?) -> SubscriptDeclSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.modifiers)
    return SubscriptDeclSyntax(newData)
  }
  public var subscriptKeyword: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.subscriptKeyword, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withSubscriptKeyword(value)
    }
  }

  /// Returns a copy of the receiver with its `subscriptKeyword` replaced.
  /// - param newChild: The new `subscriptKeyword` to replace the node's
  ///                   current `subscriptKeyword`, if present.
  public func withSubscriptKeyword(
    _ newChild: TokenSyntax?) -> SubscriptDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.subscriptKeyword)
    let newData = data.replacingChild(raw, at: Cursor.subscriptKeyword)
    return SubscriptDeclSyntax(newData)
  }
  public var genericParameterClause: GenericParameterClauseSyntax? {
    get {
      let childData = data.child(at: Cursor.genericParameterClause, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return GenericParameterClauseSyntax(childData!)
    }
    set(value) {
      self = withGenericParameterClause(value)
    }
  }

  /// Returns a copy of the receiver with its `genericParameterClause` replaced.
  /// - param newChild: The new `genericParameterClause` to replace the node's
  ///                   current `genericParameterClause`, if present.
  public func withGenericParameterClause(
    _ newChild: GenericParameterClauseSyntax?) -> SubscriptDeclSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.genericParameterClause)
    return SubscriptDeclSyntax(newData)
  }
  public var indices: ParameterClauseSyntax {
    get {
      let childData = data.child(at: Cursor.indices, 
                                 parent: Syntax(self))
      return ParameterClauseSyntax(childData!)
    }
    set(value) {
      self = withIndices(value)
    }
  }

  /// Returns a copy of the receiver with its `indices` replaced.
  /// - param newChild: The new `indices` to replace the node's
  ///                   current `indices`, if present.
  public func withIndices(
    _ newChild: ParameterClauseSyntax?) -> SubscriptDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.parameterClause)
    let newData = data.replacingChild(raw, at: Cursor.indices)
    return SubscriptDeclSyntax(newData)
  }
  public var result: ReturnClauseSyntax {
    get {
      let childData = data.child(at: Cursor.result, 
                                 parent: Syntax(self))
      return ReturnClauseSyntax(childData!)
    }
    set(value) {
      self = withResult(value)
    }
  }

  /// Returns a copy of the receiver with its `result` replaced.
  /// - param newChild: The new `result` to replace the node's
  ///                   current `result`, if present.
  public func withResult(
    _ newChild: ReturnClauseSyntax?) -> SubscriptDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.returnClause)
    let newData = data.replacingChild(raw, at: Cursor.result)
    return SubscriptDeclSyntax(newData)
  }
  public var genericWhereClause: GenericWhereClauseSyntax? {
    get {
      let childData = data.child(at: Cursor.genericWhereClause, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return GenericWhereClauseSyntax(childData!)
    }
    set(value) {
      self = withGenericWhereClause(value)
    }
  }

  /// Returns a copy of the receiver with its `genericWhereClause` replaced.
  /// - param newChild: The new `genericWhereClause` to replace the node's
  ///                   current `genericWhereClause`, if present.
  public func withGenericWhereClause(
    _ newChild: GenericWhereClauseSyntax?) -> SubscriptDeclSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.genericWhereClause)
    return SubscriptDeclSyntax(newData)
  }
  public var accessor: Syntax? {
    get {
      let childData = data.child(at: Cursor.accessor, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return Syntax(childData!)
    }
    set(value) {
      self = withAccessor(value)
    }
  }

  /// Returns a copy of the receiver with its `accessor` replaced.
  /// - param newChild: The new `accessor` to replace the node's
  ///                   current `accessor`, if present.
  public func withAccessor(
    _ newChild: Syntax?) -> SubscriptDeclSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.accessor)
    return SubscriptDeclSyntax(newData)
  }

  /// Returns a new `SubscriptDeclSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> SubscriptDeclSyntax {
    return SubscriptDeclSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `SubscriptDeclSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> SubscriptDeclSyntax {
    return SubscriptDeclSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `SubscriptDeclSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> SubscriptDeclSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `SubscriptDeclSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> SubscriptDeclSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `SubscriptDeclSyntax` with all trivia removed.
  public func withoutTrivia() -> SubscriptDeclSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `SubscriptDeclSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `SubscriptDeclSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `AccessLevelModifierSyntax` nodes conform. Extension point to add
/// common methods to all `AccessLevelModifierSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol AccessLevelModifierSyntaxProtocol: SyntaxProtocol {}


public struct AccessLevelModifierSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case name
    case leftParen
    case modifier
    case rightParen
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `AccessLevelModifierSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .accessLevelModifier else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `AccessLevelModifierSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .accessLevelModifier)
    self._syntaxNode = Syntax(data)
  }

  public var name: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.name, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withName(value)
    }
  }

  /// Returns a copy of the receiver with its `name` replaced.
  /// - param newChild: The new `name` to replace the node's
  ///                   current `name`, if present.
  public func withName(
    _ newChild: TokenSyntax?) -> AccessLevelModifierSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let newData = data.replacingChild(raw, at: Cursor.name)
    return AccessLevelModifierSyntax(newData)
  }
  public var leftParen: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.leftParen, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withLeftParen(value)
    }
  }

  /// Returns a copy of the receiver with its `leftParen` replaced.
  /// - param newChild: The new `leftParen` to replace the node's
  ///                   current `leftParen`, if present.
  public func withLeftParen(
    _ newChild: TokenSyntax?) -> AccessLevelModifierSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.leftParen)
    return AccessLevelModifierSyntax(newData)
  }
  public var modifier: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.modifier, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withModifier(value)
    }
  }

  /// Returns a copy of the receiver with its `modifier` replaced.
  /// - param newChild: The new `modifier` to replace the node's
  ///                   current `modifier`, if present.
  public func withModifier(
    _ newChild: TokenSyntax?) -> AccessLevelModifierSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.modifier)
    return AccessLevelModifierSyntax(newData)
  }
  public var rightParen: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.rightParen, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withRightParen(value)
    }
  }

  /// Returns a copy of the receiver with its `rightParen` replaced.
  /// - param newChild: The new `rightParen` to replace the node's
  ///                   current `rightParen`, if present.
  public func withRightParen(
    _ newChild: TokenSyntax?) -> AccessLevelModifierSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.rightParen)
    return AccessLevelModifierSyntax(newData)
  }

  /// Returns a new `AccessLevelModifierSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> AccessLevelModifierSyntax {
    return AccessLevelModifierSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `AccessLevelModifierSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> AccessLevelModifierSyntax {
    return AccessLevelModifierSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `AccessLevelModifierSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> AccessLevelModifierSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `AccessLevelModifierSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> AccessLevelModifierSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `AccessLevelModifierSyntax` with all trivia removed.
  public func withoutTrivia() -> AccessLevelModifierSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `AccessLevelModifierSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `AccessLevelModifierSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `AccessPathComponentSyntax` nodes conform. Extension point to add
/// common methods to all `AccessPathComponentSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol AccessPathComponentSyntaxProtocol: SyntaxProtocol {}


public struct AccessPathComponentSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case name
    case trailingDot
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `AccessPathComponentSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .accessPathComponent else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `AccessPathComponentSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .accessPathComponent)
    self._syntaxNode = Syntax(data)
  }

  public var name: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.name, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withName(value)
    }
  }

  /// Returns a copy of the receiver with its `name` replaced.
  /// - param newChild: The new `name` to replace the node's
  ///                   current `name`, if present.
  public func withName(
    _ newChild: TokenSyntax?) -> AccessPathComponentSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let newData = data.replacingChild(raw, at: Cursor.name)
    return AccessPathComponentSyntax(newData)
  }
  public var trailingDot: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.trailingDot, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withTrailingDot(value)
    }
  }

  /// Returns a copy of the receiver with its `trailingDot` replaced.
  /// - param newChild: The new `trailingDot` to replace the node's
  ///                   current `trailingDot`, if present.
  public func withTrailingDot(
    _ newChild: TokenSyntax?) -> AccessPathComponentSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.trailingDot)
    return AccessPathComponentSyntax(newData)
  }

  /// Returns a new `AccessPathComponentSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> AccessPathComponentSyntax {
    return AccessPathComponentSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `AccessPathComponentSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> AccessPathComponentSyntax {
    return AccessPathComponentSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `AccessPathComponentSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> AccessPathComponentSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `AccessPathComponentSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> AccessPathComponentSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `AccessPathComponentSyntax` with all trivia removed.
  public func withoutTrivia() -> AccessPathComponentSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `AccessPathComponentSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `AccessPathComponentSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `AccessPathSyntax` nodes conform. Extension point to add
/// common methods to all `AccessPathSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol AccessPathSyntaxProtocol: SyntaxProtocol {}

/// Protocol to which all `ImportDeclSyntax` nodes conform. Extension point to add
/// common methods to all `ImportDeclSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol ImportDeclSyntaxProtocol: DeclSyntaxProtocol {}


public struct ImportDeclSyntax: DeclSyntaxProtocol {
  enum Cursor: Int {
    case attributes
    case modifiers
    case importTok
    case importKind
    case path
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `ImportDeclSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .importDecl else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `ImportDeclSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .importDecl)
    self._syntaxNode = Syntax(data)
  }

  public var attributes: AttributeListSyntax? {
    get {
      let childData = data.child(at: Cursor.attributes, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return AttributeListSyntax(childData!)
    }
    set(value) {
      self = withAttributes(value)
    }
  }

  /// Adds the provided `Attribute` to the node's `attributes`
  /// collection.
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  public func addAttribute(_ element: Syntax) -> ImportDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.attributes] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.attributeList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.attributes)
    return ImportDeclSyntax(newData)
  }

  /// Returns a copy of the receiver with its `attributes` replaced.
  /// - param newChild: The new `attributes` to replace the node's
  ///                   current `attributes`, if present.
  public func withAttributes(
    _ newChild: AttributeListSyntax?) -> ImportDeclSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.attributes)
    return ImportDeclSyntax(newData)
  }
  public var modifiers: ModifierListSyntax? {
    get {
      let childData = data.child(at: Cursor.modifiers, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return ModifierListSyntax(childData!)
    }
    set(value) {
      self = withModifiers(value)
    }
  }

  /// Adds the provided `Modifier` to the node's `modifiers`
  /// collection.
  /// - param element: The new `Modifier` to add to the node's
  ///                  `modifiers` collection.
  /// - returns: A copy of the receiver with the provided `Modifier`
  ///            appended to its `modifiers` collection.
  public func addModifier(_ element: DeclModifierSyntax) -> ImportDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.modifiers] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.modifierList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.modifiers)
    return ImportDeclSyntax(newData)
  }

  /// Returns a copy of the receiver with its `modifiers` replaced.
  /// - param newChild: The new `modifiers` to replace the node's
  ///                   current `modifiers`, if present.
  public func withModifiers(
    _ newChild: ModifierListSyntax?) -> ImportDeclSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.modifiers)
    return ImportDeclSyntax(newData)
  }
  public var importTok: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.importTok, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withImportTok(value)
    }
  }

  /// Returns a copy of the receiver with its `importTok` replaced.
  /// - param newChild: The new `importTok` to replace the node's
  ///                   current `importTok`, if present.
  public func withImportTok(
    _ newChild: TokenSyntax?) -> ImportDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.importKeyword)
    let newData = data.replacingChild(raw, at: Cursor.importTok)
    return ImportDeclSyntax(newData)
  }
  public var importKind: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.importKind, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withImportKind(value)
    }
  }

  /// Returns a copy of the receiver with its `importKind` replaced.
  /// - param newChild: The new `importKind` to replace the node's
  ///                   current `importKind`, if present.
  public func withImportKind(
    _ newChild: TokenSyntax?) -> ImportDeclSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.importKind)
    return ImportDeclSyntax(newData)
  }
  public var path: AccessPathSyntax {
    get {
      let childData = data.child(at: Cursor.path, 
                                 parent: Syntax(self))
      return AccessPathSyntax(childData!)
    }
    set(value) {
      self = withPath(value)
    }
  }

  /// Adds the provided `PathComponent` to the node's `path`
  /// collection.
  /// - param element: The new `PathComponent` to add to the node's
  ///                  `path` collection.
  /// - returns: A copy of the receiver with the provided `PathComponent`
  ///            appended to its `path` collection.
  public func addPathComponent(_ element: AccessPathComponentSyntax) -> ImportDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.path] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.accessPath,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.path)
    return ImportDeclSyntax(newData)
  }

  /// Returns a copy of the receiver with its `path` replaced.
  /// - param newChild: The new `path` to replace the node's
  ///                   current `path`, if present.
  public func withPath(
    _ newChild: AccessPathSyntax?) -> ImportDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.accessPath)
    let newData = data.replacingChild(raw, at: Cursor.path)
    return ImportDeclSyntax(newData)
  }

  /// Returns a new `ImportDeclSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> ImportDeclSyntax {
    return ImportDeclSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `ImportDeclSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> ImportDeclSyntax {
    return ImportDeclSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `ImportDeclSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> ImportDeclSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `ImportDeclSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> ImportDeclSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `ImportDeclSyntax` with all trivia removed.
  public func withoutTrivia() -> ImportDeclSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `ImportDeclSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `ImportDeclSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `AccessorParameterSyntax` nodes conform. Extension point to add
/// common methods to all `AccessorParameterSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol AccessorParameterSyntaxProtocol: SyntaxProtocol {}


public struct AccessorParameterSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case leftParen
    case name
    case rightParen
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `AccessorParameterSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .accessorParameter else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `AccessorParameterSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .accessorParameter)
    self._syntaxNode = Syntax(data)
  }

  public var leftParen: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.leftParen, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withLeftParen(value)
    }
  }

  /// Returns a copy of the receiver with its `leftParen` replaced.
  /// - param newChild: The new `leftParen` to replace the node's
  ///                   current `leftParen`, if present.
  public func withLeftParen(
    _ newChild: TokenSyntax?) -> AccessorParameterSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.leftParen)
    let newData = data.replacingChild(raw, at: Cursor.leftParen)
    return AccessorParameterSyntax(newData)
  }
  public var name: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.name, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withName(value)
    }
  }

  /// Returns a copy of the receiver with its `name` replaced.
  /// - param newChild: The new `name` to replace the node's
  ///                   current `name`, if present.
  public func withName(
    _ newChild: TokenSyntax?) -> AccessorParameterSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let newData = data.replacingChild(raw, at: Cursor.name)
    return AccessorParameterSyntax(newData)
  }
  public var rightParen: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.rightParen, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withRightParen(value)
    }
  }

  /// Returns a copy of the receiver with its `rightParen` replaced.
  /// - param newChild: The new `rightParen` to replace the node's
  ///                   current `rightParen`, if present.
  public func withRightParen(
    _ newChild: TokenSyntax?) -> AccessorParameterSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.rightParen)
    let newData = data.replacingChild(raw, at: Cursor.rightParen)
    return AccessorParameterSyntax(newData)
  }

  /// Returns a new `AccessorParameterSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> AccessorParameterSyntax {
    return AccessorParameterSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `AccessorParameterSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> AccessorParameterSyntax {
    return AccessorParameterSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `AccessorParameterSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> AccessorParameterSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `AccessorParameterSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> AccessorParameterSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `AccessorParameterSyntax` with all trivia removed.
  public func withoutTrivia() -> AccessorParameterSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `AccessorParameterSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `AccessorParameterSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `AccessorDeclSyntax` nodes conform. Extension point to add
/// common methods to all `AccessorDeclSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol AccessorDeclSyntaxProtocol: DeclSyntaxProtocol {}


public struct AccessorDeclSyntax: DeclSyntaxProtocol {
  enum Cursor: Int {
    case attributes
    case modifier
    case accessorKind
    case parameter
    case body
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `AccessorDeclSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .accessorDecl else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `AccessorDeclSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .accessorDecl)
    self._syntaxNode = Syntax(data)
  }

  public var attributes: AttributeListSyntax? {
    get {
      let childData = data.child(at: Cursor.attributes, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return AttributeListSyntax(childData!)
    }
    set(value) {
      self = withAttributes(value)
    }
  }

  /// Adds the provided `Attribute` to the node's `attributes`
  /// collection.
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  public func addAttribute(_ element: Syntax) -> AccessorDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.attributes] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.attributeList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.attributes)
    return AccessorDeclSyntax(newData)
  }

  /// Returns a copy of the receiver with its `attributes` replaced.
  /// - param newChild: The new `attributes` to replace the node's
  ///                   current `attributes`, if present.
  public func withAttributes(
    _ newChild: AttributeListSyntax?) -> AccessorDeclSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.attributes)
    return AccessorDeclSyntax(newData)
  }
  public var modifier: DeclModifierSyntax? {
    get {
      let childData = data.child(at: Cursor.modifier, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return DeclModifierSyntax(childData!)
    }
    set(value) {
      self = withModifier(value)
    }
  }

  /// Returns a copy of the receiver with its `modifier` replaced.
  /// - param newChild: The new `modifier` to replace the node's
  ///                   current `modifier`, if present.
  public func withModifier(
    _ newChild: DeclModifierSyntax?) -> AccessorDeclSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.modifier)
    return AccessorDeclSyntax(newData)
  }
  public var accessorKind: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.accessorKind, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withAccessorKind(value)
    }
  }

  /// Returns a copy of the receiver with its `accessorKind` replaced.
  /// - param newChild: The new `accessorKind` to replace the node's
  ///                   current `accessorKind`, if present.
  public func withAccessorKind(
    _ newChild: TokenSyntax?) -> AccessorDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.unknown(""))
    let newData = data.replacingChild(raw, at: Cursor.accessorKind)
    return AccessorDeclSyntax(newData)
  }
  public var parameter: AccessorParameterSyntax? {
    get {
      let childData = data.child(at: Cursor.parameter, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return AccessorParameterSyntax(childData!)
    }
    set(value) {
      self = withParameter(value)
    }
  }

  /// Returns a copy of the receiver with its `parameter` replaced.
  /// - param newChild: The new `parameter` to replace the node's
  ///                   current `parameter`, if present.
  public func withParameter(
    _ newChild: AccessorParameterSyntax?) -> AccessorDeclSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.parameter)
    return AccessorDeclSyntax(newData)
  }
  public var body: CodeBlockSyntax? {
    get {
      let childData = data.child(at: Cursor.body, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return CodeBlockSyntax(childData!)
    }
    set(value) {
      self = withBody(value)
    }
  }

  /// Returns a copy of the receiver with its `body` replaced.
  /// - param newChild: The new `body` to replace the node's
  ///                   current `body`, if present.
  public func withBody(
    _ newChild: CodeBlockSyntax?) -> AccessorDeclSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.body)
    return AccessorDeclSyntax(newData)
  }

  /// Returns a new `AccessorDeclSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> AccessorDeclSyntax {
    return AccessorDeclSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `AccessorDeclSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> AccessorDeclSyntax {
    return AccessorDeclSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `AccessorDeclSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> AccessorDeclSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `AccessorDeclSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> AccessorDeclSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `AccessorDeclSyntax` with all trivia removed.
  public func withoutTrivia() -> AccessorDeclSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `AccessorDeclSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `AccessorDeclSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `AccessorListSyntax` nodes conform. Extension point to add
/// common methods to all `AccessorListSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol AccessorListSyntaxProtocol: SyntaxProtocol {}

/// Protocol to which all `AccessorBlockSyntax` nodes conform. Extension point to add
/// common methods to all `AccessorBlockSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol AccessorBlockSyntaxProtocol: SyntaxProtocol {}


public struct AccessorBlockSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case leftBrace
    case accessors
    case rightBrace
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `AccessorBlockSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .accessorBlock else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `AccessorBlockSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .accessorBlock)
    self._syntaxNode = Syntax(data)
  }

  public var leftBrace: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.leftBrace, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withLeftBrace(value)
    }
  }

  /// Returns a copy of the receiver with its `leftBrace` replaced.
  /// - param newChild: The new `leftBrace` to replace the node's
  ///                   current `leftBrace`, if present.
  public func withLeftBrace(
    _ newChild: TokenSyntax?) -> AccessorBlockSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.leftBrace)
    let newData = data.replacingChild(raw, at: Cursor.leftBrace)
    return AccessorBlockSyntax(newData)
  }
  public var accessors: AccessorListSyntax {
    get {
      let childData = data.child(at: Cursor.accessors, 
                                 parent: Syntax(self))
      return AccessorListSyntax(childData!)
    }
    set(value) {
      self = withAccessors(value)
    }
  }

  /// Adds the provided `Accessor` to the node's `accessors`
  /// collection.
  /// - param element: The new `Accessor` to add to the node's
  ///                  `accessors` collection.
  /// - returns: A copy of the receiver with the provided `Accessor`
  ///            appended to its `accessors` collection.
  public func addAccessor(_ element: AccessorDeclSyntax) -> AccessorBlockSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.accessors] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.accessorList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.accessors)
    return AccessorBlockSyntax(newData)
  }

  /// Returns a copy of the receiver with its `accessors` replaced.
  /// - param newChild: The new `accessors` to replace the node's
  ///                   current `accessors`, if present.
  public func withAccessors(
    _ newChild: AccessorListSyntax?) -> AccessorBlockSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.accessorList)
    let newData = data.replacingChild(raw, at: Cursor.accessors)
    return AccessorBlockSyntax(newData)
  }
  public var rightBrace: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.rightBrace, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withRightBrace(value)
    }
  }

  /// Returns a copy of the receiver with its `rightBrace` replaced.
  /// - param newChild: The new `rightBrace` to replace the node's
  ///                   current `rightBrace`, if present.
  public func withRightBrace(
    _ newChild: TokenSyntax?) -> AccessorBlockSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.rightBrace)
    let newData = data.replacingChild(raw, at: Cursor.rightBrace)
    return AccessorBlockSyntax(newData)
  }

  /// Returns a new `AccessorBlockSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> AccessorBlockSyntax {
    return AccessorBlockSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `AccessorBlockSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> AccessorBlockSyntax {
    return AccessorBlockSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `AccessorBlockSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> AccessorBlockSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `AccessorBlockSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> AccessorBlockSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `AccessorBlockSyntax` with all trivia removed.
  public func withoutTrivia() -> AccessorBlockSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `AccessorBlockSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `AccessorBlockSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `PatternBindingSyntax` nodes conform. Extension point to add
/// common methods to all `PatternBindingSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol PatternBindingSyntaxProtocol: SyntaxProtocol {}


public struct PatternBindingSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case pattern
    case typeAnnotation
    case initializer
    case accessor
    case trailingComma
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `PatternBindingSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .patternBinding else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `PatternBindingSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .patternBinding)
    self._syntaxNode = Syntax(data)
  }

  public var pattern: PatternSyntax {
    get {
      let childData = data.child(at: Cursor.pattern, 
                                 parent: Syntax(self))
      return PatternSyntax(childData!)
    }
    set(value) {
      self = withPattern(value)
    }
  }

  /// Returns a copy of the receiver with its `pattern` replaced.
  /// - param newChild: The new `pattern` to replace the node's
  ///                   current `pattern`, if present.
  public func withPattern(
    _ newChild: PatternSyntax?) -> PatternBindingSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.pattern)
    let newData = data.replacingChild(raw, at: Cursor.pattern)
    return PatternBindingSyntax(newData)
  }
  public var typeAnnotation: TypeAnnotationSyntax? {
    get {
      let childData = data.child(at: Cursor.typeAnnotation, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TypeAnnotationSyntax(childData!)
    }
    set(value) {
      self = withTypeAnnotation(value)
    }
  }

  /// Returns a copy of the receiver with its `typeAnnotation` replaced.
  /// - param newChild: The new `typeAnnotation` to replace the node's
  ///                   current `typeAnnotation`, if present.
  public func withTypeAnnotation(
    _ newChild: TypeAnnotationSyntax?) -> PatternBindingSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.typeAnnotation)
    return PatternBindingSyntax(newData)
  }
  public var initializer: InitializerClauseSyntax? {
    get {
      let childData = data.child(at: Cursor.initializer, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return InitializerClauseSyntax(childData!)
    }
    set(value) {
      self = withInitializer(value)
    }
  }

  /// Returns a copy of the receiver with its `initializer` replaced.
  /// - param newChild: The new `initializer` to replace the node's
  ///                   current `initializer`, if present.
  public func withInitializer(
    _ newChild: InitializerClauseSyntax?) -> PatternBindingSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.initializer)
    return PatternBindingSyntax(newData)
  }
  public var accessor: Syntax? {
    get {
      let childData = data.child(at: Cursor.accessor, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return Syntax(childData!)
    }
    set(value) {
      self = withAccessor(value)
    }
  }

  /// Returns a copy of the receiver with its `accessor` replaced.
  /// - param newChild: The new `accessor` to replace the node's
  ///                   current `accessor`, if present.
  public func withAccessor(
    _ newChild: Syntax?) -> PatternBindingSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.accessor)
    return PatternBindingSyntax(newData)
  }
  public var trailingComma: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.trailingComma, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withTrailingComma(value)
    }
  }

  /// Returns a copy of the receiver with its `trailingComma` replaced.
  /// - param newChild: The new `trailingComma` to replace the node's
  ///                   current `trailingComma`, if present.
  public func withTrailingComma(
    _ newChild: TokenSyntax?) -> PatternBindingSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.trailingComma)
    return PatternBindingSyntax(newData)
  }

  /// Returns a new `PatternBindingSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> PatternBindingSyntax {
    return PatternBindingSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `PatternBindingSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> PatternBindingSyntax {
    return PatternBindingSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `PatternBindingSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> PatternBindingSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `PatternBindingSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> PatternBindingSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `PatternBindingSyntax` with all trivia removed.
  public func withoutTrivia() -> PatternBindingSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `PatternBindingSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `PatternBindingSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `PatternBindingListSyntax` nodes conform. Extension point to add
/// common methods to all `PatternBindingListSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol PatternBindingListSyntaxProtocol: SyntaxProtocol {}

/// Protocol to which all `VariableDeclSyntax` nodes conform. Extension point to add
/// common methods to all `VariableDeclSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol VariableDeclSyntaxProtocol: DeclSyntaxProtocol {}


public struct VariableDeclSyntax: DeclSyntaxProtocol {
  enum Cursor: Int {
    case attributes
    case modifiers
    case letOrVarKeyword
    case bindings
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `VariableDeclSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .variableDecl else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `VariableDeclSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .variableDecl)
    self._syntaxNode = Syntax(data)
  }

  public var attributes: AttributeListSyntax? {
    get {
      let childData = data.child(at: Cursor.attributes, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return AttributeListSyntax(childData!)
    }
    set(value) {
      self = withAttributes(value)
    }
  }

  /// Adds the provided `Attribute` to the node's `attributes`
  /// collection.
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  public func addAttribute(_ element: Syntax) -> VariableDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.attributes] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.attributeList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.attributes)
    return VariableDeclSyntax(newData)
  }

  /// Returns a copy of the receiver with its `attributes` replaced.
  /// - param newChild: The new `attributes` to replace the node's
  ///                   current `attributes`, if present.
  public func withAttributes(
    _ newChild: AttributeListSyntax?) -> VariableDeclSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.attributes)
    return VariableDeclSyntax(newData)
  }
  public var modifiers: ModifierListSyntax? {
    get {
      let childData = data.child(at: Cursor.modifiers, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return ModifierListSyntax(childData!)
    }
    set(value) {
      self = withModifiers(value)
    }
  }

  /// Adds the provided `Modifier` to the node's `modifiers`
  /// collection.
  /// - param element: The new `Modifier` to add to the node's
  ///                  `modifiers` collection.
  /// - returns: A copy of the receiver with the provided `Modifier`
  ///            appended to its `modifiers` collection.
  public func addModifier(_ element: DeclModifierSyntax) -> VariableDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.modifiers] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.modifierList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.modifiers)
    return VariableDeclSyntax(newData)
  }

  /// Returns a copy of the receiver with its `modifiers` replaced.
  /// - param newChild: The new `modifiers` to replace the node's
  ///                   current `modifiers`, if present.
  public func withModifiers(
    _ newChild: ModifierListSyntax?) -> VariableDeclSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.modifiers)
    return VariableDeclSyntax(newData)
  }
  public var letOrVarKeyword: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.letOrVarKeyword, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withLetOrVarKeyword(value)
    }
  }

  /// Returns a copy of the receiver with its `letOrVarKeyword` replaced.
  /// - param newChild: The new `letOrVarKeyword` to replace the node's
  ///                   current `letOrVarKeyword`, if present.
  public func withLetOrVarKeyword(
    _ newChild: TokenSyntax?) -> VariableDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.letKeyword)
    let newData = data.replacingChild(raw, at: Cursor.letOrVarKeyword)
    return VariableDeclSyntax(newData)
  }
  public var bindings: PatternBindingListSyntax {
    get {
      let childData = data.child(at: Cursor.bindings, 
                                 parent: Syntax(self))
      return PatternBindingListSyntax(childData!)
    }
    set(value) {
      self = withBindings(value)
    }
  }

  /// Adds the provided `Binding` to the node's `bindings`
  /// collection.
  /// - param element: The new `Binding` to add to the node's
  ///                  `bindings` collection.
  /// - returns: A copy of the receiver with the provided `Binding`
  ///            appended to its `bindings` collection.
  public func addBinding(_ element: PatternBindingSyntax) -> VariableDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.bindings] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.patternBindingList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.bindings)
    return VariableDeclSyntax(newData)
  }

  /// Returns a copy of the receiver with its `bindings` replaced.
  /// - param newChild: The new `bindings` to replace the node's
  ///                   current `bindings`, if present.
  public func withBindings(
    _ newChild: PatternBindingListSyntax?) -> VariableDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.patternBindingList)
    let newData = data.replacingChild(raw, at: Cursor.bindings)
    return VariableDeclSyntax(newData)
  }

  /// Returns a new `VariableDeclSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> VariableDeclSyntax {
    return VariableDeclSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `VariableDeclSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> VariableDeclSyntax {
    return VariableDeclSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `VariableDeclSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> VariableDeclSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `VariableDeclSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> VariableDeclSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `VariableDeclSyntax` with all trivia removed.
  public func withoutTrivia() -> VariableDeclSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `VariableDeclSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `VariableDeclSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `EnumCaseElementSyntax` nodes conform. Extension point to add
/// common methods to all `EnumCaseElementSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol EnumCaseElementSyntaxProtocol: SyntaxProtocol {}


/// 
/// An element of an enum case, containing the name of the case and,          optionally, either associated values or an assignment to a raw value.
/// 
public struct EnumCaseElementSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case identifier
    case associatedValue
    case rawValue
    case trailingComma
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `EnumCaseElementSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .enumCaseElement else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `EnumCaseElementSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .enumCaseElement)
    self._syntaxNode = Syntax(data)
  }

  /// The name of this case.
  public var identifier: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.identifier, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withIdentifier(value)
    }
  }

  /// Returns a copy of the receiver with its `identifier` replaced.
  /// - param newChild: The new `identifier` to replace the node's
  ///                   current `identifier`, if present.
  public func withIdentifier(
    _ newChild: TokenSyntax?) -> EnumCaseElementSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let newData = data.replacingChild(raw, at: Cursor.identifier)
    return EnumCaseElementSyntax(newData)
  }
  /// The set of associated values of the case.
  public var associatedValue: ParameterClauseSyntax? {
    get {
      let childData = data.child(at: Cursor.associatedValue, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return ParameterClauseSyntax(childData!)
    }
    set(value) {
      self = withAssociatedValue(value)
    }
  }

  /// Returns a copy of the receiver with its `associatedValue` replaced.
  /// - param newChild: The new `associatedValue` to replace the node's
  ///                   current `associatedValue`, if present.
  public func withAssociatedValue(
    _ newChild: ParameterClauseSyntax?) -> EnumCaseElementSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.associatedValue)
    return EnumCaseElementSyntax(newData)
  }
  /// 
  /// The raw value of this enum element, if present.
  /// 
  public var rawValue: InitializerClauseSyntax? {
    get {
      let childData = data.child(at: Cursor.rawValue, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return InitializerClauseSyntax(childData!)
    }
    set(value) {
      self = withRawValue(value)
    }
  }

  /// Returns a copy of the receiver with its `rawValue` replaced.
  /// - param newChild: The new `rawValue` to replace the node's
  ///                   current `rawValue`, if present.
  public func withRawValue(
    _ newChild: InitializerClauseSyntax?) -> EnumCaseElementSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.rawValue)
    return EnumCaseElementSyntax(newData)
  }
  /// 
  /// The trailing comma of this element, if the case has                    multiple elements.
  /// 
  public var trailingComma: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.trailingComma, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withTrailingComma(value)
    }
  }

  /// Returns a copy of the receiver with its `trailingComma` replaced.
  /// - param newChild: The new `trailingComma` to replace the node's
  ///                   current `trailingComma`, if present.
  public func withTrailingComma(
    _ newChild: TokenSyntax?) -> EnumCaseElementSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.trailingComma)
    return EnumCaseElementSyntax(newData)
  }

  /// Returns a new `EnumCaseElementSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> EnumCaseElementSyntax {
    return EnumCaseElementSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `EnumCaseElementSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> EnumCaseElementSyntax {
    return EnumCaseElementSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `EnumCaseElementSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> EnumCaseElementSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `EnumCaseElementSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> EnumCaseElementSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `EnumCaseElementSyntax` with all trivia removed.
  public func withoutTrivia() -> EnumCaseElementSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `EnumCaseElementSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `EnumCaseElementSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `EnumCaseElementListSyntax` nodes conform. Extension point to add
/// common methods to all `EnumCaseElementListSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol EnumCaseElementListSyntaxProtocol: SyntaxProtocol {}

/// Protocol to which all `EnumCaseDeclSyntax` nodes conform. Extension point to add
/// common methods to all `EnumCaseDeclSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol EnumCaseDeclSyntaxProtocol: DeclSyntaxProtocol {}


/// 
/// A `case` declaration of a Swift `enum`. It can have 1 or more          `EnumCaseElement`s inside, each declaring a different case of the
/// enum.
/// 
public struct EnumCaseDeclSyntax: DeclSyntaxProtocol {
  enum Cursor: Int {
    case attributes
    case modifiers
    case caseKeyword
    case elements
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `EnumCaseDeclSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .enumCaseDecl else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `EnumCaseDeclSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .enumCaseDecl)
    self._syntaxNode = Syntax(data)
  }

  /// 
  /// The attributes applied to the case declaration.
  /// 
  public var attributes: AttributeListSyntax? {
    get {
      let childData = data.child(at: Cursor.attributes, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return AttributeListSyntax(childData!)
    }
    set(value) {
      self = withAttributes(value)
    }
  }

  /// Adds the provided `Attribute` to the node's `attributes`
  /// collection.
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  public func addAttribute(_ element: Syntax) -> EnumCaseDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.attributes] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.attributeList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.attributes)
    return EnumCaseDeclSyntax(newData)
  }

  /// Returns a copy of the receiver with its `attributes` replaced.
  /// - param newChild: The new `attributes` to replace the node's
  ///                   current `attributes`, if present.
  public func withAttributes(
    _ newChild: AttributeListSyntax?) -> EnumCaseDeclSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.attributes)
    return EnumCaseDeclSyntax(newData)
  }
  /// 
  /// The declaration modifiers applied to the case declaration.
  /// 
  public var modifiers: ModifierListSyntax? {
    get {
      let childData = data.child(at: Cursor.modifiers, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return ModifierListSyntax(childData!)
    }
    set(value) {
      self = withModifiers(value)
    }
  }

  /// Adds the provided `Modifier` to the node's `modifiers`
  /// collection.
  /// - param element: The new `Modifier` to add to the node's
  ///                  `modifiers` collection.
  /// - returns: A copy of the receiver with the provided `Modifier`
  ///            appended to its `modifiers` collection.
  public func addModifier(_ element: DeclModifierSyntax) -> EnumCaseDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.modifiers] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.modifierList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.modifiers)
    return EnumCaseDeclSyntax(newData)
  }

  /// Returns a copy of the receiver with its `modifiers` replaced.
  /// - param newChild: The new `modifiers` to replace the node's
  ///                   current `modifiers`, if present.
  public func withModifiers(
    _ newChild: ModifierListSyntax?) -> EnumCaseDeclSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.modifiers)
    return EnumCaseDeclSyntax(newData)
  }
  /// The `case` keyword for this case.
  public var caseKeyword: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.caseKeyword, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withCaseKeyword(value)
    }
  }

  /// Returns a copy of the receiver with its `caseKeyword` replaced.
  /// - param newChild: The new `caseKeyword` to replace the node's
  ///                   current `caseKeyword`, if present.
  public func withCaseKeyword(
    _ newChild: TokenSyntax?) -> EnumCaseDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.caseKeyword)
    let newData = data.replacingChild(raw, at: Cursor.caseKeyword)
    return EnumCaseDeclSyntax(newData)
  }
  /// The elements this case declares.
  public var elements: EnumCaseElementListSyntax {
    get {
      let childData = data.child(at: Cursor.elements, 
                                 parent: Syntax(self))
      return EnumCaseElementListSyntax(childData!)
    }
    set(value) {
      self = withElements(value)
    }
  }

  /// Adds the provided `Element` to the node's `elements`
  /// collection.
  /// - param element: The new `Element` to add to the node's
  ///                  `elements` collection.
  /// - returns: A copy of the receiver with the provided `Element`
  ///            appended to its `elements` collection.
  public func addElement(_ element: EnumCaseElementSyntax) -> EnumCaseDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.elements] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.enumCaseElementList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.elements)
    return EnumCaseDeclSyntax(newData)
  }

  /// Returns a copy of the receiver with its `elements` replaced.
  /// - param newChild: The new `elements` to replace the node's
  ///                   current `elements`, if present.
  public func withElements(
    _ newChild: EnumCaseElementListSyntax?) -> EnumCaseDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.enumCaseElementList)
    let newData = data.replacingChild(raw, at: Cursor.elements)
    return EnumCaseDeclSyntax(newData)
  }

  /// Returns a new `EnumCaseDeclSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> EnumCaseDeclSyntax {
    return EnumCaseDeclSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `EnumCaseDeclSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> EnumCaseDeclSyntax {
    return EnumCaseDeclSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `EnumCaseDeclSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> EnumCaseDeclSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `EnumCaseDeclSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> EnumCaseDeclSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `EnumCaseDeclSyntax` with all trivia removed.
  public func withoutTrivia() -> EnumCaseDeclSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `EnumCaseDeclSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `EnumCaseDeclSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `EnumDeclSyntax` nodes conform. Extension point to add
/// common methods to all `EnumDeclSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol EnumDeclSyntaxProtocol: DeclSyntaxProtocol {}


/// A Swift `enum` declaration.
public struct EnumDeclSyntax: DeclSyntaxProtocol {
  enum Cursor: Int {
    case attributes
    case modifiers
    case enumKeyword
    case identifier
    case genericParameters
    case inheritanceClause
    case genericWhereClause
    case members
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `EnumDeclSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .enumDecl else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `EnumDeclSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .enumDecl)
    self._syntaxNode = Syntax(data)
  }

  /// 
  /// The attributes applied to the enum declaration.
  /// 
  public var attributes: AttributeListSyntax? {
    get {
      let childData = data.child(at: Cursor.attributes, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return AttributeListSyntax(childData!)
    }
    set(value) {
      self = withAttributes(value)
    }
  }

  /// Adds the provided `Attribute` to the node's `attributes`
  /// collection.
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  public func addAttribute(_ element: Syntax) -> EnumDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.attributes] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.attributeList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.attributes)
    return EnumDeclSyntax(newData)
  }

  /// Returns a copy of the receiver with its `attributes` replaced.
  /// - param newChild: The new `attributes` to replace the node's
  ///                   current `attributes`, if present.
  public func withAttributes(
    _ newChild: AttributeListSyntax?) -> EnumDeclSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.attributes)
    return EnumDeclSyntax(newData)
  }
  /// 
  /// The declaration modifiers applied to the enum declaration.
  /// 
  public var modifiers: ModifierListSyntax? {
    get {
      let childData = data.child(at: Cursor.modifiers, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return ModifierListSyntax(childData!)
    }
    set(value) {
      self = withModifiers(value)
    }
  }

  /// Adds the provided `Modifier` to the node's `modifiers`
  /// collection.
  /// - param element: The new `Modifier` to add to the node's
  ///                  `modifiers` collection.
  /// - returns: A copy of the receiver with the provided `Modifier`
  ///            appended to its `modifiers` collection.
  public func addModifier(_ element: DeclModifierSyntax) -> EnumDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.modifiers] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.modifierList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.modifiers)
    return EnumDeclSyntax(newData)
  }

  /// Returns a copy of the receiver with its `modifiers` replaced.
  /// - param newChild: The new `modifiers` to replace the node's
  ///                   current `modifiers`, if present.
  public func withModifiers(
    _ newChild: ModifierListSyntax?) -> EnumDeclSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.modifiers)
    return EnumDeclSyntax(newData)
  }
  /// 
  /// The `enum` keyword for this declaration.
  /// 
  public var enumKeyword: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.enumKeyword, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withEnumKeyword(value)
    }
  }

  /// Returns a copy of the receiver with its `enumKeyword` replaced.
  /// - param newChild: The new `enumKeyword` to replace the node's
  ///                   current `enumKeyword`, if present.
  public func withEnumKeyword(
    _ newChild: TokenSyntax?) -> EnumDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.enumKeyword)
    let newData = data.replacingChild(raw, at: Cursor.enumKeyword)
    return EnumDeclSyntax(newData)
  }
  /// 
  /// The name of this enum.
  /// 
  public var identifier: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.identifier, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withIdentifier(value)
    }
  }

  /// Returns a copy of the receiver with its `identifier` replaced.
  /// - param newChild: The new `identifier` to replace the node's
  ///                   current `identifier`, if present.
  public func withIdentifier(
    _ newChild: TokenSyntax?) -> EnumDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let newData = data.replacingChild(raw, at: Cursor.identifier)
    return EnumDeclSyntax(newData)
  }
  /// 
  /// The generic parameters, if any, for this enum.
  /// 
  public var genericParameters: GenericParameterClauseSyntax? {
    get {
      let childData = data.child(at: Cursor.genericParameters, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return GenericParameterClauseSyntax(childData!)
    }
    set(value) {
      self = withGenericParameters(value)
    }
  }

  /// Returns a copy of the receiver with its `genericParameters` replaced.
  /// - param newChild: The new `genericParameters` to replace the node's
  ///                   current `genericParameters`, if present.
  public func withGenericParameters(
    _ newChild: GenericParameterClauseSyntax?) -> EnumDeclSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.genericParameters)
    return EnumDeclSyntax(newData)
  }
  /// 
  /// The inheritance clause describing conformances or raw                    values for this enum.
  /// 
  public var inheritanceClause: TypeInheritanceClauseSyntax? {
    get {
      let childData = data.child(at: Cursor.inheritanceClause, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TypeInheritanceClauseSyntax(childData!)
    }
    set(value) {
      self = withInheritanceClause(value)
    }
  }

  /// Returns a copy of the receiver with its `inheritanceClause` replaced.
  /// - param newChild: The new `inheritanceClause` to replace the node's
  ///                   current `inheritanceClause`, if present.
  public func withInheritanceClause(
    _ newChild: TypeInheritanceClauseSyntax?) -> EnumDeclSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.inheritanceClause)
    return EnumDeclSyntax(newData)
  }
  /// 
  /// The `where` clause that applies to the generic parameters of                    this enum.
  /// 
  public var genericWhereClause: GenericWhereClauseSyntax? {
    get {
      let childData = data.child(at: Cursor.genericWhereClause, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return GenericWhereClauseSyntax(childData!)
    }
    set(value) {
      self = withGenericWhereClause(value)
    }
  }

  /// Returns a copy of the receiver with its `genericWhereClause` replaced.
  /// - param newChild: The new `genericWhereClause` to replace the node's
  ///                   current `genericWhereClause`, if present.
  public func withGenericWhereClause(
    _ newChild: GenericWhereClauseSyntax?) -> EnumDeclSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.genericWhereClause)
    return EnumDeclSyntax(newData)
  }
  /// 
  /// The cases and other members of this enum.
  /// 
  public var members: MemberDeclBlockSyntax {
    get {
      let childData = data.child(at: Cursor.members, 
                                 parent: Syntax(self))
      return MemberDeclBlockSyntax(childData!)
    }
    set(value) {
      self = withMembers(value)
    }
  }

  /// Returns a copy of the receiver with its `members` replaced.
  /// - param newChild: The new `members` to replace the node's
  ///                   current `members`, if present.
  public func withMembers(
    _ newChild: MemberDeclBlockSyntax?) -> EnumDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.memberDeclBlock)
    let newData = data.replacingChild(raw, at: Cursor.members)
    return EnumDeclSyntax(newData)
  }

  /// Returns a new `EnumDeclSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> EnumDeclSyntax {
    return EnumDeclSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `EnumDeclSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> EnumDeclSyntax {
    return EnumDeclSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `EnumDeclSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> EnumDeclSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `EnumDeclSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> EnumDeclSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `EnumDeclSyntax` with all trivia removed.
  public func withoutTrivia() -> EnumDeclSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `EnumDeclSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `EnumDeclSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `OperatorDeclSyntax` nodes conform. Extension point to add
/// common methods to all `OperatorDeclSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol OperatorDeclSyntaxProtocol: DeclSyntaxProtocol {}


/// A Swift `operator` declaration.
public struct OperatorDeclSyntax: DeclSyntaxProtocol {
  enum Cursor: Int {
    case attributes
    case modifiers
    case operatorKeyword
    case identifier
    case operatorPrecedenceAndTypes
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `OperatorDeclSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .operatorDecl else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `OperatorDeclSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .operatorDecl)
    self._syntaxNode = Syntax(data)
  }

  /// 
  /// The attributes applied to the 'operator' declaration.
  /// 
  public var attributes: AttributeListSyntax? {
    get {
      let childData = data.child(at: Cursor.attributes, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return AttributeListSyntax(childData!)
    }
    set(value) {
      self = withAttributes(value)
    }
  }

  /// Adds the provided `Attribute` to the node's `attributes`
  /// collection.
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  public func addAttribute(_ element: Syntax) -> OperatorDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.attributes] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.attributeList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.attributes)
    return OperatorDeclSyntax(newData)
  }

  /// Returns a copy of the receiver with its `attributes` replaced.
  /// - param newChild: The new `attributes` to replace the node's
  ///                   current `attributes`, if present.
  public func withAttributes(
    _ newChild: AttributeListSyntax?) -> OperatorDeclSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.attributes)
    return OperatorDeclSyntax(newData)
  }
  /// 
  /// The declaration modifiers applied to the 'operator'
  /// declaration.
  /// 
  public var modifiers: ModifierListSyntax? {
    get {
      let childData = data.child(at: Cursor.modifiers, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return ModifierListSyntax(childData!)
    }
    set(value) {
      self = withModifiers(value)
    }
  }

  /// Adds the provided `Modifier` to the node's `modifiers`
  /// collection.
  /// - param element: The new `Modifier` to add to the node's
  ///                  `modifiers` collection.
  /// - returns: A copy of the receiver with the provided `Modifier`
  ///            appended to its `modifiers` collection.
  public func addModifier(_ element: DeclModifierSyntax) -> OperatorDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.modifiers] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.modifierList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.modifiers)
    return OperatorDeclSyntax(newData)
  }

  /// Returns a copy of the receiver with its `modifiers` replaced.
  /// - param newChild: The new `modifiers` to replace the node's
  ///                   current `modifiers`, if present.
  public func withModifiers(
    _ newChild: ModifierListSyntax?) -> OperatorDeclSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.modifiers)
    return OperatorDeclSyntax(newData)
  }
  public var operatorKeyword: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.operatorKeyword, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withOperatorKeyword(value)
    }
  }

  /// Returns a copy of the receiver with its `operatorKeyword` replaced.
  /// - param newChild: The new `operatorKeyword` to replace the node's
  ///                   current `operatorKeyword`, if present.
  public func withOperatorKeyword(
    _ newChild: TokenSyntax?) -> OperatorDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.operatorKeyword)
    let newData = data.replacingChild(raw, at: Cursor.operatorKeyword)
    return OperatorDeclSyntax(newData)
  }
  public var identifier: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.identifier, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withIdentifier(value)
    }
  }

  /// Returns a copy of the receiver with its `identifier` replaced.
  /// - param newChild: The new `identifier` to replace the node's
  ///                   current `identifier`, if present.
  public func withIdentifier(
    _ newChild: TokenSyntax?) -> OperatorDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.unspacedBinaryOperator(""))
    let newData = data.replacingChild(raw, at: Cursor.identifier)
    return OperatorDeclSyntax(newData)
  }
  /// 
  /// Optionally specify a precedence group and designated types.
  /// 
  public var operatorPrecedenceAndTypes: OperatorPrecedenceAndTypesSyntax? {
    get {
      let childData = data.child(at: Cursor.operatorPrecedenceAndTypes, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return OperatorPrecedenceAndTypesSyntax(childData!)
    }
    set(value) {
      self = withOperatorPrecedenceAndTypes(value)
    }
  }

  /// Returns a copy of the receiver with its `operatorPrecedenceAndTypes` replaced.
  /// - param newChild: The new `operatorPrecedenceAndTypes` to replace the node's
  ///                   current `operatorPrecedenceAndTypes`, if present.
  public func withOperatorPrecedenceAndTypes(
    _ newChild: OperatorPrecedenceAndTypesSyntax?) -> OperatorDeclSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.operatorPrecedenceAndTypes)
    return OperatorDeclSyntax(newData)
  }

  /// Returns a new `OperatorDeclSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> OperatorDeclSyntax {
    return OperatorDeclSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `OperatorDeclSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> OperatorDeclSyntax {
    return OperatorDeclSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `OperatorDeclSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> OperatorDeclSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `OperatorDeclSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> OperatorDeclSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `OperatorDeclSyntax` with all trivia removed.
  public func withoutTrivia() -> OperatorDeclSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `OperatorDeclSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `OperatorDeclSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `IdentifierListSyntax` nodes conform. Extension point to add
/// common methods to all `IdentifierListSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol IdentifierListSyntaxProtocol: SyntaxProtocol {}

/// Protocol to which all `OperatorPrecedenceAndTypesSyntax` nodes conform. Extension point to add
/// common methods to all `OperatorPrecedenceAndTypesSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol OperatorPrecedenceAndTypesSyntaxProtocol: SyntaxProtocol {}


/// 
/// A clause to specify precedence group in infix operator declarations, and designated types in any operator declaration.
/// 
public struct OperatorPrecedenceAndTypesSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case colon
    case precedenceGroupAndDesignatedTypes
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `OperatorPrecedenceAndTypesSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .operatorPrecedenceAndTypes else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `OperatorPrecedenceAndTypesSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .operatorPrecedenceAndTypes)
    self._syntaxNode = Syntax(data)
  }

  public var colon: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.colon, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withColon(value)
    }
  }

  /// Returns a copy of the receiver with its `colon` replaced.
  /// - param newChild: The new `colon` to replace the node's
  ///                   current `colon`, if present.
  public func withColon(
    _ newChild: TokenSyntax?) -> OperatorPrecedenceAndTypesSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.colon)
    let newData = data.replacingChild(raw, at: Cursor.colon)
    return OperatorPrecedenceAndTypesSyntax(newData)
  }
  /// 
  /// The precedence group and designated types for this operator
  /// 
  public var precedenceGroupAndDesignatedTypes: IdentifierListSyntax {
    get {
      let childData = data.child(at: Cursor.precedenceGroupAndDesignatedTypes, 
                                 parent: Syntax(self))
      return IdentifierListSyntax(childData!)
    }
    set(value) {
      self = withPrecedenceGroupAndDesignatedTypes(value)
    }
  }

  /// Adds the provided `PrecedenceGroupAndDesignatedType` to the node's `precedenceGroupAndDesignatedTypes`
  /// collection.
  /// - param element: The new `PrecedenceGroupAndDesignatedType` to add to the node's
  ///                  `precedenceGroupAndDesignatedTypes` collection.
  /// - returns: A copy of the receiver with the provided `PrecedenceGroupAndDesignatedType`
  ///            appended to its `precedenceGroupAndDesignatedTypes` collection.
  public func addPrecedenceGroupAndDesignatedType(_ element: TokenSyntax) -> OperatorPrecedenceAndTypesSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.precedenceGroupAndDesignatedTypes] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.identifierList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.precedenceGroupAndDesignatedTypes)
    return OperatorPrecedenceAndTypesSyntax(newData)
  }

  /// Returns a copy of the receiver with its `precedenceGroupAndDesignatedTypes` replaced.
  /// - param newChild: The new `precedenceGroupAndDesignatedTypes` to replace the node's
  ///                   current `precedenceGroupAndDesignatedTypes`, if present.
  public func withPrecedenceGroupAndDesignatedTypes(
    _ newChild: IdentifierListSyntax?) -> OperatorPrecedenceAndTypesSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.identifierList)
    let newData = data.replacingChild(raw, at: Cursor.precedenceGroupAndDesignatedTypes)
    return OperatorPrecedenceAndTypesSyntax(newData)
  }

  /// Returns a new `OperatorPrecedenceAndTypesSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> OperatorPrecedenceAndTypesSyntax {
    return OperatorPrecedenceAndTypesSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `OperatorPrecedenceAndTypesSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> OperatorPrecedenceAndTypesSyntax {
    return OperatorPrecedenceAndTypesSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `OperatorPrecedenceAndTypesSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> OperatorPrecedenceAndTypesSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `OperatorPrecedenceAndTypesSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> OperatorPrecedenceAndTypesSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `OperatorPrecedenceAndTypesSyntax` with all trivia removed.
  public func withoutTrivia() -> OperatorPrecedenceAndTypesSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `OperatorPrecedenceAndTypesSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `OperatorPrecedenceAndTypesSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `PrecedenceGroupDeclSyntax` nodes conform. Extension point to add
/// common methods to all `PrecedenceGroupDeclSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol PrecedenceGroupDeclSyntaxProtocol: DeclSyntaxProtocol {}


/// A Swift `precedencegroup` declaration.
public struct PrecedenceGroupDeclSyntax: DeclSyntaxProtocol {
  enum Cursor: Int {
    case attributes
    case modifiers
    case precedencegroupKeyword
    case identifier
    case leftBrace
    case groupAttributes
    case rightBrace
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `PrecedenceGroupDeclSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .precedenceGroupDecl else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `PrecedenceGroupDeclSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .precedenceGroupDecl)
    self._syntaxNode = Syntax(data)
  }

  /// 
  /// The attributes applied to the 'precedencegroup' declaration.
  /// 
  public var attributes: AttributeListSyntax? {
    get {
      let childData = data.child(at: Cursor.attributes, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return AttributeListSyntax(childData!)
    }
    set(value) {
      self = withAttributes(value)
    }
  }

  /// Adds the provided `Attribute` to the node's `attributes`
  /// collection.
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  public func addAttribute(_ element: Syntax) -> PrecedenceGroupDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.attributes] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.attributeList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.attributes)
    return PrecedenceGroupDeclSyntax(newData)
  }

  /// Returns a copy of the receiver with its `attributes` replaced.
  /// - param newChild: The new `attributes` to replace the node's
  ///                   current `attributes`, if present.
  public func withAttributes(
    _ newChild: AttributeListSyntax?) -> PrecedenceGroupDeclSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.attributes)
    return PrecedenceGroupDeclSyntax(newData)
  }
  /// 
  /// The declaration modifiers applied to the 'precedencegroup'
  /// declaration.
  /// 
  public var modifiers: ModifierListSyntax? {
    get {
      let childData = data.child(at: Cursor.modifiers, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return ModifierListSyntax(childData!)
    }
    set(value) {
      self = withModifiers(value)
    }
  }

  /// Adds the provided `Modifier` to the node's `modifiers`
  /// collection.
  /// - param element: The new `Modifier` to add to the node's
  ///                  `modifiers` collection.
  /// - returns: A copy of the receiver with the provided `Modifier`
  ///            appended to its `modifiers` collection.
  public func addModifier(_ element: DeclModifierSyntax) -> PrecedenceGroupDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.modifiers] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.modifierList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.modifiers)
    return PrecedenceGroupDeclSyntax(newData)
  }

  /// Returns a copy of the receiver with its `modifiers` replaced.
  /// - param newChild: The new `modifiers` to replace the node's
  ///                   current `modifiers`, if present.
  public func withModifiers(
    _ newChild: ModifierListSyntax?) -> PrecedenceGroupDeclSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.modifiers)
    return PrecedenceGroupDeclSyntax(newData)
  }
  public var precedencegroupKeyword: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.precedencegroupKeyword, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withPrecedencegroupKeyword(value)
    }
  }

  /// Returns a copy of the receiver with its `precedencegroupKeyword` replaced.
  /// - param newChild: The new `precedencegroupKeyword` to replace the node's
  ///                   current `precedencegroupKeyword`, if present.
  public func withPrecedencegroupKeyword(
    _ newChild: TokenSyntax?) -> PrecedenceGroupDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.precedencegroupKeyword)
    let newData = data.replacingChild(raw, at: Cursor.precedencegroupKeyword)
    return PrecedenceGroupDeclSyntax(newData)
  }
  /// 
  /// The name of this precedence group.
  /// 
  public var identifier: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.identifier, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withIdentifier(value)
    }
  }

  /// Returns a copy of the receiver with its `identifier` replaced.
  /// - param newChild: The new `identifier` to replace the node's
  ///                   current `identifier`, if present.
  public func withIdentifier(
    _ newChild: TokenSyntax?) -> PrecedenceGroupDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let newData = data.replacingChild(raw, at: Cursor.identifier)
    return PrecedenceGroupDeclSyntax(newData)
  }
  public var leftBrace: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.leftBrace, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withLeftBrace(value)
    }
  }

  /// Returns a copy of the receiver with its `leftBrace` replaced.
  /// - param newChild: The new `leftBrace` to replace the node's
  ///                   current `leftBrace`, if present.
  public func withLeftBrace(
    _ newChild: TokenSyntax?) -> PrecedenceGroupDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.leftBrace)
    let newData = data.replacingChild(raw, at: Cursor.leftBrace)
    return PrecedenceGroupDeclSyntax(newData)
  }
  /// 
  /// The characteristics of this precedence group.
  /// 
  public var groupAttributes: PrecedenceGroupAttributeListSyntax {
    get {
      let childData = data.child(at: Cursor.groupAttributes, 
                                 parent: Syntax(self))
      return PrecedenceGroupAttributeListSyntax(childData!)
    }
    set(value) {
      self = withGroupAttributes(value)
    }
  }

  /// Adds the provided `GroupAttribute` to the node's `groupAttributes`
  /// collection.
  /// - param element: The new `GroupAttribute` to add to the node's
  ///                  `groupAttributes` collection.
  /// - returns: A copy of the receiver with the provided `GroupAttribute`
  ///            appended to its `groupAttributes` collection.
  public func addGroupAttribute(_ element: Syntax) -> PrecedenceGroupDeclSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.groupAttributes] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.precedenceGroupAttributeList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.groupAttributes)
    return PrecedenceGroupDeclSyntax(newData)
  }

  /// Returns a copy of the receiver with its `groupAttributes` replaced.
  /// - param newChild: The new `groupAttributes` to replace the node's
  ///                   current `groupAttributes`, if present.
  public func withGroupAttributes(
    _ newChild: PrecedenceGroupAttributeListSyntax?) -> PrecedenceGroupDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.precedenceGroupAttributeList)
    let newData = data.replacingChild(raw, at: Cursor.groupAttributes)
    return PrecedenceGroupDeclSyntax(newData)
  }
  public var rightBrace: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.rightBrace, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withRightBrace(value)
    }
  }

  /// Returns a copy of the receiver with its `rightBrace` replaced.
  /// - param newChild: The new `rightBrace` to replace the node's
  ///                   current `rightBrace`, if present.
  public func withRightBrace(
    _ newChild: TokenSyntax?) -> PrecedenceGroupDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.rightBrace)
    let newData = data.replacingChild(raw, at: Cursor.rightBrace)
    return PrecedenceGroupDeclSyntax(newData)
  }

  /// Returns a new `PrecedenceGroupDeclSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> PrecedenceGroupDeclSyntax {
    return PrecedenceGroupDeclSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `PrecedenceGroupDeclSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> PrecedenceGroupDeclSyntax {
    return PrecedenceGroupDeclSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `PrecedenceGroupDeclSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> PrecedenceGroupDeclSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `PrecedenceGroupDeclSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> PrecedenceGroupDeclSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `PrecedenceGroupDeclSyntax` with all trivia removed.
  public func withoutTrivia() -> PrecedenceGroupDeclSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `PrecedenceGroupDeclSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `PrecedenceGroupDeclSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `PrecedenceGroupAttributeListSyntax` nodes conform. Extension point to add
/// common methods to all `PrecedenceGroupAttributeListSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol PrecedenceGroupAttributeListSyntaxProtocol: SyntaxProtocol {}

/// Protocol to which all `PrecedenceGroupRelationSyntax` nodes conform. Extension point to add
/// common methods to all `PrecedenceGroupRelationSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol PrecedenceGroupRelationSyntaxProtocol: SyntaxProtocol {}


/// 
/// Specify the new precedence group's relation to existing precedence
/// groups.
/// 
public struct PrecedenceGroupRelationSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case higherThanOrLowerThan
    case colon
    case otherNames
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `PrecedenceGroupRelationSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .precedenceGroupRelation else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `PrecedenceGroupRelationSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .precedenceGroupRelation)
    self._syntaxNode = Syntax(data)
  }

  /// 
  /// The relation to specified other precedence groups.
  /// 
  public var higherThanOrLowerThan: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.higherThanOrLowerThan, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withHigherThanOrLowerThan(value)
    }
  }

  /// Returns a copy of the receiver with its `higherThanOrLowerThan` replaced.
  /// - param newChild: The new `higherThanOrLowerThan` to replace the node's
  ///                   current `higherThanOrLowerThan`, if present.
  public func withHigherThanOrLowerThan(
    _ newChild: TokenSyntax?) -> PrecedenceGroupRelationSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let newData = data.replacingChild(raw, at: Cursor.higherThanOrLowerThan)
    return PrecedenceGroupRelationSyntax(newData)
  }
  public var colon: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.colon, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withColon(value)
    }
  }

  /// Returns a copy of the receiver with its `colon` replaced.
  /// - param newChild: The new `colon` to replace the node's
  ///                   current `colon`, if present.
  public func withColon(
    _ newChild: TokenSyntax?) -> PrecedenceGroupRelationSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.colon)
    let newData = data.replacingChild(raw, at: Cursor.colon)
    return PrecedenceGroupRelationSyntax(newData)
  }
  /// 
  /// The name of other precedence group to which this precedence
  /// group relates.
  /// 
  public var otherNames: PrecedenceGroupNameListSyntax {
    get {
      let childData = data.child(at: Cursor.otherNames, 
                                 parent: Syntax(self))
      return PrecedenceGroupNameListSyntax(childData!)
    }
    set(value) {
      self = withOtherNames(value)
    }
  }

  /// Adds the provided `OtherName` to the node's `otherNames`
  /// collection.
  /// - param element: The new `OtherName` to add to the node's
  ///                  `otherNames` collection.
  /// - returns: A copy of the receiver with the provided `OtherName`
  ///            appended to its `otherNames` collection.
  public func addOtherName(_ element: PrecedenceGroupNameElementSyntax) -> PrecedenceGroupRelationSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.otherNames] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.precedenceGroupNameList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.otherNames)
    return PrecedenceGroupRelationSyntax(newData)
  }

  /// Returns a copy of the receiver with its `otherNames` replaced.
  /// - param newChild: The new `otherNames` to replace the node's
  ///                   current `otherNames`, if present.
  public func withOtherNames(
    _ newChild: PrecedenceGroupNameListSyntax?) -> PrecedenceGroupRelationSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.precedenceGroupNameList)
    let newData = data.replacingChild(raw, at: Cursor.otherNames)
    return PrecedenceGroupRelationSyntax(newData)
  }

  /// Returns a new `PrecedenceGroupRelationSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> PrecedenceGroupRelationSyntax {
    return PrecedenceGroupRelationSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `PrecedenceGroupRelationSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> PrecedenceGroupRelationSyntax {
    return PrecedenceGroupRelationSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `PrecedenceGroupRelationSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> PrecedenceGroupRelationSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `PrecedenceGroupRelationSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> PrecedenceGroupRelationSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `PrecedenceGroupRelationSyntax` with all trivia removed.
  public func withoutTrivia() -> PrecedenceGroupRelationSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `PrecedenceGroupRelationSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `PrecedenceGroupRelationSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `PrecedenceGroupNameListSyntax` nodes conform. Extension point to add
/// common methods to all `PrecedenceGroupNameListSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol PrecedenceGroupNameListSyntaxProtocol: SyntaxProtocol {}

/// Protocol to which all `PrecedenceGroupNameElementSyntax` nodes conform. Extension point to add
/// common methods to all `PrecedenceGroupNameElementSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol PrecedenceGroupNameElementSyntaxProtocol: SyntaxProtocol {}


public struct PrecedenceGroupNameElementSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case name
    case trailingComma
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `PrecedenceGroupNameElementSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .precedenceGroupNameElement else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `PrecedenceGroupNameElementSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .precedenceGroupNameElement)
    self._syntaxNode = Syntax(data)
  }

  public var name: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.name, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withName(value)
    }
  }

  /// Returns a copy of the receiver with its `name` replaced.
  /// - param newChild: The new `name` to replace the node's
  ///                   current `name`, if present.
  public func withName(
    _ newChild: TokenSyntax?) -> PrecedenceGroupNameElementSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let newData = data.replacingChild(raw, at: Cursor.name)
    return PrecedenceGroupNameElementSyntax(newData)
  }
  public var trailingComma: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.trailingComma, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withTrailingComma(value)
    }
  }

  /// Returns a copy of the receiver with its `trailingComma` replaced.
  /// - param newChild: The new `trailingComma` to replace the node's
  ///                   current `trailingComma`, if present.
  public func withTrailingComma(
    _ newChild: TokenSyntax?) -> PrecedenceGroupNameElementSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.trailingComma)
    return PrecedenceGroupNameElementSyntax(newData)
  }

  /// Returns a new `PrecedenceGroupNameElementSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> PrecedenceGroupNameElementSyntax {
    return PrecedenceGroupNameElementSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `PrecedenceGroupNameElementSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> PrecedenceGroupNameElementSyntax {
    return PrecedenceGroupNameElementSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `PrecedenceGroupNameElementSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> PrecedenceGroupNameElementSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `PrecedenceGroupNameElementSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> PrecedenceGroupNameElementSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `PrecedenceGroupNameElementSyntax` with all trivia removed.
  public func withoutTrivia() -> PrecedenceGroupNameElementSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `PrecedenceGroupNameElementSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `PrecedenceGroupNameElementSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `PrecedenceGroupAssignmentSyntax` nodes conform. Extension point to add
/// common methods to all `PrecedenceGroupAssignmentSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol PrecedenceGroupAssignmentSyntaxProtocol: SyntaxProtocol {}


/// 
/// Specifies the precedence of an operator when used in an operation
/// that includes optional chaining.
/// 
public struct PrecedenceGroupAssignmentSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case assignmentKeyword
    case colon
    case flag
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `PrecedenceGroupAssignmentSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .precedenceGroupAssignment else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `PrecedenceGroupAssignmentSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .precedenceGroupAssignment)
    self._syntaxNode = Syntax(data)
  }

  public var assignmentKeyword: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.assignmentKeyword, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withAssignmentKeyword(value)
    }
  }

  /// Returns a copy of the receiver with its `assignmentKeyword` replaced.
  /// - param newChild: The new `assignmentKeyword` to replace the node's
  ///                   current `assignmentKeyword`, if present.
  public func withAssignmentKeyword(
    _ newChild: TokenSyntax?) -> PrecedenceGroupAssignmentSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let newData = data.replacingChild(raw, at: Cursor.assignmentKeyword)
    return PrecedenceGroupAssignmentSyntax(newData)
  }
  public var colon: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.colon, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withColon(value)
    }
  }

  /// Returns a copy of the receiver with its `colon` replaced.
  /// - param newChild: The new `colon` to replace the node's
  ///                   current `colon`, if present.
  public func withColon(
    _ newChild: TokenSyntax?) -> PrecedenceGroupAssignmentSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.colon)
    let newData = data.replacingChild(raw, at: Cursor.colon)
    return PrecedenceGroupAssignmentSyntax(newData)
  }
  /// 
  /// When true, an operator in the corresponding precedence group
  /// uses the same grouping rules during optional chaining as the
  /// assignment operators from the standard library. Otherwise,
  /// operators in the precedence group follows the same optional
  /// chaining rules as operators that don't perform assignment.
  /// 
  public var flag: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.flag, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withFlag(value)
    }
  }

  /// Returns a copy of the receiver with its `flag` replaced.
  /// - param newChild: The new `flag` to replace the node's
  ///                   current `flag`, if present.
  public func withFlag(
    _ newChild: TokenSyntax?) -> PrecedenceGroupAssignmentSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.trueKeyword)
    let newData = data.replacingChild(raw, at: Cursor.flag)
    return PrecedenceGroupAssignmentSyntax(newData)
  }

  /// Returns a new `PrecedenceGroupAssignmentSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> PrecedenceGroupAssignmentSyntax {
    return PrecedenceGroupAssignmentSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `PrecedenceGroupAssignmentSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> PrecedenceGroupAssignmentSyntax {
    return PrecedenceGroupAssignmentSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `PrecedenceGroupAssignmentSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> PrecedenceGroupAssignmentSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `PrecedenceGroupAssignmentSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> PrecedenceGroupAssignmentSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `PrecedenceGroupAssignmentSyntax` with all trivia removed.
  public func withoutTrivia() -> PrecedenceGroupAssignmentSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `PrecedenceGroupAssignmentSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `PrecedenceGroupAssignmentSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `PrecedenceGroupAssociativitySyntax` nodes conform. Extension point to add
/// common methods to all `PrecedenceGroupAssociativitySyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol PrecedenceGroupAssociativitySyntaxProtocol: SyntaxProtocol {}


/// 
/// Specifies how a sequence of operators with the same precedence level
/// are grouped together in the absence of grouping parentheses.
/// 
public struct PrecedenceGroupAssociativitySyntax: SyntaxProtocol {
  enum Cursor: Int {
    case associativityKeyword
    case colon
    case value
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `PrecedenceGroupAssociativitySyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .precedenceGroupAssociativity else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `PrecedenceGroupAssociativitySyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .precedenceGroupAssociativity)
    self._syntaxNode = Syntax(data)
  }

  public var associativityKeyword: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.associativityKeyword, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withAssociativityKeyword(value)
    }
  }

  /// Returns a copy of the receiver with its `associativityKeyword` replaced.
  /// - param newChild: The new `associativityKeyword` to replace the node's
  ///                   current `associativityKeyword`, if present.
  public func withAssociativityKeyword(
    _ newChild: TokenSyntax?) -> PrecedenceGroupAssociativitySyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let newData = data.replacingChild(raw, at: Cursor.associativityKeyword)
    return PrecedenceGroupAssociativitySyntax(newData)
  }
  public var colon: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.colon, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withColon(value)
    }
  }

  /// Returns a copy of the receiver with its `colon` replaced.
  /// - param newChild: The new `colon` to replace the node's
  ///                   current `colon`, if present.
  public func withColon(
    _ newChild: TokenSyntax?) -> PrecedenceGroupAssociativitySyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.colon)
    let newData = data.replacingChild(raw, at: Cursor.colon)
    return PrecedenceGroupAssociativitySyntax(newData)
  }
  /// 
  /// Operators that are `left`-associative group left-to-right.
  /// Operators that are `right`-associative group right-to-left.
  /// Operators that are specified with an associativity of `none`
  /// don't associate at all
  /// 
  public var value: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.value, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withValue(value)
    }
  }

  /// Returns a copy of the receiver with its `value` replaced.
  /// - param newChild: The new `value` to replace the node's
  ///                   current `value`, if present.
  public func withValue(
    _ newChild: TokenSyntax?) -> PrecedenceGroupAssociativitySyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let newData = data.replacingChild(raw, at: Cursor.value)
    return PrecedenceGroupAssociativitySyntax(newData)
  }

  /// Returns a new `PrecedenceGroupAssociativitySyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> PrecedenceGroupAssociativitySyntax {
    return PrecedenceGroupAssociativitySyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `PrecedenceGroupAssociativitySyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> PrecedenceGroupAssociativitySyntax {
    return PrecedenceGroupAssociativitySyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `PrecedenceGroupAssociativitySyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> PrecedenceGroupAssociativitySyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `PrecedenceGroupAssociativitySyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> PrecedenceGroupAssociativitySyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `PrecedenceGroupAssociativitySyntax` with all trivia removed.
  public func withoutTrivia() -> PrecedenceGroupAssociativitySyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `PrecedenceGroupAssociativitySyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `PrecedenceGroupAssociativitySyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `TokenListSyntax` nodes conform. Extension point to add
/// common methods to all `TokenListSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol TokenListSyntaxProtocol: SyntaxProtocol {}

/// Protocol to which all `NonEmptyTokenListSyntax` nodes conform. Extension point to add
/// common methods to all `NonEmptyTokenListSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol NonEmptyTokenListSyntaxProtocol: SyntaxProtocol {}

/// Protocol to which all `CustomAttributeSyntax` nodes conform. Extension point to add
/// common methods to all `CustomAttributeSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol CustomAttributeSyntaxProtocol: SyntaxProtocol {}


/// 
/// A custom `@` attribute.
/// 
public struct CustomAttributeSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case atSignToken
    case attributeName
    case leftParen
    case argumentList
    case rightParen
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `CustomAttributeSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .customAttribute else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `CustomAttributeSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .customAttribute)
    self._syntaxNode = Syntax(data)
  }

  /// The `@` sign.
  public var atSignToken: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.atSignToken, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withAtSignToken(value)
    }
  }

  /// Returns a copy of the receiver with its `atSignToken` replaced.
  /// - param newChild: The new `atSignToken` to replace the node's
  ///                   current `atSignToken`, if present.
  public func withAtSignToken(
    _ newChild: TokenSyntax?) -> CustomAttributeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.atSign)
    let newData = data.replacingChild(raw, at: Cursor.atSignToken)
    return CustomAttributeSyntax(newData)
  }
  /// The name of the attribute.
  public var attributeName: TypeSyntax {
    get {
      let childData = data.child(at: Cursor.attributeName, 
                                 parent: Syntax(self))
      return TypeSyntax(childData!)
    }
    set(value) {
      self = withAttributeName(value)
    }
  }

  /// Returns a copy of the receiver with its `attributeName` replaced.
  /// - param newChild: The new `attributeName` to replace the node's
  ///                   current `attributeName`, if present.
  public func withAttributeName(
    _ newChild: TypeSyntax?) -> CustomAttributeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.type)
    let newData = data.replacingChild(raw, at: Cursor.attributeName)
    return CustomAttributeSyntax(newData)
  }
  public var leftParen: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.leftParen, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withLeftParen(value)
    }
  }

  /// Returns a copy of the receiver with its `leftParen` replaced.
  /// - param newChild: The new `leftParen` to replace the node's
  ///                   current `leftParen`, if present.
  public func withLeftParen(
    _ newChild: TokenSyntax?) -> CustomAttributeSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.leftParen)
    return CustomAttributeSyntax(newData)
  }
  public var argumentList: TupleExprElementListSyntax? {
    get {
      let childData = data.child(at: Cursor.argumentList, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TupleExprElementListSyntax(childData!)
    }
    set(value) {
      self = withArgumentList(value)
    }
  }

  /// Adds the provided `Argument` to the node's `argumentList`
  /// collection.
  /// - param element: The new `Argument` to add to the node's
  ///                  `argumentList` collection.
  /// - returns: A copy of the receiver with the provided `Argument`
  ///            appended to its `argumentList` collection.
  public func addArgument(_ element: TupleExprElementSyntax) -> CustomAttributeSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.argumentList] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.tupleExprElementList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.argumentList)
    return CustomAttributeSyntax(newData)
  }

  /// Returns a copy of the receiver with its `argumentList` replaced.
  /// - param newChild: The new `argumentList` to replace the node's
  ///                   current `argumentList`, if present.
  public func withArgumentList(
    _ newChild: TupleExprElementListSyntax?) -> CustomAttributeSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.argumentList)
    return CustomAttributeSyntax(newData)
  }
  public var rightParen: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.rightParen, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withRightParen(value)
    }
  }

  /// Returns a copy of the receiver with its `rightParen` replaced.
  /// - param newChild: The new `rightParen` to replace the node's
  ///                   current `rightParen`, if present.
  public func withRightParen(
    _ newChild: TokenSyntax?) -> CustomAttributeSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.rightParen)
    return CustomAttributeSyntax(newData)
  }

  /// Returns a new `CustomAttributeSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> CustomAttributeSyntax {
    return CustomAttributeSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `CustomAttributeSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> CustomAttributeSyntax {
    return CustomAttributeSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `CustomAttributeSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> CustomAttributeSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `CustomAttributeSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> CustomAttributeSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `CustomAttributeSyntax` with all trivia removed.
  public func withoutTrivia() -> CustomAttributeSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `CustomAttributeSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `CustomAttributeSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `AttributeSyntax` nodes conform. Extension point to add
/// common methods to all `AttributeSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol AttributeSyntaxProtocol: SyntaxProtocol {}


/// 
/// An `@` attribute.
/// 
public struct AttributeSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case atSignToken
    case attributeName
    case leftParen
    case argument
    case rightParen
    case tokenList
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `AttributeSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .attribute else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `AttributeSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .attribute)
    self._syntaxNode = Syntax(data)
  }

  /// The `@` sign.
  public var atSignToken: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.atSignToken, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withAtSignToken(value)
    }
  }

  /// Returns a copy of the receiver with its `atSignToken` replaced.
  /// - param newChild: The new `atSignToken` to replace the node's
  ///                   current `atSignToken`, if present.
  public func withAtSignToken(
    _ newChild: TokenSyntax?) -> AttributeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.atSign)
    let newData = data.replacingChild(raw, at: Cursor.atSignToken)
    return AttributeSyntax(newData)
  }
  /// The name of the attribute.
  public var attributeName: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.attributeName, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withAttributeName(value)
    }
  }

  /// Returns a copy of the receiver with its `attributeName` replaced.
  /// - param newChild: The new `attributeName` to replace the node's
  ///                   current `attributeName`, if present.
  public func withAttributeName(
    _ newChild: TokenSyntax?) -> AttributeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.unknown(""))
    let newData = data.replacingChild(raw, at: Cursor.attributeName)
    return AttributeSyntax(newData)
  }
  /// 
  /// If the attribute takes arguments, the opening parenthesis.
  /// 
  public var leftParen: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.leftParen, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withLeftParen(value)
    }
  }

  /// Returns a copy of the receiver with its `leftParen` replaced.
  /// - param newChild: The new `leftParen` to replace the node's
  ///                   current `leftParen`, if present.
  public func withLeftParen(
    _ newChild: TokenSyntax?) -> AttributeSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.leftParen)
    return AttributeSyntax(newData)
  }
  /// 
  /// The arguments of the attribute. In case the attribute                     takes multiple arguments, they are gather in the                    appropriate takes first.
  /// 
  public var argument: Syntax? {
    get {
      let childData = data.child(at: Cursor.argument, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return Syntax(childData!)
    }
    set(value) {
      self = withArgument(value)
    }
  }

  /// Returns a copy of the receiver with its `argument` replaced.
  /// - param newChild: The new `argument` to replace the node's
  ///                   current `argument`, if present.
  public func withArgument(
    _ newChild: Syntax?) -> AttributeSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.argument)
    return AttributeSyntax(newData)
  }
  /// 
  /// If the attribute takes arguments, the closing parenthesis.
  /// 
  public var rightParen: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.rightParen, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withRightParen(value)
    }
  }

  /// Returns a copy of the receiver with its `rightParen` replaced.
  /// - param newChild: The new `rightParen` to replace the node's
  ///                   current `rightParen`, if present.
  public func withRightParen(
    _ newChild: TokenSyntax?) -> AttributeSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.rightParen)
    return AttributeSyntax(newData)
  }
  public var tokenList: TokenListSyntax? {
    get {
      let childData = data.child(at: Cursor.tokenList, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenListSyntax(childData!)
    }
    set(value) {
      self = withTokenList(value)
    }
  }

  /// Adds the provided `Token` to the node's `tokenList`
  /// collection.
  /// - param element: The new `Token` to add to the node's
  ///                  `tokenList` collection.
  /// - returns: A copy of the receiver with the provided `Token`
  ///            appended to its `tokenList` collection.
  public func addToken(_ element: TokenSyntax) -> AttributeSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.tokenList] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.tokenList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.tokenList)
    return AttributeSyntax(newData)
  }

  /// Returns a copy of the receiver with its `tokenList` replaced.
  /// - param newChild: The new `tokenList` to replace the node's
  ///                   current `tokenList`, if present.
  public func withTokenList(
    _ newChild: TokenListSyntax?) -> AttributeSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.tokenList)
    return AttributeSyntax(newData)
  }

  /// Returns a new `AttributeSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> AttributeSyntax {
    return AttributeSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `AttributeSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> AttributeSyntax {
    return AttributeSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `AttributeSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> AttributeSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `AttributeSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> AttributeSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `AttributeSyntax` with all trivia removed.
  public func withoutTrivia() -> AttributeSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `AttributeSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `AttributeSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `AttributeListSyntax` nodes conform. Extension point to add
/// common methods to all `AttributeListSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol AttributeListSyntaxProtocol: SyntaxProtocol {}

/// Protocol to which all `SpecializeAttributeSpecListSyntax` nodes conform. Extension point to add
/// common methods to all `SpecializeAttributeSpecListSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol SpecializeAttributeSpecListSyntaxProtocol: SyntaxProtocol {}

/// Protocol to which all `LabeledSpecializeEntrySyntax` nodes conform. Extension point to add
/// common methods to all `LabeledSpecializeEntrySyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol LabeledSpecializeEntrySyntaxProtocol: SyntaxProtocol {}


/// 
/// A labeled argument for the `@_specialize` attribute like          `exported: true`
/// 
public struct LabeledSpecializeEntrySyntax: SyntaxProtocol {
  enum Cursor: Int {
    case label
    case colon
    case value
    case trailingComma
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `LabeledSpecializeEntrySyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .labeledSpecializeEntry else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `LabeledSpecializeEntrySyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .labeledSpecializeEntry)
    self._syntaxNode = Syntax(data)
  }

  /// The label of the argument
  public var label: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.label, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withLabel(value)
    }
  }

  /// Returns a copy of the receiver with its `label` replaced.
  /// - param newChild: The new `label` to replace the node's
  ///                   current `label`, if present.
  public func withLabel(
    _ newChild: TokenSyntax?) -> LabeledSpecializeEntrySyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let newData = data.replacingChild(raw, at: Cursor.label)
    return LabeledSpecializeEntrySyntax(newData)
  }
  /// The colon separating the label and the value
  public var colon: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.colon, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withColon(value)
    }
  }

  /// Returns a copy of the receiver with its `colon` replaced.
  /// - param newChild: The new `colon` to replace the node's
  ///                   current `colon`, if present.
  public func withColon(
    _ newChild: TokenSyntax?) -> LabeledSpecializeEntrySyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.colon)
    let newData = data.replacingChild(raw, at: Cursor.colon)
    return LabeledSpecializeEntrySyntax(newData)
  }
  /// The value for this argument
  public var value: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.value, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withValue(value)
    }
  }

  /// Returns a copy of the receiver with its `value` replaced.
  /// - param newChild: The new `value` to replace the node's
  ///                   current `value`, if present.
  public func withValue(
    _ newChild: TokenSyntax?) -> LabeledSpecializeEntrySyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.unknown(""))
    let newData = data.replacingChild(raw, at: Cursor.value)
    return LabeledSpecializeEntrySyntax(newData)
  }
  /// 
  /// A trailing comma if this argument is followed by another one
  /// 
  public var trailingComma: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.trailingComma, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withTrailingComma(value)
    }
  }

  /// Returns a copy of the receiver with its `trailingComma` replaced.
  /// - param newChild: The new `trailingComma` to replace the node's
  ///                   current `trailingComma`, if present.
  public func withTrailingComma(
    _ newChild: TokenSyntax?) -> LabeledSpecializeEntrySyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.trailingComma)
    return LabeledSpecializeEntrySyntax(newData)
  }

  /// Returns a new `LabeledSpecializeEntrySyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> LabeledSpecializeEntrySyntax {
    return LabeledSpecializeEntrySyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `LabeledSpecializeEntrySyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> LabeledSpecializeEntrySyntax {
    return LabeledSpecializeEntrySyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `LabeledSpecializeEntrySyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> LabeledSpecializeEntrySyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `LabeledSpecializeEntrySyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> LabeledSpecializeEntrySyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `LabeledSpecializeEntrySyntax` with all trivia removed.
  public func withoutTrivia() -> LabeledSpecializeEntrySyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `LabeledSpecializeEntrySyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `LabeledSpecializeEntrySyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `NamedAttributeStringArgumentSyntax` nodes conform. Extension point to add
/// common methods to all `NamedAttributeStringArgumentSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol NamedAttributeStringArgumentSyntaxProtocol: SyntaxProtocol {}


/// 
/// The argument for the `@_dynamic_replacement` or `@_private`          attribute of the form `for: "function()"` or `sourceFile:          "Src.swift"`
/// 
public struct NamedAttributeStringArgumentSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case nameTok
    case colon
    case stringOrDeclname
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `NamedAttributeStringArgumentSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .namedAttributeStringArgument else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `NamedAttributeStringArgumentSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .namedAttributeStringArgument)
    self._syntaxNode = Syntax(data)
  }

  /// The label of the argument
  public var nameTok: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.nameTok, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withNameTok(value)
    }
  }

  /// Returns a copy of the receiver with its `nameTok` replaced.
  /// - param newChild: The new `nameTok` to replace the node's
  ///                   current `nameTok`, if present.
  public func withNameTok(
    _ newChild: TokenSyntax?) -> NamedAttributeStringArgumentSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.unknown(""))
    let newData = data.replacingChild(raw, at: Cursor.nameTok)
    return NamedAttributeStringArgumentSyntax(newData)
  }
  /// The colon separating the label and the value
  public var colon: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.colon, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withColon(value)
    }
  }

  /// Returns a copy of the receiver with its `colon` replaced.
  /// - param newChild: The new `colon` to replace the node's
  ///                   current `colon`, if present.
  public func withColon(
    _ newChild: TokenSyntax?) -> NamedAttributeStringArgumentSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.colon)
    let newData = data.replacingChild(raw, at: Cursor.colon)
    return NamedAttributeStringArgumentSyntax(newData)
  }
  public var stringOrDeclname: Syntax {
    get {
      let childData = data.child(at: Cursor.stringOrDeclname, 
                                 parent: Syntax(self))
      return Syntax(childData!)
    }
    set(value) {
      self = withStringOrDeclname(value)
    }
  }

  /// Returns a copy of the receiver with its `stringOrDeclname` replaced.
  /// - param newChild: The new `stringOrDeclname` to replace the node's
  ///                   current `stringOrDeclname`, if present.
  public func withStringOrDeclname(
    _ newChild: Syntax?) -> NamedAttributeStringArgumentSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.unknown)
    let newData = data.replacingChild(raw, at: Cursor.stringOrDeclname)
    return NamedAttributeStringArgumentSyntax(newData)
  }

  /// Returns a new `NamedAttributeStringArgumentSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> NamedAttributeStringArgumentSyntax {
    return NamedAttributeStringArgumentSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `NamedAttributeStringArgumentSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> NamedAttributeStringArgumentSyntax {
    return NamedAttributeStringArgumentSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `NamedAttributeStringArgumentSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> NamedAttributeStringArgumentSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `NamedAttributeStringArgumentSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> NamedAttributeStringArgumentSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `NamedAttributeStringArgumentSyntax` with all trivia removed.
  public func withoutTrivia() -> NamedAttributeStringArgumentSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `NamedAttributeStringArgumentSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `NamedAttributeStringArgumentSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `DeclNameSyntax` nodes conform. Extension point to add
/// common methods to all `DeclNameSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol DeclNameSyntaxProtocol: SyntaxProtocol {}


public struct DeclNameSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case declBaseName
    case declNameArguments
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `DeclNameSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .declName else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `DeclNameSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .declName)
    self._syntaxNode = Syntax(data)
  }

  /// 
  /// The base name of the protocol's requirement.
  /// 
  public var declBaseName: Syntax {
    get {
      let childData = data.child(at: Cursor.declBaseName, 
                                 parent: Syntax(self))
      return Syntax(childData!)
    }
    set(value) {
      self = withDeclBaseName(value)
    }
  }

  /// Returns a copy of the receiver with its `declBaseName` replaced.
  /// - param newChild: The new `declBaseName` to replace the node's
  ///                   current `declBaseName`, if present.
  public func withDeclBaseName(
    _ newChild: Syntax?) -> DeclNameSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.unknown)
    let newData = data.replacingChild(raw, at: Cursor.declBaseName)
    return DeclNameSyntax(newData)
  }
  /// 
  /// The argument labels of the protocol's requirement if it                is a function requirement.
  /// 
  public var declNameArguments: DeclNameArgumentsSyntax? {
    get {
      let childData = data.child(at: Cursor.declNameArguments, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return DeclNameArgumentsSyntax(childData!)
    }
    set(value) {
      self = withDeclNameArguments(value)
    }
  }

  /// Returns a copy of the receiver with its `declNameArguments` replaced.
  /// - param newChild: The new `declNameArguments` to replace the node's
  ///                   current `declNameArguments`, if present.
  public func withDeclNameArguments(
    _ newChild: DeclNameArgumentsSyntax?) -> DeclNameSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.declNameArguments)
    return DeclNameSyntax(newData)
  }

  /// Returns a new `DeclNameSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> DeclNameSyntax {
    return DeclNameSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `DeclNameSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> DeclNameSyntax {
    return DeclNameSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `DeclNameSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> DeclNameSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `DeclNameSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> DeclNameSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `DeclNameSyntax` with all trivia removed.
  public func withoutTrivia() -> DeclNameSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `DeclNameSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `DeclNameSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `ImplementsAttributeArgumentsSyntax` nodes conform. Extension point to add
/// common methods to all `ImplementsAttributeArgumentsSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol ImplementsAttributeArgumentsSyntaxProtocol: SyntaxProtocol {}


/// 
/// The arguments for the `@_implements` attribute of the form          `Type, methodName(arg1Label:arg2Label:)`
/// 
public struct ImplementsAttributeArgumentsSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case type
    case comma
    case declBaseName
    case declNameArguments
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `ImplementsAttributeArgumentsSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .implementsAttributeArguments else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `ImplementsAttributeArgumentsSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .implementsAttributeArguments)
    self._syntaxNode = Syntax(data)
  }

  /// 
  /// The type for which the method with this attribute                    implements a requirement.
  /// 
  public var type: SimpleTypeIdentifierSyntax {
    get {
      let childData = data.child(at: Cursor.type, 
                                 parent: Syntax(self))
      return SimpleTypeIdentifierSyntax(childData!)
    }
    set(value) {
      self = withType(value)
    }
  }

  /// Returns a copy of the receiver with its `type` replaced.
  /// - param newChild: The new `type` to replace the node's
  ///                   current `type`, if present.
  public func withType(
    _ newChild: SimpleTypeIdentifierSyntax?) -> ImplementsAttributeArgumentsSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.simpleTypeIdentifier)
    let newData = data.replacingChild(raw, at: Cursor.type)
    return ImplementsAttributeArgumentsSyntax(newData)
  }
  /// 
  /// The comma separating the type and method name
  /// 
  public var comma: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.comma, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withComma(value)
    }
  }

  /// Returns a copy of the receiver with its `comma` replaced.
  /// - param newChild: The new `comma` to replace the node's
  ///                   current `comma`, if present.
  public func withComma(
    _ newChild: TokenSyntax?) -> ImplementsAttributeArgumentsSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.comma)
    let newData = data.replacingChild(raw, at: Cursor.comma)
    return ImplementsAttributeArgumentsSyntax(newData)
  }
  /// 
  /// The base name of the protocol's requirement.
  /// 
  public var declBaseName: Syntax {
    get {
      let childData = data.child(at: Cursor.declBaseName, 
                                 parent: Syntax(self))
      return Syntax(childData!)
    }
    set(value) {
      self = withDeclBaseName(value)
    }
  }

  /// Returns a copy of the receiver with its `declBaseName` replaced.
  /// - param newChild: The new `declBaseName` to replace the node's
  ///                   current `declBaseName`, if present.
  public func withDeclBaseName(
    _ newChild: Syntax?) -> ImplementsAttributeArgumentsSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.unknown)
    let newData = data.replacingChild(raw, at: Cursor.declBaseName)
    return ImplementsAttributeArgumentsSyntax(newData)
  }
  /// 
  /// The argument labels of the protocol's requirement if it                    is a function requirement.
  /// 
  public var declNameArguments: DeclNameArgumentsSyntax? {
    get {
      let childData = data.child(at: Cursor.declNameArguments, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return DeclNameArgumentsSyntax(childData!)
    }
    set(value) {
      self = withDeclNameArguments(value)
    }
  }

  /// Returns a copy of the receiver with its `declNameArguments` replaced.
  /// - param newChild: The new `declNameArguments` to replace the node's
  ///                   current `declNameArguments`, if present.
  public func withDeclNameArguments(
    _ newChild: DeclNameArgumentsSyntax?) -> ImplementsAttributeArgumentsSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.declNameArguments)
    return ImplementsAttributeArgumentsSyntax(newData)
  }

  /// Returns a new `ImplementsAttributeArgumentsSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> ImplementsAttributeArgumentsSyntax {
    return ImplementsAttributeArgumentsSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `ImplementsAttributeArgumentsSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> ImplementsAttributeArgumentsSyntax {
    return ImplementsAttributeArgumentsSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `ImplementsAttributeArgumentsSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> ImplementsAttributeArgumentsSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `ImplementsAttributeArgumentsSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> ImplementsAttributeArgumentsSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `ImplementsAttributeArgumentsSyntax` with all trivia removed.
  public func withoutTrivia() -> ImplementsAttributeArgumentsSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `ImplementsAttributeArgumentsSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `ImplementsAttributeArgumentsSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `ObjCSelectorPieceSyntax` nodes conform. Extension point to add
/// common methods to all `ObjCSelectorPieceSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol ObjCSelectorPieceSyntaxProtocol: SyntaxProtocol {}


/// 
/// A piece of an Objective-C selector. Either consisiting of just an          identifier for a nullary selector, an identifier and a colon for a          labeled argument or just a colon for an unlabeled argument
/// 
public struct ObjCSelectorPieceSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case name
    case colon
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `ObjCSelectorPieceSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .objCSelectorPiece else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `ObjCSelectorPieceSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .objCSelectorPiece)
    self._syntaxNode = Syntax(data)
  }

  public var name: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.name, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withName(value)
    }
  }

  /// Returns a copy of the receiver with its `name` replaced.
  /// - param newChild: The new `name` to replace the node's
  ///                   current `name`, if present.
  public func withName(
    _ newChild: TokenSyntax?) -> ObjCSelectorPieceSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.name)
    return ObjCSelectorPieceSyntax(newData)
  }
  public var colon: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.colon, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withColon(value)
    }
  }

  /// Returns a copy of the receiver with its `colon` replaced.
  /// - param newChild: The new `colon` to replace the node's
  ///                   current `colon`, if present.
  public func withColon(
    _ newChild: TokenSyntax?) -> ObjCSelectorPieceSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.colon)
    return ObjCSelectorPieceSyntax(newData)
  }

  /// Returns a new `ObjCSelectorPieceSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> ObjCSelectorPieceSyntax {
    return ObjCSelectorPieceSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `ObjCSelectorPieceSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> ObjCSelectorPieceSyntax {
    return ObjCSelectorPieceSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `ObjCSelectorPieceSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> ObjCSelectorPieceSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `ObjCSelectorPieceSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> ObjCSelectorPieceSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `ObjCSelectorPieceSyntax` with all trivia removed.
  public func withoutTrivia() -> ObjCSelectorPieceSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `ObjCSelectorPieceSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `ObjCSelectorPieceSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `ObjCSelectorSyntax` nodes conform. Extension point to add
/// common methods to all `ObjCSelectorSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol ObjCSelectorSyntaxProtocol: SyntaxProtocol {}

/// Protocol to which all `ContinueStmtSyntax` nodes conform. Extension point to add
/// common methods to all `ContinueStmtSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol ContinueStmtSyntaxProtocol: StmtSyntaxProtocol {}


public struct ContinueStmtSyntax: StmtSyntaxProtocol {
  enum Cursor: Int {
    case continueKeyword
    case label
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `ContinueStmtSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .continueStmt else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `ContinueStmtSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .continueStmt)
    self._syntaxNode = Syntax(data)
  }

  public var continueKeyword: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.continueKeyword, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withContinueKeyword(value)
    }
  }

  /// Returns a copy of the receiver with its `continueKeyword` replaced.
  /// - param newChild: The new `continueKeyword` to replace the node's
  ///                   current `continueKeyword`, if present.
  public func withContinueKeyword(
    _ newChild: TokenSyntax?) -> ContinueStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.continueKeyword)
    let newData = data.replacingChild(raw, at: Cursor.continueKeyword)
    return ContinueStmtSyntax(newData)
  }
  public var label: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.label, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withLabel(value)
    }
  }

  /// Returns a copy of the receiver with its `label` replaced.
  /// - param newChild: The new `label` to replace the node's
  ///                   current `label`, if present.
  public func withLabel(
    _ newChild: TokenSyntax?) -> ContinueStmtSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.label)
    return ContinueStmtSyntax(newData)
  }

  /// Returns a new `ContinueStmtSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> ContinueStmtSyntax {
    return ContinueStmtSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `ContinueStmtSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> ContinueStmtSyntax {
    return ContinueStmtSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `ContinueStmtSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> ContinueStmtSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `ContinueStmtSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> ContinueStmtSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `ContinueStmtSyntax` with all trivia removed.
  public func withoutTrivia() -> ContinueStmtSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `ContinueStmtSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `ContinueStmtSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `WhileStmtSyntax` nodes conform. Extension point to add
/// common methods to all `WhileStmtSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol WhileStmtSyntaxProtocol: StmtSyntaxProtocol {}


public struct WhileStmtSyntax: StmtSyntaxProtocol {
  enum Cursor: Int {
    case labelName
    case labelColon
    case whileKeyword
    case conditions
    case body
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `WhileStmtSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .whileStmt else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `WhileStmtSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .whileStmt)
    self._syntaxNode = Syntax(data)
  }

  public var labelName: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.labelName, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withLabelName(value)
    }
  }

  /// Returns a copy of the receiver with its `labelName` replaced.
  /// - param newChild: The new `labelName` to replace the node's
  ///                   current `labelName`, if present.
  public func withLabelName(
    _ newChild: TokenSyntax?) -> WhileStmtSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.labelName)
    return WhileStmtSyntax(newData)
  }
  public var labelColon: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.labelColon, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withLabelColon(value)
    }
  }

  /// Returns a copy of the receiver with its `labelColon` replaced.
  /// - param newChild: The new `labelColon` to replace the node's
  ///                   current `labelColon`, if present.
  public func withLabelColon(
    _ newChild: TokenSyntax?) -> WhileStmtSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.labelColon)
    return WhileStmtSyntax(newData)
  }
  public var whileKeyword: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.whileKeyword, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withWhileKeyword(value)
    }
  }

  /// Returns a copy of the receiver with its `whileKeyword` replaced.
  /// - param newChild: The new `whileKeyword` to replace the node's
  ///                   current `whileKeyword`, if present.
  public func withWhileKeyword(
    _ newChild: TokenSyntax?) -> WhileStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.whileKeyword)
    let newData = data.replacingChild(raw, at: Cursor.whileKeyword)
    return WhileStmtSyntax(newData)
  }
  public var conditions: ConditionElementListSyntax {
    get {
      let childData = data.child(at: Cursor.conditions, 
                                 parent: Syntax(self))
      return ConditionElementListSyntax(childData!)
    }
    set(value) {
      self = withConditions(value)
    }
  }

  /// Adds the provided `Condition` to the node's `conditions`
  /// collection.
  /// - param element: The new `Condition` to add to the node's
  ///                  `conditions` collection.
  /// - returns: A copy of the receiver with the provided `Condition`
  ///            appended to its `conditions` collection.
  public func addCondition(_ element: ConditionElementSyntax) -> WhileStmtSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.conditions] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.conditionElementList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.conditions)
    return WhileStmtSyntax(newData)
  }

  /// Returns a copy of the receiver with its `conditions` replaced.
  /// - param newChild: The new `conditions` to replace the node's
  ///                   current `conditions`, if present.
  public func withConditions(
    _ newChild: ConditionElementListSyntax?) -> WhileStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.conditionElementList)
    let newData = data.replacingChild(raw, at: Cursor.conditions)
    return WhileStmtSyntax(newData)
  }
  public var body: CodeBlockSyntax {
    get {
      let childData = data.child(at: Cursor.body, 
                                 parent: Syntax(self))
      return CodeBlockSyntax(childData!)
    }
    set(value) {
      self = withBody(value)
    }
  }

  /// Returns a copy of the receiver with its `body` replaced.
  /// - param newChild: The new `body` to replace the node's
  ///                   current `body`, if present.
  public func withBody(
    _ newChild: CodeBlockSyntax?) -> WhileStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.codeBlock)
    let newData = data.replacingChild(raw, at: Cursor.body)
    return WhileStmtSyntax(newData)
  }

  /// Returns a new `WhileStmtSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> WhileStmtSyntax {
    return WhileStmtSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `WhileStmtSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> WhileStmtSyntax {
    return WhileStmtSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `WhileStmtSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> WhileStmtSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `WhileStmtSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> WhileStmtSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `WhileStmtSyntax` with all trivia removed.
  public func withoutTrivia() -> WhileStmtSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `WhileStmtSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `WhileStmtSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `DeferStmtSyntax` nodes conform. Extension point to add
/// common methods to all `DeferStmtSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol DeferStmtSyntaxProtocol: StmtSyntaxProtocol {}


public struct DeferStmtSyntax: StmtSyntaxProtocol {
  enum Cursor: Int {
    case deferKeyword
    case body
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `DeferStmtSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .deferStmt else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `DeferStmtSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .deferStmt)
    self._syntaxNode = Syntax(data)
  }

  public var deferKeyword: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.deferKeyword, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withDeferKeyword(value)
    }
  }

  /// Returns a copy of the receiver with its `deferKeyword` replaced.
  /// - param newChild: The new `deferKeyword` to replace the node's
  ///                   current `deferKeyword`, if present.
  public func withDeferKeyword(
    _ newChild: TokenSyntax?) -> DeferStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.deferKeyword)
    let newData = data.replacingChild(raw, at: Cursor.deferKeyword)
    return DeferStmtSyntax(newData)
  }
  public var body: CodeBlockSyntax {
    get {
      let childData = data.child(at: Cursor.body, 
                                 parent: Syntax(self))
      return CodeBlockSyntax(childData!)
    }
    set(value) {
      self = withBody(value)
    }
  }

  /// Returns a copy of the receiver with its `body` replaced.
  /// - param newChild: The new `body` to replace the node's
  ///                   current `body`, if present.
  public func withBody(
    _ newChild: CodeBlockSyntax?) -> DeferStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.codeBlock)
    let newData = data.replacingChild(raw, at: Cursor.body)
    return DeferStmtSyntax(newData)
  }

  /// Returns a new `DeferStmtSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> DeferStmtSyntax {
    return DeferStmtSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `DeferStmtSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> DeferStmtSyntax {
    return DeferStmtSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `DeferStmtSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> DeferStmtSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `DeferStmtSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> DeferStmtSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `DeferStmtSyntax` with all trivia removed.
  public func withoutTrivia() -> DeferStmtSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `DeferStmtSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `DeferStmtSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `ExpressionStmtSyntax` nodes conform. Extension point to add
/// common methods to all `ExpressionStmtSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol ExpressionStmtSyntaxProtocol: StmtSyntaxProtocol {}


public struct ExpressionStmtSyntax: StmtSyntaxProtocol {
  enum Cursor: Int {
    case expression
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `ExpressionStmtSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .expressionStmt else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `ExpressionStmtSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .expressionStmt)
    self._syntaxNode = Syntax(data)
  }

  public var expression: ExprSyntax {
    get {
      let childData = data.child(at: Cursor.expression, 
                                 parent: Syntax(self))
      return ExprSyntax(childData!)
    }
    set(value) {
      self = withExpression(value)
    }
  }

  /// Returns a copy of the receiver with its `expression` replaced.
  /// - param newChild: The new `expression` to replace the node's
  ///                   current `expression`, if present.
  public func withExpression(
    _ newChild: ExprSyntax?) -> ExpressionStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.expr)
    let newData = data.replacingChild(raw, at: Cursor.expression)
    return ExpressionStmtSyntax(newData)
  }

  /// Returns a new `ExpressionStmtSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> ExpressionStmtSyntax {
    return ExpressionStmtSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `ExpressionStmtSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> ExpressionStmtSyntax {
    return ExpressionStmtSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `ExpressionStmtSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> ExpressionStmtSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `ExpressionStmtSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> ExpressionStmtSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `ExpressionStmtSyntax` with all trivia removed.
  public func withoutTrivia() -> ExpressionStmtSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `ExpressionStmtSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `ExpressionStmtSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `SwitchCaseListSyntax` nodes conform. Extension point to add
/// common methods to all `SwitchCaseListSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol SwitchCaseListSyntaxProtocol: SyntaxProtocol {}

/// Protocol to which all `RepeatWhileStmtSyntax` nodes conform. Extension point to add
/// common methods to all `RepeatWhileStmtSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol RepeatWhileStmtSyntaxProtocol: StmtSyntaxProtocol {}


public struct RepeatWhileStmtSyntax: StmtSyntaxProtocol {
  enum Cursor: Int {
    case labelName
    case labelColon
    case repeatKeyword
    case body
    case whileKeyword
    case condition
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `RepeatWhileStmtSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .repeatWhileStmt else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `RepeatWhileStmtSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .repeatWhileStmt)
    self._syntaxNode = Syntax(data)
  }

  public var labelName: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.labelName, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withLabelName(value)
    }
  }

  /// Returns a copy of the receiver with its `labelName` replaced.
  /// - param newChild: The new `labelName` to replace the node's
  ///                   current `labelName`, if present.
  public func withLabelName(
    _ newChild: TokenSyntax?) -> RepeatWhileStmtSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.labelName)
    return RepeatWhileStmtSyntax(newData)
  }
  public var labelColon: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.labelColon, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withLabelColon(value)
    }
  }

  /// Returns a copy of the receiver with its `labelColon` replaced.
  /// - param newChild: The new `labelColon` to replace the node's
  ///                   current `labelColon`, if present.
  public func withLabelColon(
    _ newChild: TokenSyntax?) -> RepeatWhileStmtSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.labelColon)
    return RepeatWhileStmtSyntax(newData)
  }
  public var repeatKeyword: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.repeatKeyword, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withRepeatKeyword(value)
    }
  }

  /// Returns a copy of the receiver with its `repeatKeyword` replaced.
  /// - param newChild: The new `repeatKeyword` to replace the node's
  ///                   current `repeatKeyword`, if present.
  public func withRepeatKeyword(
    _ newChild: TokenSyntax?) -> RepeatWhileStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.repeatKeyword)
    let newData = data.replacingChild(raw, at: Cursor.repeatKeyword)
    return RepeatWhileStmtSyntax(newData)
  }
  public var body: CodeBlockSyntax {
    get {
      let childData = data.child(at: Cursor.body, 
                                 parent: Syntax(self))
      return CodeBlockSyntax(childData!)
    }
    set(value) {
      self = withBody(value)
    }
  }

  /// Returns a copy of the receiver with its `body` replaced.
  /// - param newChild: The new `body` to replace the node's
  ///                   current `body`, if present.
  public func withBody(
    _ newChild: CodeBlockSyntax?) -> RepeatWhileStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.codeBlock)
    let newData = data.replacingChild(raw, at: Cursor.body)
    return RepeatWhileStmtSyntax(newData)
  }
  public var whileKeyword: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.whileKeyword, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withWhileKeyword(value)
    }
  }

  /// Returns a copy of the receiver with its `whileKeyword` replaced.
  /// - param newChild: The new `whileKeyword` to replace the node's
  ///                   current `whileKeyword`, if present.
  public func withWhileKeyword(
    _ newChild: TokenSyntax?) -> RepeatWhileStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.whileKeyword)
    let newData = data.replacingChild(raw, at: Cursor.whileKeyword)
    return RepeatWhileStmtSyntax(newData)
  }
  public var condition: ExprSyntax {
    get {
      let childData = data.child(at: Cursor.condition, 
                                 parent: Syntax(self))
      return ExprSyntax(childData!)
    }
    set(value) {
      self = withCondition(value)
    }
  }

  /// Returns a copy of the receiver with its `condition` replaced.
  /// - param newChild: The new `condition` to replace the node's
  ///                   current `condition`, if present.
  public func withCondition(
    _ newChild: ExprSyntax?) -> RepeatWhileStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.expr)
    let newData = data.replacingChild(raw, at: Cursor.condition)
    return RepeatWhileStmtSyntax(newData)
  }

  /// Returns a new `RepeatWhileStmtSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> RepeatWhileStmtSyntax {
    return RepeatWhileStmtSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `RepeatWhileStmtSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> RepeatWhileStmtSyntax {
    return RepeatWhileStmtSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `RepeatWhileStmtSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> RepeatWhileStmtSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `RepeatWhileStmtSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> RepeatWhileStmtSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `RepeatWhileStmtSyntax` with all trivia removed.
  public func withoutTrivia() -> RepeatWhileStmtSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `RepeatWhileStmtSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `RepeatWhileStmtSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `GuardStmtSyntax` nodes conform. Extension point to add
/// common methods to all `GuardStmtSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol GuardStmtSyntaxProtocol: StmtSyntaxProtocol {}


public struct GuardStmtSyntax: StmtSyntaxProtocol {
  enum Cursor: Int {
    case guardKeyword
    case conditions
    case elseKeyword
    case body
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `GuardStmtSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .guardStmt else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `GuardStmtSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .guardStmt)
    self._syntaxNode = Syntax(data)
  }

  public var guardKeyword: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.guardKeyword, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withGuardKeyword(value)
    }
  }

  /// Returns a copy of the receiver with its `guardKeyword` replaced.
  /// - param newChild: The new `guardKeyword` to replace the node's
  ///                   current `guardKeyword`, if present.
  public func withGuardKeyword(
    _ newChild: TokenSyntax?) -> GuardStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.guardKeyword)
    let newData = data.replacingChild(raw, at: Cursor.guardKeyword)
    return GuardStmtSyntax(newData)
  }
  public var conditions: ConditionElementListSyntax {
    get {
      let childData = data.child(at: Cursor.conditions, 
                                 parent: Syntax(self))
      return ConditionElementListSyntax(childData!)
    }
    set(value) {
      self = withConditions(value)
    }
  }

  /// Adds the provided `Condition` to the node's `conditions`
  /// collection.
  /// - param element: The new `Condition` to add to the node's
  ///                  `conditions` collection.
  /// - returns: A copy of the receiver with the provided `Condition`
  ///            appended to its `conditions` collection.
  public func addCondition(_ element: ConditionElementSyntax) -> GuardStmtSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.conditions] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.conditionElementList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.conditions)
    return GuardStmtSyntax(newData)
  }

  /// Returns a copy of the receiver with its `conditions` replaced.
  /// - param newChild: The new `conditions` to replace the node's
  ///                   current `conditions`, if present.
  public func withConditions(
    _ newChild: ConditionElementListSyntax?) -> GuardStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.conditionElementList)
    let newData = data.replacingChild(raw, at: Cursor.conditions)
    return GuardStmtSyntax(newData)
  }
  public var elseKeyword: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.elseKeyword, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withElseKeyword(value)
    }
  }

  /// Returns a copy of the receiver with its `elseKeyword` replaced.
  /// - param newChild: The new `elseKeyword` to replace the node's
  ///                   current `elseKeyword`, if present.
  public func withElseKeyword(
    _ newChild: TokenSyntax?) -> GuardStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.elseKeyword)
    let newData = data.replacingChild(raw, at: Cursor.elseKeyword)
    return GuardStmtSyntax(newData)
  }
  public var body: CodeBlockSyntax {
    get {
      let childData = data.child(at: Cursor.body, 
                                 parent: Syntax(self))
      return CodeBlockSyntax(childData!)
    }
    set(value) {
      self = withBody(value)
    }
  }

  /// Returns a copy of the receiver with its `body` replaced.
  /// - param newChild: The new `body` to replace the node's
  ///                   current `body`, if present.
  public func withBody(
    _ newChild: CodeBlockSyntax?) -> GuardStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.codeBlock)
    let newData = data.replacingChild(raw, at: Cursor.body)
    return GuardStmtSyntax(newData)
  }

  /// Returns a new `GuardStmtSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> GuardStmtSyntax {
    return GuardStmtSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `GuardStmtSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> GuardStmtSyntax {
    return GuardStmtSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `GuardStmtSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> GuardStmtSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `GuardStmtSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> GuardStmtSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `GuardStmtSyntax` with all trivia removed.
  public func withoutTrivia() -> GuardStmtSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `GuardStmtSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `GuardStmtSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `WhereClauseSyntax` nodes conform. Extension point to add
/// common methods to all `WhereClauseSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol WhereClauseSyntaxProtocol: SyntaxProtocol {}


public struct WhereClauseSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case whereKeyword
    case guardResult
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `WhereClauseSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .whereClause else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `WhereClauseSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .whereClause)
    self._syntaxNode = Syntax(data)
  }

  public var whereKeyword: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.whereKeyword, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withWhereKeyword(value)
    }
  }

  /// Returns a copy of the receiver with its `whereKeyword` replaced.
  /// - param newChild: The new `whereKeyword` to replace the node's
  ///                   current `whereKeyword`, if present.
  public func withWhereKeyword(
    _ newChild: TokenSyntax?) -> WhereClauseSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.whereKeyword)
    let newData = data.replacingChild(raw, at: Cursor.whereKeyword)
    return WhereClauseSyntax(newData)
  }
  public var guardResult: ExprSyntax {
    get {
      let childData = data.child(at: Cursor.guardResult, 
                                 parent: Syntax(self))
      return ExprSyntax(childData!)
    }
    set(value) {
      self = withGuardResult(value)
    }
  }

  /// Returns a copy of the receiver with its `guardResult` replaced.
  /// - param newChild: The new `guardResult` to replace the node's
  ///                   current `guardResult`, if present.
  public func withGuardResult(
    _ newChild: ExprSyntax?) -> WhereClauseSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.expr)
    let newData = data.replacingChild(raw, at: Cursor.guardResult)
    return WhereClauseSyntax(newData)
  }

  /// Returns a new `WhereClauseSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> WhereClauseSyntax {
    return WhereClauseSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `WhereClauseSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> WhereClauseSyntax {
    return WhereClauseSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `WhereClauseSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> WhereClauseSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `WhereClauseSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> WhereClauseSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `WhereClauseSyntax` with all trivia removed.
  public func withoutTrivia() -> WhereClauseSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `WhereClauseSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `WhereClauseSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `ForInStmtSyntax` nodes conform. Extension point to add
/// common methods to all `ForInStmtSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol ForInStmtSyntaxProtocol: StmtSyntaxProtocol {}


public struct ForInStmtSyntax: StmtSyntaxProtocol {
  enum Cursor: Int {
    case labelName
    case labelColon
    case forKeyword
    case caseKeyword
    case pattern
    case typeAnnotation
    case inKeyword
    case sequenceExpr
    case whereClause
    case body
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `ForInStmtSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .forInStmt else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `ForInStmtSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .forInStmt)
    self._syntaxNode = Syntax(data)
  }

  public var labelName: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.labelName, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withLabelName(value)
    }
  }

  /// Returns a copy of the receiver with its `labelName` replaced.
  /// - param newChild: The new `labelName` to replace the node's
  ///                   current `labelName`, if present.
  public func withLabelName(
    _ newChild: TokenSyntax?) -> ForInStmtSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.labelName)
    return ForInStmtSyntax(newData)
  }
  public var labelColon: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.labelColon, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withLabelColon(value)
    }
  }

  /// Returns a copy of the receiver with its `labelColon` replaced.
  /// - param newChild: The new `labelColon` to replace the node's
  ///                   current `labelColon`, if present.
  public func withLabelColon(
    _ newChild: TokenSyntax?) -> ForInStmtSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.labelColon)
    return ForInStmtSyntax(newData)
  }
  public var forKeyword: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.forKeyword, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withForKeyword(value)
    }
  }

  /// Returns a copy of the receiver with its `forKeyword` replaced.
  /// - param newChild: The new `forKeyword` to replace the node's
  ///                   current `forKeyword`, if present.
  public func withForKeyword(
    _ newChild: TokenSyntax?) -> ForInStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.forKeyword)
    let newData = data.replacingChild(raw, at: Cursor.forKeyword)
    return ForInStmtSyntax(newData)
  }
  public var caseKeyword: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.caseKeyword, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withCaseKeyword(value)
    }
  }

  /// Returns a copy of the receiver with its `caseKeyword` replaced.
  /// - param newChild: The new `caseKeyword` to replace the node's
  ///                   current `caseKeyword`, if present.
  public func withCaseKeyword(
    _ newChild: TokenSyntax?) -> ForInStmtSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.caseKeyword)
    return ForInStmtSyntax(newData)
  }
  public var pattern: PatternSyntax {
    get {
      let childData = data.child(at: Cursor.pattern, 
                                 parent: Syntax(self))
      return PatternSyntax(childData!)
    }
    set(value) {
      self = withPattern(value)
    }
  }

  /// Returns a copy of the receiver with its `pattern` replaced.
  /// - param newChild: The new `pattern` to replace the node's
  ///                   current `pattern`, if present.
  public func withPattern(
    _ newChild: PatternSyntax?) -> ForInStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.pattern)
    let newData = data.replacingChild(raw, at: Cursor.pattern)
    return ForInStmtSyntax(newData)
  }
  public var typeAnnotation: TypeAnnotationSyntax? {
    get {
      let childData = data.child(at: Cursor.typeAnnotation, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TypeAnnotationSyntax(childData!)
    }
    set(value) {
      self = withTypeAnnotation(value)
    }
  }

  /// Returns a copy of the receiver with its `typeAnnotation` replaced.
  /// - param newChild: The new `typeAnnotation` to replace the node's
  ///                   current `typeAnnotation`, if present.
  public func withTypeAnnotation(
    _ newChild: TypeAnnotationSyntax?) -> ForInStmtSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.typeAnnotation)
    return ForInStmtSyntax(newData)
  }
  public var inKeyword: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.inKeyword, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withInKeyword(value)
    }
  }

  /// Returns a copy of the receiver with its `inKeyword` replaced.
  /// - param newChild: The new `inKeyword` to replace the node's
  ///                   current `inKeyword`, if present.
  public func withInKeyword(
    _ newChild: TokenSyntax?) -> ForInStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.inKeyword)
    let newData = data.replacingChild(raw, at: Cursor.inKeyword)
    return ForInStmtSyntax(newData)
  }
  public var sequenceExpr: ExprSyntax {
    get {
      let childData = data.child(at: Cursor.sequenceExpr, 
                                 parent: Syntax(self))
      return ExprSyntax(childData!)
    }
    set(value) {
      self = withSequenceExpr(value)
    }
  }

  /// Returns a copy of the receiver with its `sequenceExpr` replaced.
  /// - param newChild: The new `sequenceExpr` to replace the node's
  ///                   current `sequenceExpr`, if present.
  public func withSequenceExpr(
    _ newChild: ExprSyntax?) -> ForInStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.expr)
    let newData = data.replacingChild(raw, at: Cursor.sequenceExpr)
    return ForInStmtSyntax(newData)
  }
  public var whereClause: WhereClauseSyntax? {
    get {
      let childData = data.child(at: Cursor.whereClause, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return WhereClauseSyntax(childData!)
    }
    set(value) {
      self = withWhereClause(value)
    }
  }

  /// Returns a copy of the receiver with its `whereClause` replaced.
  /// - param newChild: The new `whereClause` to replace the node's
  ///                   current `whereClause`, if present.
  public func withWhereClause(
    _ newChild: WhereClauseSyntax?) -> ForInStmtSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.whereClause)
    return ForInStmtSyntax(newData)
  }
  public var body: CodeBlockSyntax {
    get {
      let childData = data.child(at: Cursor.body, 
                                 parent: Syntax(self))
      return CodeBlockSyntax(childData!)
    }
    set(value) {
      self = withBody(value)
    }
  }

  /// Returns a copy of the receiver with its `body` replaced.
  /// - param newChild: The new `body` to replace the node's
  ///                   current `body`, if present.
  public func withBody(
    _ newChild: CodeBlockSyntax?) -> ForInStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.codeBlock)
    let newData = data.replacingChild(raw, at: Cursor.body)
    return ForInStmtSyntax(newData)
  }

  /// Returns a new `ForInStmtSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> ForInStmtSyntax {
    return ForInStmtSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `ForInStmtSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> ForInStmtSyntax {
    return ForInStmtSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `ForInStmtSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> ForInStmtSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `ForInStmtSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> ForInStmtSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `ForInStmtSyntax` with all trivia removed.
  public func withoutTrivia() -> ForInStmtSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `ForInStmtSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `ForInStmtSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `SwitchStmtSyntax` nodes conform. Extension point to add
/// common methods to all `SwitchStmtSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol SwitchStmtSyntaxProtocol: StmtSyntaxProtocol {}


public struct SwitchStmtSyntax: StmtSyntaxProtocol {
  enum Cursor: Int {
    case labelName
    case labelColon
    case switchKeyword
    case expression
    case leftBrace
    case cases
    case rightBrace
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `SwitchStmtSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .switchStmt else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `SwitchStmtSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .switchStmt)
    self._syntaxNode = Syntax(data)
  }

  public var labelName: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.labelName, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withLabelName(value)
    }
  }

  /// Returns a copy of the receiver with its `labelName` replaced.
  /// - param newChild: The new `labelName` to replace the node's
  ///                   current `labelName`, if present.
  public func withLabelName(
    _ newChild: TokenSyntax?) -> SwitchStmtSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.labelName)
    return SwitchStmtSyntax(newData)
  }
  public var labelColon: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.labelColon, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withLabelColon(value)
    }
  }

  /// Returns a copy of the receiver with its `labelColon` replaced.
  /// - param newChild: The new `labelColon` to replace the node's
  ///                   current `labelColon`, if present.
  public func withLabelColon(
    _ newChild: TokenSyntax?) -> SwitchStmtSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.labelColon)
    return SwitchStmtSyntax(newData)
  }
  public var switchKeyword: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.switchKeyword, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withSwitchKeyword(value)
    }
  }

  /// Returns a copy of the receiver with its `switchKeyword` replaced.
  /// - param newChild: The new `switchKeyword` to replace the node's
  ///                   current `switchKeyword`, if present.
  public func withSwitchKeyword(
    _ newChild: TokenSyntax?) -> SwitchStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.switchKeyword)
    let newData = data.replacingChild(raw, at: Cursor.switchKeyword)
    return SwitchStmtSyntax(newData)
  }
  public var expression: ExprSyntax {
    get {
      let childData = data.child(at: Cursor.expression, 
                                 parent: Syntax(self))
      return ExprSyntax(childData!)
    }
    set(value) {
      self = withExpression(value)
    }
  }

  /// Returns a copy of the receiver with its `expression` replaced.
  /// - param newChild: The new `expression` to replace the node's
  ///                   current `expression`, if present.
  public func withExpression(
    _ newChild: ExprSyntax?) -> SwitchStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.expr)
    let newData = data.replacingChild(raw, at: Cursor.expression)
    return SwitchStmtSyntax(newData)
  }
  public var leftBrace: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.leftBrace, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withLeftBrace(value)
    }
  }

  /// Returns a copy of the receiver with its `leftBrace` replaced.
  /// - param newChild: The new `leftBrace` to replace the node's
  ///                   current `leftBrace`, if present.
  public func withLeftBrace(
    _ newChild: TokenSyntax?) -> SwitchStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.leftBrace)
    let newData = data.replacingChild(raw, at: Cursor.leftBrace)
    return SwitchStmtSyntax(newData)
  }
  public var cases: SwitchCaseListSyntax {
    get {
      let childData = data.child(at: Cursor.cases, 
                                 parent: Syntax(self))
      return SwitchCaseListSyntax(childData!)
    }
    set(value) {
      self = withCases(value)
    }
  }

  /// Adds the provided `Case` to the node's `cases`
  /// collection.
  /// - param element: The new `Case` to add to the node's
  ///                  `cases` collection.
  /// - returns: A copy of the receiver with the provided `Case`
  ///            appended to its `cases` collection.
  public func addCase(_ element: Syntax) -> SwitchStmtSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.cases] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.switchCaseList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.cases)
    return SwitchStmtSyntax(newData)
  }

  /// Returns a copy of the receiver with its `cases` replaced.
  /// - param newChild: The new `cases` to replace the node's
  ///                   current `cases`, if present.
  public func withCases(
    _ newChild: SwitchCaseListSyntax?) -> SwitchStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.switchCaseList)
    let newData = data.replacingChild(raw, at: Cursor.cases)
    return SwitchStmtSyntax(newData)
  }
  public var rightBrace: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.rightBrace, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withRightBrace(value)
    }
  }

  /// Returns a copy of the receiver with its `rightBrace` replaced.
  /// - param newChild: The new `rightBrace` to replace the node's
  ///                   current `rightBrace`, if present.
  public func withRightBrace(
    _ newChild: TokenSyntax?) -> SwitchStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.rightBrace)
    let newData = data.replacingChild(raw, at: Cursor.rightBrace)
    return SwitchStmtSyntax(newData)
  }

  /// Returns a new `SwitchStmtSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> SwitchStmtSyntax {
    return SwitchStmtSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `SwitchStmtSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> SwitchStmtSyntax {
    return SwitchStmtSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `SwitchStmtSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> SwitchStmtSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `SwitchStmtSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> SwitchStmtSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `SwitchStmtSyntax` with all trivia removed.
  public func withoutTrivia() -> SwitchStmtSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `SwitchStmtSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `SwitchStmtSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `CatchClauseListSyntax` nodes conform. Extension point to add
/// common methods to all `CatchClauseListSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol CatchClauseListSyntaxProtocol: SyntaxProtocol {}

/// Protocol to which all `DoStmtSyntax` nodes conform. Extension point to add
/// common methods to all `DoStmtSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol DoStmtSyntaxProtocol: StmtSyntaxProtocol {}


public struct DoStmtSyntax: StmtSyntaxProtocol {
  enum Cursor: Int {
    case labelName
    case labelColon
    case doKeyword
    case body
    case catchClauses
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `DoStmtSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .doStmt else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `DoStmtSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .doStmt)
    self._syntaxNode = Syntax(data)
  }

  public var labelName: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.labelName, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withLabelName(value)
    }
  }

  /// Returns a copy of the receiver with its `labelName` replaced.
  /// - param newChild: The new `labelName` to replace the node's
  ///                   current `labelName`, if present.
  public func withLabelName(
    _ newChild: TokenSyntax?) -> DoStmtSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.labelName)
    return DoStmtSyntax(newData)
  }
  public var labelColon: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.labelColon, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withLabelColon(value)
    }
  }

  /// Returns a copy of the receiver with its `labelColon` replaced.
  /// - param newChild: The new `labelColon` to replace the node's
  ///                   current `labelColon`, if present.
  public func withLabelColon(
    _ newChild: TokenSyntax?) -> DoStmtSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.labelColon)
    return DoStmtSyntax(newData)
  }
  public var doKeyword: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.doKeyword, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withDoKeyword(value)
    }
  }

  /// Returns a copy of the receiver with its `doKeyword` replaced.
  /// - param newChild: The new `doKeyword` to replace the node's
  ///                   current `doKeyword`, if present.
  public func withDoKeyword(
    _ newChild: TokenSyntax?) -> DoStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.doKeyword)
    let newData = data.replacingChild(raw, at: Cursor.doKeyword)
    return DoStmtSyntax(newData)
  }
  public var body: CodeBlockSyntax {
    get {
      let childData = data.child(at: Cursor.body, 
                                 parent: Syntax(self))
      return CodeBlockSyntax(childData!)
    }
    set(value) {
      self = withBody(value)
    }
  }

  /// Returns a copy of the receiver with its `body` replaced.
  /// - param newChild: The new `body` to replace the node's
  ///                   current `body`, if present.
  public func withBody(
    _ newChild: CodeBlockSyntax?) -> DoStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.codeBlock)
    let newData = data.replacingChild(raw, at: Cursor.body)
    return DoStmtSyntax(newData)
  }
  public var catchClauses: CatchClauseListSyntax? {
    get {
      let childData = data.child(at: Cursor.catchClauses, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return CatchClauseListSyntax(childData!)
    }
    set(value) {
      self = withCatchClauses(value)
    }
  }

  /// Adds the provided `CatchClause` to the node's `catchClauses`
  /// collection.
  /// - param element: The new `CatchClause` to add to the node's
  ///                  `catchClauses` collection.
  /// - returns: A copy of the receiver with the provided `CatchClause`
  ///            appended to its `catchClauses` collection.
  public func addCatchClause(_ element: CatchClauseSyntax) -> DoStmtSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.catchClauses] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.catchClauseList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.catchClauses)
    return DoStmtSyntax(newData)
  }

  /// Returns a copy of the receiver with its `catchClauses` replaced.
  /// - param newChild: The new `catchClauses` to replace the node's
  ///                   current `catchClauses`, if present.
  public func withCatchClauses(
    _ newChild: CatchClauseListSyntax?) -> DoStmtSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.catchClauses)
    return DoStmtSyntax(newData)
  }

  /// Returns a new `DoStmtSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> DoStmtSyntax {
    return DoStmtSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `DoStmtSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> DoStmtSyntax {
    return DoStmtSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `DoStmtSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> DoStmtSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `DoStmtSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> DoStmtSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `DoStmtSyntax` with all trivia removed.
  public func withoutTrivia() -> DoStmtSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `DoStmtSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `DoStmtSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `ReturnStmtSyntax` nodes conform. Extension point to add
/// common methods to all `ReturnStmtSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol ReturnStmtSyntaxProtocol: StmtSyntaxProtocol {}


public struct ReturnStmtSyntax: StmtSyntaxProtocol {
  enum Cursor: Int {
    case returnKeyword
    case expression
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `ReturnStmtSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .returnStmt else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `ReturnStmtSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .returnStmt)
    self._syntaxNode = Syntax(data)
  }

  public var returnKeyword: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.returnKeyword, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withReturnKeyword(value)
    }
  }

  /// Returns a copy of the receiver with its `returnKeyword` replaced.
  /// - param newChild: The new `returnKeyword` to replace the node's
  ///                   current `returnKeyword`, if present.
  public func withReturnKeyword(
    _ newChild: TokenSyntax?) -> ReturnStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.returnKeyword)
    let newData = data.replacingChild(raw, at: Cursor.returnKeyword)
    return ReturnStmtSyntax(newData)
  }
  public var expression: ExprSyntax? {
    get {
      let childData = data.child(at: Cursor.expression, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return ExprSyntax(childData!)
    }
    set(value) {
      self = withExpression(value)
    }
  }

  /// Returns a copy of the receiver with its `expression` replaced.
  /// - param newChild: The new `expression` to replace the node's
  ///                   current `expression`, if present.
  public func withExpression(
    _ newChild: ExprSyntax?) -> ReturnStmtSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.expression)
    return ReturnStmtSyntax(newData)
  }

  /// Returns a new `ReturnStmtSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> ReturnStmtSyntax {
    return ReturnStmtSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `ReturnStmtSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> ReturnStmtSyntax {
    return ReturnStmtSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `ReturnStmtSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> ReturnStmtSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `ReturnStmtSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> ReturnStmtSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `ReturnStmtSyntax` with all trivia removed.
  public func withoutTrivia() -> ReturnStmtSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `ReturnStmtSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `ReturnStmtSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `YieldStmtSyntax` nodes conform. Extension point to add
/// common methods to all `YieldStmtSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol YieldStmtSyntaxProtocol: StmtSyntaxProtocol {}


public struct YieldStmtSyntax: StmtSyntaxProtocol {
  enum Cursor: Int {
    case yieldKeyword
    case yields
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `YieldStmtSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .yieldStmt else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `YieldStmtSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .yieldStmt)
    self._syntaxNode = Syntax(data)
  }

  public var yieldKeyword: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.yieldKeyword, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withYieldKeyword(value)
    }
  }

  /// Returns a copy of the receiver with its `yieldKeyword` replaced.
  /// - param newChild: The new `yieldKeyword` to replace the node's
  ///                   current `yieldKeyword`, if present.
  public func withYieldKeyword(
    _ newChild: TokenSyntax?) -> YieldStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.yield)
    let newData = data.replacingChild(raw, at: Cursor.yieldKeyword)
    return YieldStmtSyntax(newData)
  }
  public var yields: Syntax {
    get {
      let childData = data.child(at: Cursor.yields, 
                                 parent: Syntax(self))
      return Syntax(childData!)
    }
    set(value) {
      self = withYields(value)
    }
  }

  /// Returns a copy of the receiver with its `yields` replaced.
  /// - param newChild: The new `yields` to replace the node's
  ///                   current `yields`, if present.
  public func withYields(
    _ newChild: Syntax?) -> YieldStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.unknown)
    let newData = data.replacingChild(raw, at: Cursor.yields)
    return YieldStmtSyntax(newData)
  }

  /// Returns a new `YieldStmtSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> YieldStmtSyntax {
    return YieldStmtSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `YieldStmtSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> YieldStmtSyntax {
    return YieldStmtSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `YieldStmtSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> YieldStmtSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `YieldStmtSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> YieldStmtSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `YieldStmtSyntax` with all trivia removed.
  public func withoutTrivia() -> YieldStmtSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `YieldStmtSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `YieldStmtSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `YieldListSyntax` nodes conform. Extension point to add
/// common methods to all `YieldListSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol YieldListSyntaxProtocol: SyntaxProtocol {}


public struct YieldListSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case leftParen
    case elementList
    case trailingComma
    case rightParen
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `YieldListSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .yieldList else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `YieldListSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .yieldList)
    self._syntaxNode = Syntax(data)
  }

  public var leftParen: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.leftParen, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withLeftParen(value)
    }
  }

  /// Returns a copy of the receiver with its `leftParen` replaced.
  /// - param newChild: The new `leftParen` to replace the node's
  ///                   current `leftParen`, if present.
  public func withLeftParen(
    _ newChild: TokenSyntax?) -> YieldListSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.leftParen)
    let newData = data.replacingChild(raw, at: Cursor.leftParen)
    return YieldListSyntax(newData)
  }
  public var elementList: ExprListSyntax {
    get {
      let childData = data.child(at: Cursor.elementList, 
                                 parent: Syntax(self))
      return ExprListSyntax(childData!)
    }
    set(value) {
      self = withElementList(value)
    }
  }

  /// Adds the provided `Element` to the node's `elementList`
  /// collection.
  /// - param element: The new `Element` to add to the node's
  ///                  `elementList` collection.
  /// - returns: A copy of the receiver with the provided `Element`
  ///            appended to its `elementList` collection.
  public func addElement(_ element: ExprSyntax) -> YieldListSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.elementList] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.exprList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.elementList)
    return YieldListSyntax(newData)
  }

  /// Returns a copy of the receiver with its `elementList` replaced.
  /// - param newChild: The new `elementList` to replace the node's
  ///                   current `elementList`, if present.
  public func withElementList(
    _ newChild: ExprListSyntax?) -> YieldListSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.exprList)
    let newData = data.replacingChild(raw, at: Cursor.elementList)
    return YieldListSyntax(newData)
  }
  public var trailingComma: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.trailingComma, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withTrailingComma(value)
    }
  }

  /// Returns a copy of the receiver with its `trailingComma` replaced.
  /// - param newChild: The new `trailingComma` to replace the node's
  ///                   current `trailingComma`, if present.
  public func withTrailingComma(
    _ newChild: TokenSyntax?) -> YieldListSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.trailingComma)
    return YieldListSyntax(newData)
  }
  public var rightParen: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.rightParen, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withRightParen(value)
    }
  }

  /// Returns a copy of the receiver with its `rightParen` replaced.
  /// - param newChild: The new `rightParen` to replace the node's
  ///                   current `rightParen`, if present.
  public func withRightParen(
    _ newChild: TokenSyntax?) -> YieldListSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.rightParen)
    let newData = data.replacingChild(raw, at: Cursor.rightParen)
    return YieldListSyntax(newData)
  }

  /// Returns a new `YieldListSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> YieldListSyntax {
    return YieldListSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `YieldListSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> YieldListSyntax {
    return YieldListSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `YieldListSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> YieldListSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `YieldListSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> YieldListSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `YieldListSyntax` with all trivia removed.
  public func withoutTrivia() -> YieldListSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `YieldListSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `YieldListSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `FallthroughStmtSyntax` nodes conform. Extension point to add
/// common methods to all `FallthroughStmtSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol FallthroughStmtSyntaxProtocol: StmtSyntaxProtocol {}


public struct FallthroughStmtSyntax: StmtSyntaxProtocol {
  enum Cursor: Int {
    case fallthroughKeyword
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `FallthroughStmtSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .fallthroughStmt else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `FallthroughStmtSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .fallthroughStmt)
    self._syntaxNode = Syntax(data)
  }

  public var fallthroughKeyword: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.fallthroughKeyword, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withFallthroughKeyword(value)
    }
  }

  /// Returns a copy of the receiver with its `fallthroughKeyword` replaced.
  /// - param newChild: The new `fallthroughKeyword` to replace the node's
  ///                   current `fallthroughKeyword`, if present.
  public func withFallthroughKeyword(
    _ newChild: TokenSyntax?) -> FallthroughStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.fallthroughKeyword)
    let newData = data.replacingChild(raw, at: Cursor.fallthroughKeyword)
    return FallthroughStmtSyntax(newData)
  }

  /// Returns a new `FallthroughStmtSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> FallthroughStmtSyntax {
    return FallthroughStmtSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `FallthroughStmtSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> FallthroughStmtSyntax {
    return FallthroughStmtSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `FallthroughStmtSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> FallthroughStmtSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `FallthroughStmtSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> FallthroughStmtSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `FallthroughStmtSyntax` with all trivia removed.
  public func withoutTrivia() -> FallthroughStmtSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `FallthroughStmtSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `FallthroughStmtSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `BreakStmtSyntax` nodes conform. Extension point to add
/// common methods to all `BreakStmtSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol BreakStmtSyntaxProtocol: StmtSyntaxProtocol {}


public struct BreakStmtSyntax: StmtSyntaxProtocol {
  enum Cursor: Int {
    case breakKeyword
    case label
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `BreakStmtSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .breakStmt else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `BreakStmtSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .breakStmt)
    self._syntaxNode = Syntax(data)
  }

  public var breakKeyword: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.breakKeyword, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withBreakKeyword(value)
    }
  }

  /// Returns a copy of the receiver with its `breakKeyword` replaced.
  /// - param newChild: The new `breakKeyword` to replace the node's
  ///                   current `breakKeyword`, if present.
  public func withBreakKeyword(
    _ newChild: TokenSyntax?) -> BreakStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.breakKeyword)
    let newData = data.replacingChild(raw, at: Cursor.breakKeyword)
    return BreakStmtSyntax(newData)
  }
  public var label: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.label, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withLabel(value)
    }
  }

  /// Returns a copy of the receiver with its `label` replaced.
  /// - param newChild: The new `label` to replace the node's
  ///                   current `label`, if present.
  public func withLabel(
    _ newChild: TokenSyntax?) -> BreakStmtSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.label)
    return BreakStmtSyntax(newData)
  }

  /// Returns a new `BreakStmtSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> BreakStmtSyntax {
    return BreakStmtSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `BreakStmtSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> BreakStmtSyntax {
    return BreakStmtSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `BreakStmtSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> BreakStmtSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `BreakStmtSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> BreakStmtSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `BreakStmtSyntax` with all trivia removed.
  public func withoutTrivia() -> BreakStmtSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `BreakStmtSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `BreakStmtSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `CaseItemListSyntax` nodes conform. Extension point to add
/// common methods to all `CaseItemListSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol CaseItemListSyntaxProtocol: SyntaxProtocol {}

/// Protocol to which all `ConditionElementSyntax` nodes conform. Extension point to add
/// common methods to all `ConditionElementSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol ConditionElementSyntaxProtocol: SyntaxProtocol {}


public struct ConditionElementSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case condition
    case trailingComma
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `ConditionElementSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .conditionElement else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `ConditionElementSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .conditionElement)
    self._syntaxNode = Syntax(data)
  }

  public var condition: Syntax {
    get {
      let childData = data.child(at: Cursor.condition, 
                                 parent: Syntax(self))
      return Syntax(childData!)
    }
    set(value) {
      self = withCondition(value)
    }
  }

  /// Returns a copy of the receiver with its `condition` replaced.
  /// - param newChild: The new `condition` to replace the node's
  ///                   current `condition`, if present.
  public func withCondition(
    _ newChild: Syntax?) -> ConditionElementSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.unknown)
    let newData = data.replacingChild(raw, at: Cursor.condition)
    return ConditionElementSyntax(newData)
  }
  public var trailingComma: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.trailingComma, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withTrailingComma(value)
    }
  }

  /// Returns a copy of the receiver with its `trailingComma` replaced.
  /// - param newChild: The new `trailingComma` to replace the node's
  ///                   current `trailingComma`, if present.
  public func withTrailingComma(
    _ newChild: TokenSyntax?) -> ConditionElementSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.trailingComma)
    return ConditionElementSyntax(newData)
  }

  /// Returns a new `ConditionElementSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> ConditionElementSyntax {
    return ConditionElementSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `ConditionElementSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> ConditionElementSyntax {
    return ConditionElementSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `ConditionElementSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> ConditionElementSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `ConditionElementSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> ConditionElementSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `ConditionElementSyntax` with all trivia removed.
  public func withoutTrivia() -> ConditionElementSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `ConditionElementSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `ConditionElementSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `AvailabilityConditionSyntax` nodes conform. Extension point to add
/// common methods to all `AvailabilityConditionSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol AvailabilityConditionSyntaxProtocol: SyntaxProtocol {}


public struct AvailabilityConditionSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case poundAvailableKeyword
    case leftParen
    case availabilitySpec
    case rightParen
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `AvailabilityConditionSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .availabilityCondition else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `AvailabilityConditionSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .availabilityCondition)
    self._syntaxNode = Syntax(data)
  }

  public var poundAvailableKeyword: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.poundAvailableKeyword, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withPoundAvailableKeyword(value)
    }
  }

  /// Returns a copy of the receiver with its `poundAvailableKeyword` replaced.
  /// - param newChild: The new `poundAvailableKeyword` to replace the node's
  ///                   current `poundAvailableKeyword`, if present.
  public func withPoundAvailableKeyword(
    _ newChild: TokenSyntax?) -> AvailabilityConditionSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.poundAvailableKeyword)
    let newData = data.replacingChild(raw, at: Cursor.poundAvailableKeyword)
    return AvailabilityConditionSyntax(newData)
  }
  public var leftParen: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.leftParen, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withLeftParen(value)
    }
  }

  /// Returns a copy of the receiver with its `leftParen` replaced.
  /// - param newChild: The new `leftParen` to replace the node's
  ///                   current `leftParen`, if present.
  public func withLeftParen(
    _ newChild: TokenSyntax?) -> AvailabilityConditionSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.leftParen)
    let newData = data.replacingChild(raw, at: Cursor.leftParen)
    return AvailabilityConditionSyntax(newData)
  }
  public var availabilitySpec: AvailabilitySpecListSyntax {
    get {
      let childData = data.child(at: Cursor.availabilitySpec, 
                                 parent: Syntax(self))
      return AvailabilitySpecListSyntax(childData!)
    }
    set(value) {
      self = withAvailabilitySpec(value)
    }
  }

  /// Adds the provided `AvailabilityArgument` to the node's `availabilitySpec`
  /// collection.
  /// - param element: The new `AvailabilityArgument` to add to the node's
  ///                  `availabilitySpec` collection.
  /// - returns: A copy of the receiver with the provided `AvailabilityArgument`
  ///            appended to its `availabilitySpec` collection.
  public func addAvailabilityArgument(_ element: AvailabilityArgumentSyntax) -> AvailabilityConditionSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.availabilitySpec] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.availabilitySpecList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.availabilitySpec)
    return AvailabilityConditionSyntax(newData)
  }

  /// Returns a copy of the receiver with its `availabilitySpec` replaced.
  /// - param newChild: The new `availabilitySpec` to replace the node's
  ///                   current `availabilitySpec`, if present.
  public func withAvailabilitySpec(
    _ newChild: AvailabilitySpecListSyntax?) -> AvailabilityConditionSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.availabilitySpecList)
    let newData = data.replacingChild(raw, at: Cursor.availabilitySpec)
    return AvailabilityConditionSyntax(newData)
  }
  public var rightParen: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.rightParen, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withRightParen(value)
    }
  }

  /// Returns a copy of the receiver with its `rightParen` replaced.
  /// - param newChild: The new `rightParen` to replace the node's
  ///                   current `rightParen`, if present.
  public func withRightParen(
    _ newChild: TokenSyntax?) -> AvailabilityConditionSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.rightParen)
    let newData = data.replacingChild(raw, at: Cursor.rightParen)
    return AvailabilityConditionSyntax(newData)
  }

  /// Returns a new `AvailabilityConditionSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> AvailabilityConditionSyntax {
    return AvailabilityConditionSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `AvailabilityConditionSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> AvailabilityConditionSyntax {
    return AvailabilityConditionSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `AvailabilityConditionSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> AvailabilityConditionSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `AvailabilityConditionSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> AvailabilityConditionSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `AvailabilityConditionSyntax` with all trivia removed.
  public func withoutTrivia() -> AvailabilityConditionSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `AvailabilityConditionSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `AvailabilityConditionSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `MatchingPatternConditionSyntax` nodes conform. Extension point to add
/// common methods to all `MatchingPatternConditionSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol MatchingPatternConditionSyntaxProtocol: SyntaxProtocol {}


public struct MatchingPatternConditionSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case caseKeyword
    case pattern
    case typeAnnotation
    case initializer
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `MatchingPatternConditionSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .matchingPatternCondition else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `MatchingPatternConditionSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .matchingPatternCondition)
    self._syntaxNode = Syntax(data)
  }

  public var caseKeyword: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.caseKeyword, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withCaseKeyword(value)
    }
  }

  /// Returns a copy of the receiver with its `caseKeyword` replaced.
  /// - param newChild: The new `caseKeyword` to replace the node's
  ///                   current `caseKeyword`, if present.
  public func withCaseKeyword(
    _ newChild: TokenSyntax?) -> MatchingPatternConditionSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.caseKeyword)
    let newData = data.replacingChild(raw, at: Cursor.caseKeyword)
    return MatchingPatternConditionSyntax(newData)
  }
  public var pattern: PatternSyntax {
    get {
      let childData = data.child(at: Cursor.pattern, 
                                 parent: Syntax(self))
      return PatternSyntax(childData!)
    }
    set(value) {
      self = withPattern(value)
    }
  }

  /// Returns a copy of the receiver with its `pattern` replaced.
  /// - param newChild: The new `pattern` to replace the node's
  ///                   current `pattern`, if present.
  public func withPattern(
    _ newChild: PatternSyntax?) -> MatchingPatternConditionSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.pattern)
    let newData = data.replacingChild(raw, at: Cursor.pattern)
    return MatchingPatternConditionSyntax(newData)
  }
  public var typeAnnotation: TypeAnnotationSyntax? {
    get {
      let childData = data.child(at: Cursor.typeAnnotation, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TypeAnnotationSyntax(childData!)
    }
    set(value) {
      self = withTypeAnnotation(value)
    }
  }

  /// Returns a copy of the receiver with its `typeAnnotation` replaced.
  /// - param newChild: The new `typeAnnotation` to replace the node's
  ///                   current `typeAnnotation`, if present.
  public func withTypeAnnotation(
    _ newChild: TypeAnnotationSyntax?) -> MatchingPatternConditionSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.typeAnnotation)
    return MatchingPatternConditionSyntax(newData)
  }
  public var initializer: InitializerClauseSyntax {
    get {
      let childData = data.child(at: Cursor.initializer, 
                                 parent: Syntax(self))
      return InitializerClauseSyntax(childData!)
    }
    set(value) {
      self = withInitializer(value)
    }
  }

  /// Returns a copy of the receiver with its `initializer` replaced.
  /// - param newChild: The new `initializer` to replace the node's
  ///                   current `initializer`, if present.
  public func withInitializer(
    _ newChild: InitializerClauseSyntax?) -> MatchingPatternConditionSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.initializerClause)
    let newData = data.replacingChild(raw, at: Cursor.initializer)
    return MatchingPatternConditionSyntax(newData)
  }

  /// Returns a new `MatchingPatternConditionSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> MatchingPatternConditionSyntax {
    return MatchingPatternConditionSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `MatchingPatternConditionSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> MatchingPatternConditionSyntax {
    return MatchingPatternConditionSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `MatchingPatternConditionSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> MatchingPatternConditionSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `MatchingPatternConditionSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> MatchingPatternConditionSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `MatchingPatternConditionSyntax` with all trivia removed.
  public func withoutTrivia() -> MatchingPatternConditionSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `MatchingPatternConditionSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `MatchingPatternConditionSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `OptionalBindingConditionSyntax` nodes conform. Extension point to add
/// common methods to all `OptionalBindingConditionSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol OptionalBindingConditionSyntaxProtocol: SyntaxProtocol {}


public struct OptionalBindingConditionSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case letOrVarKeyword
    case pattern
    case typeAnnotation
    case initializer
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `OptionalBindingConditionSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .optionalBindingCondition else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `OptionalBindingConditionSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .optionalBindingCondition)
    self._syntaxNode = Syntax(data)
  }

  public var letOrVarKeyword: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.letOrVarKeyword, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withLetOrVarKeyword(value)
    }
  }

  /// Returns a copy of the receiver with its `letOrVarKeyword` replaced.
  /// - param newChild: The new `letOrVarKeyword` to replace the node's
  ///                   current `letOrVarKeyword`, if present.
  public func withLetOrVarKeyword(
    _ newChild: TokenSyntax?) -> OptionalBindingConditionSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.letKeyword)
    let newData = data.replacingChild(raw, at: Cursor.letOrVarKeyword)
    return OptionalBindingConditionSyntax(newData)
  }
  public var pattern: PatternSyntax {
    get {
      let childData = data.child(at: Cursor.pattern, 
                                 parent: Syntax(self))
      return PatternSyntax(childData!)
    }
    set(value) {
      self = withPattern(value)
    }
  }

  /// Returns a copy of the receiver with its `pattern` replaced.
  /// - param newChild: The new `pattern` to replace the node's
  ///                   current `pattern`, if present.
  public func withPattern(
    _ newChild: PatternSyntax?) -> OptionalBindingConditionSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.pattern)
    let newData = data.replacingChild(raw, at: Cursor.pattern)
    return OptionalBindingConditionSyntax(newData)
  }
  public var typeAnnotation: TypeAnnotationSyntax? {
    get {
      let childData = data.child(at: Cursor.typeAnnotation, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TypeAnnotationSyntax(childData!)
    }
    set(value) {
      self = withTypeAnnotation(value)
    }
  }

  /// Returns a copy of the receiver with its `typeAnnotation` replaced.
  /// - param newChild: The new `typeAnnotation` to replace the node's
  ///                   current `typeAnnotation`, if present.
  public func withTypeAnnotation(
    _ newChild: TypeAnnotationSyntax?) -> OptionalBindingConditionSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.typeAnnotation)
    return OptionalBindingConditionSyntax(newData)
  }
  public var initializer: InitializerClauseSyntax {
    get {
      let childData = data.child(at: Cursor.initializer, 
                                 parent: Syntax(self))
      return InitializerClauseSyntax(childData!)
    }
    set(value) {
      self = withInitializer(value)
    }
  }

  /// Returns a copy of the receiver with its `initializer` replaced.
  /// - param newChild: The new `initializer` to replace the node's
  ///                   current `initializer`, if present.
  public func withInitializer(
    _ newChild: InitializerClauseSyntax?) -> OptionalBindingConditionSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.initializerClause)
    let newData = data.replacingChild(raw, at: Cursor.initializer)
    return OptionalBindingConditionSyntax(newData)
  }

  /// Returns a new `OptionalBindingConditionSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> OptionalBindingConditionSyntax {
    return OptionalBindingConditionSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `OptionalBindingConditionSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> OptionalBindingConditionSyntax {
    return OptionalBindingConditionSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `OptionalBindingConditionSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> OptionalBindingConditionSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `OptionalBindingConditionSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> OptionalBindingConditionSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `OptionalBindingConditionSyntax` with all trivia removed.
  public func withoutTrivia() -> OptionalBindingConditionSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `OptionalBindingConditionSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `OptionalBindingConditionSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `ConditionElementListSyntax` nodes conform. Extension point to add
/// common methods to all `ConditionElementListSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol ConditionElementListSyntaxProtocol: SyntaxProtocol {}

/// Protocol to which all `DeclarationStmtSyntax` nodes conform. Extension point to add
/// common methods to all `DeclarationStmtSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol DeclarationStmtSyntaxProtocol: StmtSyntaxProtocol {}


public struct DeclarationStmtSyntax: StmtSyntaxProtocol {
  enum Cursor: Int {
    case declaration
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `DeclarationStmtSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .declarationStmt else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `DeclarationStmtSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .declarationStmt)
    self._syntaxNode = Syntax(data)
  }

  public var declaration: DeclSyntax {
    get {
      let childData = data.child(at: Cursor.declaration, 
                                 parent: Syntax(self))
      return DeclSyntax(childData!)
    }
    set(value) {
      self = withDeclaration(value)
    }
  }

  /// Returns a copy of the receiver with its `declaration` replaced.
  /// - param newChild: The new `declaration` to replace the node's
  ///                   current `declaration`, if present.
  public func withDeclaration(
    _ newChild: DeclSyntax?) -> DeclarationStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.decl)
    let newData = data.replacingChild(raw, at: Cursor.declaration)
    return DeclarationStmtSyntax(newData)
  }

  /// Returns a new `DeclarationStmtSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> DeclarationStmtSyntax {
    return DeclarationStmtSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `DeclarationStmtSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> DeclarationStmtSyntax {
    return DeclarationStmtSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `DeclarationStmtSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> DeclarationStmtSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `DeclarationStmtSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> DeclarationStmtSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `DeclarationStmtSyntax` with all trivia removed.
  public func withoutTrivia() -> DeclarationStmtSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `DeclarationStmtSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `DeclarationStmtSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `ThrowStmtSyntax` nodes conform. Extension point to add
/// common methods to all `ThrowStmtSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol ThrowStmtSyntaxProtocol: StmtSyntaxProtocol {}


public struct ThrowStmtSyntax: StmtSyntaxProtocol {
  enum Cursor: Int {
    case throwKeyword
    case expression
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `ThrowStmtSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .throwStmt else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `ThrowStmtSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .throwStmt)
    self._syntaxNode = Syntax(data)
  }

  public var throwKeyword: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.throwKeyword, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withThrowKeyword(value)
    }
  }

  /// Returns a copy of the receiver with its `throwKeyword` replaced.
  /// - param newChild: The new `throwKeyword` to replace the node's
  ///                   current `throwKeyword`, if present.
  public func withThrowKeyword(
    _ newChild: TokenSyntax?) -> ThrowStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.throwKeyword)
    let newData = data.replacingChild(raw, at: Cursor.throwKeyword)
    return ThrowStmtSyntax(newData)
  }
  public var expression: ExprSyntax {
    get {
      let childData = data.child(at: Cursor.expression, 
                                 parent: Syntax(self))
      return ExprSyntax(childData!)
    }
    set(value) {
      self = withExpression(value)
    }
  }

  /// Returns a copy of the receiver with its `expression` replaced.
  /// - param newChild: The new `expression` to replace the node's
  ///                   current `expression`, if present.
  public func withExpression(
    _ newChild: ExprSyntax?) -> ThrowStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.expr)
    let newData = data.replacingChild(raw, at: Cursor.expression)
    return ThrowStmtSyntax(newData)
  }

  /// Returns a new `ThrowStmtSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> ThrowStmtSyntax {
    return ThrowStmtSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `ThrowStmtSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> ThrowStmtSyntax {
    return ThrowStmtSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `ThrowStmtSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> ThrowStmtSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `ThrowStmtSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> ThrowStmtSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `ThrowStmtSyntax` with all trivia removed.
  public func withoutTrivia() -> ThrowStmtSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `ThrowStmtSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `ThrowStmtSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `IfStmtSyntax` nodes conform. Extension point to add
/// common methods to all `IfStmtSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol IfStmtSyntaxProtocol: StmtSyntaxProtocol {}


public struct IfStmtSyntax: StmtSyntaxProtocol {
  enum Cursor: Int {
    case labelName
    case labelColon
    case ifKeyword
    case conditions
    case body
    case elseKeyword
    case elseBody
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `IfStmtSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .ifStmt else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `IfStmtSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .ifStmt)
    self._syntaxNode = Syntax(data)
  }

  public var labelName: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.labelName, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withLabelName(value)
    }
  }

  /// Returns a copy of the receiver with its `labelName` replaced.
  /// - param newChild: The new `labelName` to replace the node's
  ///                   current `labelName`, if present.
  public func withLabelName(
    _ newChild: TokenSyntax?) -> IfStmtSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.labelName)
    return IfStmtSyntax(newData)
  }
  public var labelColon: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.labelColon, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withLabelColon(value)
    }
  }

  /// Returns a copy of the receiver with its `labelColon` replaced.
  /// - param newChild: The new `labelColon` to replace the node's
  ///                   current `labelColon`, if present.
  public func withLabelColon(
    _ newChild: TokenSyntax?) -> IfStmtSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.labelColon)
    return IfStmtSyntax(newData)
  }
  public var ifKeyword: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.ifKeyword, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withIfKeyword(value)
    }
  }

  /// Returns a copy of the receiver with its `ifKeyword` replaced.
  /// - param newChild: The new `ifKeyword` to replace the node's
  ///                   current `ifKeyword`, if present.
  public func withIfKeyword(
    _ newChild: TokenSyntax?) -> IfStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.ifKeyword)
    let newData = data.replacingChild(raw, at: Cursor.ifKeyword)
    return IfStmtSyntax(newData)
  }
  public var conditions: ConditionElementListSyntax {
    get {
      let childData = data.child(at: Cursor.conditions, 
                                 parent: Syntax(self))
      return ConditionElementListSyntax(childData!)
    }
    set(value) {
      self = withConditions(value)
    }
  }

  /// Adds the provided `Condition` to the node's `conditions`
  /// collection.
  /// - param element: The new `Condition` to add to the node's
  ///                  `conditions` collection.
  /// - returns: A copy of the receiver with the provided `Condition`
  ///            appended to its `conditions` collection.
  public func addCondition(_ element: ConditionElementSyntax) -> IfStmtSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.conditions] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.conditionElementList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.conditions)
    return IfStmtSyntax(newData)
  }

  /// Returns a copy of the receiver with its `conditions` replaced.
  /// - param newChild: The new `conditions` to replace the node's
  ///                   current `conditions`, if present.
  public func withConditions(
    _ newChild: ConditionElementListSyntax?) -> IfStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.conditionElementList)
    let newData = data.replacingChild(raw, at: Cursor.conditions)
    return IfStmtSyntax(newData)
  }
  public var body: CodeBlockSyntax {
    get {
      let childData = data.child(at: Cursor.body, 
                                 parent: Syntax(self))
      return CodeBlockSyntax(childData!)
    }
    set(value) {
      self = withBody(value)
    }
  }

  /// Returns a copy of the receiver with its `body` replaced.
  /// - param newChild: The new `body` to replace the node's
  ///                   current `body`, if present.
  public func withBody(
    _ newChild: CodeBlockSyntax?) -> IfStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.codeBlock)
    let newData = data.replacingChild(raw, at: Cursor.body)
    return IfStmtSyntax(newData)
  }
  public var elseKeyword: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.elseKeyword, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withElseKeyword(value)
    }
  }

  /// Returns a copy of the receiver with its `elseKeyword` replaced.
  /// - param newChild: The new `elseKeyword` to replace the node's
  ///                   current `elseKeyword`, if present.
  public func withElseKeyword(
    _ newChild: TokenSyntax?) -> IfStmtSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.elseKeyword)
    return IfStmtSyntax(newData)
  }
  public var elseBody: Syntax? {
    get {
      let childData = data.child(at: Cursor.elseBody, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return Syntax(childData!)
    }
    set(value) {
      self = withElseBody(value)
    }
  }

  /// Returns a copy of the receiver with its `elseBody` replaced.
  /// - param newChild: The new `elseBody` to replace the node's
  ///                   current `elseBody`, if present.
  public func withElseBody(
    _ newChild: Syntax?) -> IfStmtSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.elseBody)
    return IfStmtSyntax(newData)
  }

  /// Returns a new `IfStmtSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> IfStmtSyntax {
    return IfStmtSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `IfStmtSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> IfStmtSyntax {
    return IfStmtSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `IfStmtSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> IfStmtSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `IfStmtSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> IfStmtSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `IfStmtSyntax` with all trivia removed.
  public func withoutTrivia() -> IfStmtSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `IfStmtSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `IfStmtSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `ElseIfContinuationSyntax` nodes conform. Extension point to add
/// common methods to all `ElseIfContinuationSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol ElseIfContinuationSyntaxProtocol: SyntaxProtocol {}


public struct ElseIfContinuationSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case ifStatement
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `ElseIfContinuationSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .elseIfContinuation else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `ElseIfContinuationSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .elseIfContinuation)
    self._syntaxNode = Syntax(data)
  }

  public var ifStatement: IfStmtSyntax {
    get {
      let childData = data.child(at: Cursor.ifStatement, 
                                 parent: Syntax(self))
      return IfStmtSyntax(childData!)
    }
    set(value) {
      self = withIfStatement(value)
    }
  }

  /// Returns a copy of the receiver with its `ifStatement` replaced.
  /// - param newChild: The new `ifStatement` to replace the node's
  ///                   current `ifStatement`, if present.
  public func withIfStatement(
    _ newChild: IfStmtSyntax?) -> ElseIfContinuationSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.ifStmt)
    let newData = data.replacingChild(raw, at: Cursor.ifStatement)
    return ElseIfContinuationSyntax(newData)
  }

  /// Returns a new `ElseIfContinuationSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> ElseIfContinuationSyntax {
    return ElseIfContinuationSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `ElseIfContinuationSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> ElseIfContinuationSyntax {
    return ElseIfContinuationSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `ElseIfContinuationSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> ElseIfContinuationSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `ElseIfContinuationSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> ElseIfContinuationSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `ElseIfContinuationSyntax` with all trivia removed.
  public func withoutTrivia() -> ElseIfContinuationSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `ElseIfContinuationSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `ElseIfContinuationSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `ElseBlockSyntax` nodes conform. Extension point to add
/// common methods to all `ElseBlockSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol ElseBlockSyntaxProtocol: SyntaxProtocol {}


public struct ElseBlockSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case elseKeyword
    case body
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `ElseBlockSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .elseBlock else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `ElseBlockSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .elseBlock)
    self._syntaxNode = Syntax(data)
  }

  public var elseKeyword: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.elseKeyword, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withElseKeyword(value)
    }
  }

  /// Returns a copy of the receiver with its `elseKeyword` replaced.
  /// - param newChild: The new `elseKeyword` to replace the node's
  ///                   current `elseKeyword`, if present.
  public func withElseKeyword(
    _ newChild: TokenSyntax?) -> ElseBlockSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.elseKeyword)
    let newData = data.replacingChild(raw, at: Cursor.elseKeyword)
    return ElseBlockSyntax(newData)
  }
  public var body: CodeBlockSyntax {
    get {
      let childData = data.child(at: Cursor.body, 
                                 parent: Syntax(self))
      return CodeBlockSyntax(childData!)
    }
    set(value) {
      self = withBody(value)
    }
  }

  /// Returns a copy of the receiver with its `body` replaced.
  /// - param newChild: The new `body` to replace the node's
  ///                   current `body`, if present.
  public func withBody(
    _ newChild: CodeBlockSyntax?) -> ElseBlockSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.codeBlock)
    let newData = data.replacingChild(raw, at: Cursor.body)
    return ElseBlockSyntax(newData)
  }

  /// Returns a new `ElseBlockSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> ElseBlockSyntax {
    return ElseBlockSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `ElseBlockSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> ElseBlockSyntax {
    return ElseBlockSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `ElseBlockSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> ElseBlockSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `ElseBlockSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> ElseBlockSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `ElseBlockSyntax` with all trivia removed.
  public func withoutTrivia() -> ElseBlockSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `ElseBlockSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `ElseBlockSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `SwitchCaseSyntax` nodes conform. Extension point to add
/// common methods to all `SwitchCaseSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol SwitchCaseSyntaxProtocol: SyntaxProtocol {}


public struct SwitchCaseSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case unknownAttr
    case label
    case statements
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `SwitchCaseSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .switchCase else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `SwitchCaseSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .switchCase)
    self._syntaxNode = Syntax(data)
  }

  public var unknownAttr: AttributeSyntax? {
    get {
      let childData = data.child(at: Cursor.unknownAttr, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return AttributeSyntax(childData!)
    }
    set(value) {
      self = withUnknownAttr(value)
    }
  }

  /// Returns a copy of the receiver with its `unknownAttr` replaced.
  /// - param newChild: The new `unknownAttr` to replace the node's
  ///                   current `unknownAttr`, if present.
  public func withUnknownAttr(
    _ newChild: AttributeSyntax?) -> SwitchCaseSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.unknownAttr)
    return SwitchCaseSyntax(newData)
  }
  public var label: Syntax {
    get {
      let childData = data.child(at: Cursor.label, 
                                 parent: Syntax(self))
      return Syntax(childData!)
    }
    set(value) {
      self = withLabel(value)
    }
  }

  /// Returns a copy of the receiver with its `label` replaced.
  /// - param newChild: The new `label` to replace the node's
  ///                   current `label`, if present.
  public func withLabel(
    _ newChild: Syntax?) -> SwitchCaseSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.unknown)
    let newData = data.replacingChild(raw, at: Cursor.label)
    return SwitchCaseSyntax(newData)
  }
  public var statements: CodeBlockItemListSyntax {
    get {
      let childData = data.child(at: Cursor.statements, 
                                 parent: Syntax(self))
      return CodeBlockItemListSyntax(childData!)
    }
    set(value) {
      self = withStatements(value)
    }
  }

  /// Adds the provided `Statement` to the node's `statements`
  /// collection.
  /// - param element: The new `Statement` to add to the node's
  ///                  `statements` collection.
  /// - returns: A copy of the receiver with the provided `Statement`
  ///            appended to its `statements` collection.
  public func addStatement(_ element: CodeBlockItemSyntax) -> SwitchCaseSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.statements] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.codeBlockItemList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.statements)
    return SwitchCaseSyntax(newData)
  }

  /// Returns a copy of the receiver with its `statements` replaced.
  /// - param newChild: The new `statements` to replace the node's
  ///                   current `statements`, if present.
  public func withStatements(
    _ newChild: CodeBlockItemListSyntax?) -> SwitchCaseSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.codeBlockItemList)
    let newData = data.replacingChild(raw, at: Cursor.statements)
    return SwitchCaseSyntax(newData)
  }

  /// Returns a new `SwitchCaseSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> SwitchCaseSyntax {
    return SwitchCaseSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `SwitchCaseSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> SwitchCaseSyntax {
    return SwitchCaseSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `SwitchCaseSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> SwitchCaseSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `SwitchCaseSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> SwitchCaseSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `SwitchCaseSyntax` with all trivia removed.
  public func withoutTrivia() -> SwitchCaseSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `SwitchCaseSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `SwitchCaseSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `SwitchDefaultLabelSyntax` nodes conform. Extension point to add
/// common methods to all `SwitchDefaultLabelSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol SwitchDefaultLabelSyntaxProtocol: SyntaxProtocol {}


public struct SwitchDefaultLabelSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case defaultKeyword
    case colon
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `SwitchDefaultLabelSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .switchDefaultLabel else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `SwitchDefaultLabelSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .switchDefaultLabel)
    self._syntaxNode = Syntax(data)
  }

  public var defaultKeyword: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.defaultKeyword, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withDefaultKeyword(value)
    }
  }

  /// Returns a copy of the receiver with its `defaultKeyword` replaced.
  /// - param newChild: The new `defaultKeyword` to replace the node's
  ///                   current `defaultKeyword`, if present.
  public func withDefaultKeyword(
    _ newChild: TokenSyntax?) -> SwitchDefaultLabelSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.defaultKeyword)
    let newData = data.replacingChild(raw, at: Cursor.defaultKeyword)
    return SwitchDefaultLabelSyntax(newData)
  }
  public var colon: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.colon, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withColon(value)
    }
  }

  /// Returns a copy of the receiver with its `colon` replaced.
  /// - param newChild: The new `colon` to replace the node's
  ///                   current `colon`, if present.
  public func withColon(
    _ newChild: TokenSyntax?) -> SwitchDefaultLabelSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.colon)
    let newData = data.replacingChild(raw, at: Cursor.colon)
    return SwitchDefaultLabelSyntax(newData)
  }

  /// Returns a new `SwitchDefaultLabelSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> SwitchDefaultLabelSyntax {
    return SwitchDefaultLabelSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `SwitchDefaultLabelSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> SwitchDefaultLabelSyntax {
    return SwitchDefaultLabelSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `SwitchDefaultLabelSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> SwitchDefaultLabelSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `SwitchDefaultLabelSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> SwitchDefaultLabelSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `SwitchDefaultLabelSyntax` with all trivia removed.
  public func withoutTrivia() -> SwitchDefaultLabelSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `SwitchDefaultLabelSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `SwitchDefaultLabelSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `CaseItemSyntax` nodes conform. Extension point to add
/// common methods to all `CaseItemSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol CaseItemSyntaxProtocol: SyntaxProtocol {}


public struct CaseItemSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case pattern
    case whereClause
    case trailingComma
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `CaseItemSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .caseItem else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `CaseItemSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .caseItem)
    self._syntaxNode = Syntax(data)
  }

  public var pattern: PatternSyntax {
    get {
      let childData = data.child(at: Cursor.pattern, 
                                 parent: Syntax(self))
      return PatternSyntax(childData!)
    }
    set(value) {
      self = withPattern(value)
    }
  }

  /// Returns a copy of the receiver with its `pattern` replaced.
  /// - param newChild: The new `pattern` to replace the node's
  ///                   current `pattern`, if present.
  public func withPattern(
    _ newChild: PatternSyntax?) -> CaseItemSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.pattern)
    let newData = data.replacingChild(raw, at: Cursor.pattern)
    return CaseItemSyntax(newData)
  }
  public var whereClause: WhereClauseSyntax? {
    get {
      let childData = data.child(at: Cursor.whereClause, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return WhereClauseSyntax(childData!)
    }
    set(value) {
      self = withWhereClause(value)
    }
  }

  /// Returns a copy of the receiver with its `whereClause` replaced.
  /// - param newChild: The new `whereClause` to replace the node's
  ///                   current `whereClause`, if present.
  public func withWhereClause(
    _ newChild: WhereClauseSyntax?) -> CaseItemSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.whereClause)
    return CaseItemSyntax(newData)
  }
  public var trailingComma: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.trailingComma, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withTrailingComma(value)
    }
  }

  /// Returns a copy of the receiver with its `trailingComma` replaced.
  /// - param newChild: The new `trailingComma` to replace the node's
  ///                   current `trailingComma`, if present.
  public func withTrailingComma(
    _ newChild: TokenSyntax?) -> CaseItemSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.trailingComma)
    return CaseItemSyntax(newData)
  }

  /// Returns a new `CaseItemSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> CaseItemSyntax {
    return CaseItemSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `CaseItemSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> CaseItemSyntax {
    return CaseItemSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `CaseItemSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> CaseItemSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `CaseItemSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> CaseItemSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `CaseItemSyntax` with all trivia removed.
  public func withoutTrivia() -> CaseItemSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `CaseItemSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `CaseItemSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `SwitchCaseLabelSyntax` nodes conform. Extension point to add
/// common methods to all `SwitchCaseLabelSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol SwitchCaseLabelSyntaxProtocol: SyntaxProtocol {}


public struct SwitchCaseLabelSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case caseKeyword
    case caseItems
    case colon
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `SwitchCaseLabelSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .switchCaseLabel else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `SwitchCaseLabelSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .switchCaseLabel)
    self._syntaxNode = Syntax(data)
  }

  public var caseKeyword: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.caseKeyword, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withCaseKeyword(value)
    }
  }

  /// Returns a copy of the receiver with its `caseKeyword` replaced.
  /// - param newChild: The new `caseKeyword` to replace the node's
  ///                   current `caseKeyword`, if present.
  public func withCaseKeyword(
    _ newChild: TokenSyntax?) -> SwitchCaseLabelSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.caseKeyword)
    let newData = data.replacingChild(raw, at: Cursor.caseKeyword)
    return SwitchCaseLabelSyntax(newData)
  }
  public var caseItems: CaseItemListSyntax {
    get {
      let childData = data.child(at: Cursor.caseItems, 
                                 parent: Syntax(self))
      return CaseItemListSyntax(childData!)
    }
    set(value) {
      self = withCaseItems(value)
    }
  }

  /// Adds the provided `CaseItem` to the node's `caseItems`
  /// collection.
  /// - param element: The new `CaseItem` to add to the node's
  ///                  `caseItems` collection.
  /// - returns: A copy of the receiver with the provided `CaseItem`
  ///            appended to its `caseItems` collection.
  public func addCaseItem(_ element: CaseItemSyntax) -> SwitchCaseLabelSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.caseItems] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.caseItemList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.caseItems)
    return SwitchCaseLabelSyntax(newData)
  }

  /// Returns a copy of the receiver with its `caseItems` replaced.
  /// - param newChild: The new `caseItems` to replace the node's
  ///                   current `caseItems`, if present.
  public func withCaseItems(
    _ newChild: CaseItemListSyntax?) -> SwitchCaseLabelSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.caseItemList)
    let newData = data.replacingChild(raw, at: Cursor.caseItems)
    return SwitchCaseLabelSyntax(newData)
  }
  public var colon: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.colon, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withColon(value)
    }
  }

  /// Returns a copy of the receiver with its `colon` replaced.
  /// - param newChild: The new `colon` to replace the node's
  ///                   current `colon`, if present.
  public func withColon(
    _ newChild: TokenSyntax?) -> SwitchCaseLabelSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.colon)
    let newData = data.replacingChild(raw, at: Cursor.colon)
    return SwitchCaseLabelSyntax(newData)
  }

  /// Returns a new `SwitchCaseLabelSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> SwitchCaseLabelSyntax {
    return SwitchCaseLabelSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `SwitchCaseLabelSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> SwitchCaseLabelSyntax {
    return SwitchCaseLabelSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `SwitchCaseLabelSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> SwitchCaseLabelSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `SwitchCaseLabelSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> SwitchCaseLabelSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `SwitchCaseLabelSyntax` with all trivia removed.
  public func withoutTrivia() -> SwitchCaseLabelSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `SwitchCaseLabelSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `SwitchCaseLabelSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `CatchClauseSyntax` nodes conform. Extension point to add
/// common methods to all `CatchClauseSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol CatchClauseSyntaxProtocol: SyntaxProtocol {}


public struct CatchClauseSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case catchKeyword
    case pattern
    case whereClause
    case body
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `CatchClauseSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .catchClause else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `CatchClauseSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .catchClause)
    self._syntaxNode = Syntax(data)
  }

  public var catchKeyword: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.catchKeyword, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withCatchKeyword(value)
    }
  }

  /// Returns a copy of the receiver with its `catchKeyword` replaced.
  /// - param newChild: The new `catchKeyword` to replace the node's
  ///                   current `catchKeyword`, if present.
  public func withCatchKeyword(
    _ newChild: TokenSyntax?) -> CatchClauseSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.catchKeyword)
    let newData = data.replacingChild(raw, at: Cursor.catchKeyword)
    return CatchClauseSyntax(newData)
  }
  public var pattern: PatternSyntax? {
    get {
      let childData = data.child(at: Cursor.pattern, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return PatternSyntax(childData!)
    }
    set(value) {
      self = withPattern(value)
    }
  }

  /// Returns a copy of the receiver with its `pattern` replaced.
  /// - param newChild: The new `pattern` to replace the node's
  ///                   current `pattern`, if present.
  public func withPattern(
    _ newChild: PatternSyntax?) -> CatchClauseSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.pattern)
    return CatchClauseSyntax(newData)
  }
  public var whereClause: WhereClauseSyntax? {
    get {
      let childData = data.child(at: Cursor.whereClause, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return WhereClauseSyntax(childData!)
    }
    set(value) {
      self = withWhereClause(value)
    }
  }

  /// Returns a copy of the receiver with its `whereClause` replaced.
  /// - param newChild: The new `whereClause` to replace the node's
  ///                   current `whereClause`, if present.
  public func withWhereClause(
    _ newChild: WhereClauseSyntax?) -> CatchClauseSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.whereClause)
    return CatchClauseSyntax(newData)
  }
  public var body: CodeBlockSyntax {
    get {
      let childData = data.child(at: Cursor.body, 
                                 parent: Syntax(self))
      return CodeBlockSyntax(childData!)
    }
    set(value) {
      self = withBody(value)
    }
  }

  /// Returns a copy of the receiver with its `body` replaced.
  /// - param newChild: The new `body` to replace the node's
  ///                   current `body`, if present.
  public func withBody(
    _ newChild: CodeBlockSyntax?) -> CatchClauseSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.codeBlock)
    let newData = data.replacingChild(raw, at: Cursor.body)
    return CatchClauseSyntax(newData)
  }

  /// Returns a new `CatchClauseSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> CatchClauseSyntax {
    return CatchClauseSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `CatchClauseSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> CatchClauseSyntax {
    return CatchClauseSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `CatchClauseSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> CatchClauseSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `CatchClauseSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> CatchClauseSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `CatchClauseSyntax` with all trivia removed.
  public func withoutTrivia() -> CatchClauseSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `CatchClauseSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `CatchClauseSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `PoundAssertStmtSyntax` nodes conform. Extension point to add
/// common methods to all `PoundAssertStmtSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol PoundAssertStmtSyntaxProtocol: StmtSyntaxProtocol {}


public struct PoundAssertStmtSyntax: StmtSyntaxProtocol {
  enum Cursor: Int {
    case poundAssert
    case leftParen
    case condition
    case comma
    case message
    case rightParen
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `PoundAssertStmtSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .poundAssertStmt else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `PoundAssertStmtSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .poundAssertStmt)
    self._syntaxNode = Syntax(data)
  }

  public var poundAssert: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.poundAssert, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withPoundAssert(value)
    }
  }

  /// Returns a copy of the receiver with its `poundAssert` replaced.
  /// - param newChild: The new `poundAssert` to replace the node's
  ///                   current `poundAssert`, if present.
  public func withPoundAssert(
    _ newChild: TokenSyntax?) -> PoundAssertStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.poundAssertKeyword)
    let newData = data.replacingChild(raw, at: Cursor.poundAssert)
    return PoundAssertStmtSyntax(newData)
  }
  public var leftParen: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.leftParen, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withLeftParen(value)
    }
  }

  /// Returns a copy of the receiver with its `leftParen` replaced.
  /// - param newChild: The new `leftParen` to replace the node's
  ///                   current `leftParen`, if present.
  public func withLeftParen(
    _ newChild: TokenSyntax?) -> PoundAssertStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.leftParen)
    let newData = data.replacingChild(raw, at: Cursor.leftParen)
    return PoundAssertStmtSyntax(newData)
  }
  /// The assertion condition.
  public var condition: ExprSyntax {
    get {
      let childData = data.child(at: Cursor.condition, 
                                 parent: Syntax(self))
      return ExprSyntax(childData!)
    }
    set(value) {
      self = withCondition(value)
    }
  }

  /// Returns a copy of the receiver with its `condition` replaced.
  /// - param newChild: The new `condition` to replace the node's
  ///                   current `condition`, if present.
  public func withCondition(
    _ newChild: ExprSyntax?) -> PoundAssertStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.expr)
    let newData = data.replacingChild(raw, at: Cursor.condition)
    return PoundAssertStmtSyntax(newData)
  }
  /// The comma after the assertion condition.
  public var comma: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.comma, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withComma(value)
    }
  }

  /// Returns a copy of the receiver with its `comma` replaced.
  /// - param newChild: The new `comma` to replace the node's
  ///                   current `comma`, if present.
  public func withComma(
    _ newChild: TokenSyntax?) -> PoundAssertStmtSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.comma)
    return PoundAssertStmtSyntax(newData)
  }
  /// The assertion message.
  public var message: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.message, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withMessage(value)
    }
  }

  /// Returns a copy of the receiver with its `message` replaced.
  /// - param newChild: The new `message` to replace the node's
  ///                   current `message`, if present.
  public func withMessage(
    _ newChild: TokenSyntax?) -> PoundAssertStmtSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.message)
    return PoundAssertStmtSyntax(newData)
  }
  public var rightParen: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.rightParen, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withRightParen(value)
    }
  }

  /// Returns a copy of the receiver with its `rightParen` replaced.
  /// - param newChild: The new `rightParen` to replace the node's
  ///                   current `rightParen`, if present.
  public func withRightParen(
    _ newChild: TokenSyntax?) -> PoundAssertStmtSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.rightParen)
    let newData = data.replacingChild(raw, at: Cursor.rightParen)
    return PoundAssertStmtSyntax(newData)
  }

  /// Returns a new `PoundAssertStmtSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> PoundAssertStmtSyntax {
    return PoundAssertStmtSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `PoundAssertStmtSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> PoundAssertStmtSyntax {
    return PoundAssertStmtSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `PoundAssertStmtSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> PoundAssertStmtSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `PoundAssertStmtSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> PoundAssertStmtSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `PoundAssertStmtSyntax` with all trivia removed.
  public func withoutTrivia() -> PoundAssertStmtSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `PoundAssertStmtSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `PoundAssertStmtSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `GenericWhereClauseSyntax` nodes conform. Extension point to add
/// common methods to all `GenericWhereClauseSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol GenericWhereClauseSyntaxProtocol: SyntaxProtocol {}


public struct GenericWhereClauseSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case whereKeyword
    case requirementList
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `GenericWhereClauseSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .genericWhereClause else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `GenericWhereClauseSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .genericWhereClause)
    self._syntaxNode = Syntax(data)
  }

  public var whereKeyword: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.whereKeyword, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withWhereKeyword(value)
    }
  }

  /// Returns a copy of the receiver with its `whereKeyword` replaced.
  /// - param newChild: The new `whereKeyword` to replace the node's
  ///                   current `whereKeyword`, if present.
  public func withWhereKeyword(
    _ newChild: TokenSyntax?) -> GenericWhereClauseSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.whereKeyword)
    let newData = data.replacingChild(raw, at: Cursor.whereKeyword)
    return GenericWhereClauseSyntax(newData)
  }
  public var requirementList: GenericRequirementListSyntax {
    get {
      let childData = data.child(at: Cursor.requirementList, 
                                 parent: Syntax(self))
      return GenericRequirementListSyntax(childData!)
    }
    set(value) {
      self = withRequirementList(value)
    }
  }

  /// Adds the provided `Requirement` to the node's `requirementList`
  /// collection.
  /// - param element: The new `Requirement` to add to the node's
  ///                  `requirementList` collection.
  /// - returns: A copy of the receiver with the provided `Requirement`
  ///            appended to its `requirementList` collection.
  public func addRequirement(_ element: GenericRequirementSyntax) -> GenericWhereClauseSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.requirementList] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.genericRequirementList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.requirementList)
    return GenericWhereClauseSyntax(newData)
  }

  /// Returns a copy of the receiver with its `requirementList` replaced.
  /// - param newChild: The new `requirementList` to replace the node's
  ///                   current `requirementList`, if present.
  public func withRequirementList(
    _ newChild: GenericRequirementListSyntax?) -> GenericWhereClauseSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.genericRequirementList)
    let newData = data.replacingChild(raw, at: Cursor.requirementList)
    return GenericWhereClauseSyntax(newData)
  }

  /// Returns a new `GenericWhereClauseSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> GenericWhereClauseSyntax {
    return GenericWhereClauseSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `GenericWhereClauseSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> GenericWhereClauseSyntax {
    return GenericWhereClauseSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `GenericWhereClauseSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> GenericWhereClauseSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `GenericWhereClauseSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> GenericWhereClauseSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `GenericWhereClauseSyntax` with all trivia removed.
  public func withoutTrivia() -> GenericWhereClauseSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `GenericWhereClauseSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `GenericWhereClauseSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `GenericRequirementListSyntax` nodes conform. Extension point to add
/// common methods to all `GenericRequirementListSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol GenericRequirementListSyntaxProtocol: SyntaxProtocol {}

/// Protocol to which all `GenericRequirementSyntax` nodes conform. Extension point to add
/// common methods to all `GenericRequirementSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol GenericRequirementSyntaxProtocol: SyntaxProtocol {}


public struct GenericRequirementSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case body
    case trailingComma
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `GenericRequirementSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .genericRequirement else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `GenericRequirementSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .genericRequirement)
    self._syntaxNode = Syntax(data)
  }

  public var body: Syntax {
    get {
      let childData = data.child(at: Cursor.body, 
                                 parent: Syntax(self))
      return Syntax(childData!)
    }
    set(value) {
      self = withBody(value)
    }
  }

  /// Returns a copy of the receiver with its `body` replaced.
  /// - param newChild: The new `body` to replace the node's
  ///                   current `body`, if present.
  public func withBody(
    _ newChild: Syntax?) -> GenericRequirementSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.unknown)
    let newData = data.replacingChild(raw, at: Cursor.body)
    return GenericRequirementSyntax(newData)
  }
  public var trailingComma: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.trailingComma, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withTrailingComma(value)
    }
  }

  /// Returns a copy of the receiver with its `trailingComma` replaced.
  /// - param newChild: The new `trailingComma` to replace the node's
  ///                   current `trailingComma`, if present.
  public func withTrailingComma(
    _ newChild: TokenSyntax?) -> GenericRequirementSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.trailingComma)
    return GenericRequirementSyntax(newData)
  }

  /// Returns a new `GenericRequirementSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> GenericRequirementSyntax {
    return GenericRequirementSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `GenericRequirementSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> GenericRequirementSyntax {
    return GenericRequirementSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `GenericRequirementSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> GenericRequirementSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `GenericRequirementSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> GenericRequirementSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `GenericRequirementSyntax` with all trivia removed.
  public func withoutTrivia() -> GenericRequirementSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `GenericRequirementSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `GenericRequirementSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `SameTypeRequirementSyntax` nodes conform. Extension point to add
/// common methods to all `SameTypeRequirementSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol SameTypeRequirementSyntaxProtocol: SyntaxProtocol {}


public struct SameTypeRequirementSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case leftTypeIdentifier
    case equalityToken
    case rightTypeIdentifier
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `SameTypeRequirementSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .sameTypeRequirement else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `SameTypeRequirementSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .sameTypeRequirement)
    self._syntaxNode = Syntax(data)
  }

  public var leftTypeIdentifier: TypeSyntax {
    get {
      let childData = data.child(at: Cursor.leftTypeIdentifier, 
                                 parent: Syntax(self))
      return TypeSyntax(childData!)
    }
    set(value) {
      self = withLeftTypeIdentifier(value)
    }
  }

  /// Returns a copy of the receiver with its `leftTypeIdentifier` replaced.
  /// - param newChild: The new `leftTypeIdentifier` to replace the node's
  ///                   current `leftTypeIdentifier`, if present.
  public func withLeftTypeIdentifier(
    _ newChild: TypeSyntax?) -> SameTypeRequirementSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.type)
    let newData = data.replacingChild(raw, at: Cursor.leftTypeIdentifier)
    return SameTypeRequirementSyntax(newData)
  }
  public var equalityToken: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.equalityToken, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withEqualityToken(value)
    }
  }

  /// Returns a copy of the receiver with its `equalityToken` replaced.
  /// - param newChild: The new `equalityToken` to replace the node's
  ///                   current `equalityToken`, if present.
  public func withEqualityToken(
    _ newChild: TokenSyntax?) -> SameTypeRequirementSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.spacedBinaryOperator(""))
    let newData = data.replacingChild(raw, at: Cursor.equalityToken)
    return SameTypeRequirementSyntax(newData)
  }
  public var rightTypeIdentifier: TypeSyntax {
    get {
      let childData = data.child(at: Cursor.rightTypeIdentifier, 
                                 parent: Syntax(self))
      return TypeSyntax(childData!)
    }
    set(value) {
      self = withRightTypeIdentifier(value)
    }
  }

  /// Returns a copy of the receiver with its `rightTypeIdentifier` replaced.
  /// - param newChild: The new `rightTypeIdentifier` to replace the node's
  ///                   current `rightTypeIdentifier`, if present.
  public func withRightTypeIdentifier(
    _ newChild: TypeSyntax?) -> SameTypeRequirementSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.type)
    let newData = data.replacingChild(raw, at: Cursor.rightTypeIdentifier)
    return SameTypeRequirementSyntax(newData)
  }

  /// Returns a new `SameTypeRequirementSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> SameTypeRequirementSyntax {
    return SameTypeRequirementSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `SameTypeRequirementSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> SameTypeRequirementSyntax {
    return SameTypeRequirementSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `SameTypeRequirementSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> SameTypeRequirementSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `SameTypeRequirementSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> SameTypeRequirementSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `SameTypeRequirementSyntax` with all trivia removed.
  public func withoutTrivia() -> SameTypeRequirementSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `SameTypeRequirementSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `SameTypeRequirementSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `GenericParameterListSyntax` nodes conform. Extension point to add
/// common methods to all `GenericParameterListSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol GenericParameterListSyntaxProtocol: SyntaxProtocol {}

/// Protocol to which all `GenericParameterSyntax` nodes conform. Extension point to add
/// common methods to all `GenericParameterSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol GenericParameterSyntaxProtocol: SyntaxProtocol {}


public struct GenericParameterSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case attributes
    case name
    case colon
    case inheritedType
    case trailingComma
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `GenericParameterSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .genericParameter else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `GenericParameterSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .genericParameter)
    self._syntaxNode = Syntax(data)
  }

  public var attributes: AttributeListSyntax? {
    get {
      let childData = data.child(at: Cursor.attributes, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return AttributeListSyntax(childData!)
    }
    set(value) {
      self = withAttributes(value)
    }
  }

  /// Adds the provided `Attribute` to the node's `attributes`
  /// collection.
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  public func addAttribute(_ element: Syntax) -> GenericParameterSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.attributes] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.attributeList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.attributes)
    return GenericParameterSyntax(newData)
  }

  /// Returns a copy of the receiver with its `attributes` replaced.
  /// - param newChild: The new `attributes` to replace the node's
  ///                   current `attributes`, if present.
  public func withAttributes(
    _ newChild: AttributeListSyntax?) -> GenericParameterSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.attributes)
    return GenericParameterSyntax(newData)
  }
  public var name: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.name, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withName(value)
    }
  }

  /// Returns a copy of the receiver with its `name` replaced.
  /// - param newChild: The new `name` to replace the node's
  ///                   current `name`, if present.
  public func withName(
    _ newChild: TokenSyntax?) -> GenericParameterSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let newData = data.replacingChild(raw, at: Cursor.name)
    return GenericParameterSyntax(newData)
  }
  public var colon: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.colon, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withColon(value)
    }
  }

  /// Returns a copy of the receiver with its `colon` replaced.
  /// - param newChild: The new `colon` to replace the node's
  ///                   current `colon`, if present.
  public func withColon(
    _ newChild: TokenSyntax?) -> GenericParameterSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.colon)
    return GenericParameterSyntax(newData)
  }
  public var inheritedType: TypeSyntax? {
    get {
      let childData = data.child(at: Cursor.inheritedType, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TypeSyntax(childData!)
    }
    set(value) {
      self = withInheritedType(value)
    }
  }

  /// Returns a copy of the receiver with its `inheritedType` replaced.
  /// - param newChild: The new `inheritedType` to replace the node's
  ///                   current `inheritedType`, if present.
  public func withInheritedType(
    _ newChild: TypeSyntax?) -> GenericParameterSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.inheritedType)
    return GenericParameterSyntax(newData)
  }
  public var trailingComma: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.trailingComma, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withTrailingComma(value)
    }
  }

  /// Returns a copy of the receiver with its `trailingComma` replaced.
  /// - param newChild: The new `trailingComma` to replace the node's
  ///                   current `trailingComma`, if present.
  public func withTrailingComma(
    _ newChild: TokenSyntax?) -> GenericParameterSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.trailingComma)
    return GenericParameterSyntax(newData)
  }

  /// Returns a new `GenericParameterSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> GenericParameterSyntax {
    return GenericParameterSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `GenericParameterSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> GenericParameterSyntax {
    return GenericParameterSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `GenericParameterSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> GenericParameterSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `GenericParameterSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> GenericParameterSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `GenericParameterSyntax` with all trivia removed.
  public func withoutTrivia() -> GenericParameterSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `GenericParameterSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `GenericParameterSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `GenericParameterClauseSyntax` nodes conform. Extension point to add
/// common methods to all `GenericParameterClauseSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol GenericParameterClauseSyntaxProtocol: SyntaxProtocol {}


public struct GenericParameterClauseSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case leftAngleBracket
    case genericParameterList
    case rightAngleBracket
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `GenericParameterClauseSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .genericParameterClause else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `GenericParameterClauseSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .genericParameterClause)
    self._syntaxNode = Syntax(data)
  }

  public var leftAngleBracket: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.leftAngleBracket, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withLeftAngleBracket(value)
    }
  }

  /// Returns a copy of the receiver with its `leftAngleBracket` replaced.
  /// - param newChild: The new `leftAngleBracket` to replace the node's
  ///                   current `leftAngleBracket`, if present.
  public func withLeftAngleBracket(
    _ newChild: TokenSyntax?) -> GenericParameterClauseSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.leftAngle)
    let newData = data.replacingChild(raw, at: Cursor.leftAngleBracket)
    return GenericParameterClauseSyntax(newData)
  }
  public var genericParameterList: GenericParameterListSyntax {
    get {
      let childData = data.child(at: Cursor.genericParameterList, 
                                 parent: Syntax(self))
      return GenericParameterListSyntax(childData!)
    }
    set(value) {
      self = withGenericParameterList(value)
    }
  }

  /// Adds the provided `GenericParameter` to the node's `genericParameterList`
  /// collection.
  /// - param element: The new `GenericParameter` to add to the node's
  ///                  `genericParameterList` collection.
  /// - returns: A copy of the receiver with the provided `GenericParameter`
  ///            appended to its `genericParameterList` collection.
  public func addGenericParameter(_ element: GenericParameterSyntax) -> GenericParameterClauseSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.genericParameterList] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.genericParameterList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.genericParameterList)
    return GenericParameterClauseSyntax(newData)
  }

  /// Returns a copy of the receiver with its `genericParameterList` replaced.
  /// - param newChild: The new `genericParameterList` to replace the node's
  ///                   current `genericParameterList`, if present.
  public func withGenericParameterList(
    _ newChild: GenericParameterListSyntax?) -> GenericParameterClauseSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.genericParameterList)
    let newData = data.replacingChild(raw, at: Cursor.genericParameterList)
    return GenericParameterClauseSyntax(newData)
  }
  public var rightAngleBracket: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.rightAngleBracket, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withRightAngleBracket(value)
    }
  }

  /// Returns a copy of the receiver with its `rightAngleBracket` replaced.
  /// - param newChild: The new `rightAngleBracket` to replace the node's
  ///                   current `rightAngleBracket`, if present.
  public func withRightAngleBracket(
    _ newChild: TokenSyntax?) -> GenericParameterClauseSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.rightAngle)
    let newData = data.replacingChild(raw, at: Cursor.rightAngleBracket)
    return GenericParameterClauseSyntax(newData)
  }

  /// Returns a new `GenericParameterClauseSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> GenericParameterClauseSyntax {
    return GenericParameterClauseSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `GenericParameterClauseSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> GenericParameterClauseSyntax {
    return GenericParameterClauseSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `GenericParameterClauseSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> GenericParameterClauseSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `GenericParameterClauseSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> GenericParameterClauseSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `GenericParameterClauseSyntax` with all trivia removed.
  public func withoutTrivia() -> GenericParameterClauseSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `GenericParameterClauseSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `GenericParameterClauseSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `ConformanceRequirementSyntax` nodes conform. Extension point to add
/// common methods to all `ConformanceRequirementSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol ConformanceRequirementSyntaxProtocol: SyntaxProtocol {}


public struct ConformanceRequirementSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case leftTypeIdentifier
    case colon
    case rightTypeIdentifier
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `ConformanceRequirementSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .conformanceRequirement else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `ConformanceRequirementSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .conformanceRequirement)
    self._syntaxNode = Syntax(data)
  }

  public var leftTypeIdentifier: TypeSyntax {
    get {
      let childData = data.child(at: Cursor.leftTypeIdentifier, 
                                 parent: Syntax(self))
      return TypeSyntax(childData!)
    }
    set(value) {
      self = withLeftTypeIdentifier(value)
    }
  }

  /// Returns a copy of the receiver with its `leftTypeIdentifier` replaced.
  /// - param newChild: The new `leftTypeIdentifier` to replace the node's
  ///                   current `leftTypeIdentifier`, if present.
  public func withLeftTypeIdentifier(
    _ newChild: TypeSyntax?) -> ConformanceRequirementSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.type)
    let newData = data.replacingChild(raw, at: Cursor.leftTypeIdentifier)
    return ConformanceRequirementSyntax(newData)
  }
  public var colon: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.colon, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withColon(value)
    }
  }

  /// Returns a copy of the receiver with its `colon` replaced.
  /// - param newChild: The new `colon` to replace the node's
  ///                   current `colon`, if present.
  public func withColon(
    _ newChild: TokenSyntax?) -> ConformanceRequirementSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.colon)
    let newData = data.replacingChild(raw, at: Cursor.colon)
    return ConformanceRequirementSyntax(newData)
  }
  public var rightTypeIdentifier: TypeSyntax {
    get {
      let childData = data.child(at: Cursor.rightTypeIdentifier, 
                                 parent: Syntax(self))
      return TypeSyntax(childData!)
    }
    set(value) {
      self = withRightTypeIdentifier(value)
    }
  }

  /// Returns a copy of the receiver with its `rightTypeIdentifier` replaced.
  /// - param newChild: The new `rightTypeIdentifier` to replace the node's
  ///                   current `rightTypeIdentifier`, if present.
  public func withRightTypeIdentifier(
    _ newChild: TypeSyntax?) -> ConformanceRequirementSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.type)
    let newData = data.replacingChild(raw, at: Cursor.rightTypeIdentifier)
    return ConformanceRequirementSyntax(newData)
  }

  /// Returns a new `ConformanceRequirementSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> ConformanceRequirementSyntax {
    return ConformanceRequirementSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `ConformanceRequirementSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> ConformanceRequirementSyntax {
    return ConformanceRequirementSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `ConformanceRequirementSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> ConformanceRequirementSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `ConformanceRequirementSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> ConformanceRequirementSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `ConformanceRequirementSyntax` with all trivia removed.
  public func withoutTrivia() -> ConformanceRequirementSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `ConformanceRequirementSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `ConformanceRequirementSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `SimpleTypeIdentifierSyntax` nodes conform. Extension point to add
/// common methods to all `SimpleTypeIdentifierSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol SimpleTypeIdentifierSyntaxProtocol: TypeSyntaxProtocol {}


public struct SimpleTypeIdentifierSyntax: TypeSyntaxProtocol {
  enum Cursor: Int {
    case name
    case genericArgumentClause
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `SimpleTypeIdentifierSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .simpleTypeIdentifier else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `SimpleTypeIdentifierSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .simpleTypeIdentifier)
    self._syntaxNode = Syntax(data)
  }

  public var name: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.name, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withName(value)
    }
  }

  /// Returns a copy of the receiver with its `name` replaced.
  /// - param newChild: The new `name` to replace the node's
  ///                   current `name`, if present.
  public func withName(
    _ newChild: TokenSyntax?) -> SimpleTypeIdentifierSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let newData = data.replacingChild(raw, at: Cursor.name)
    return SimpleTypeIdentifierSyntax(newData)
  }
  public var genericArgumentClause: GenericArgumentClauseSyntax? {
    get {
      let childData = data.child(at: Cursor.genericArgumentClause, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return GenericArgumentClauseSyntax(childData!)
    }
    set(value) {
      self = withGenericArgumentClause(value)
    }
  }

  /// Returns a copy of the receiver with its `genericArgumentClause` replaced.
  /// - param newChild: The new `genericArgumentClause` to replace the node's
  ///                   current `genericArgumentClause`, if present.
  public func withGenericArgumentClause(
    _ newChild: GenericArgumentClauseSyntax?) -> SimpleTypeIdentifierSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.genericArgumentClause)
    return SimpleTypeIdentifierSyntax(newData)
  }

  /// Returns a new `SimpleTypeIdentifierSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> SimpleTypeIdentifierSyntax {
    return SimpleTypeIdentifierSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `SimpleTypeIdentifierSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> SimpleTypeIdentifierSyntax {
    return SimpleTypeIdentifierSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `SimpleTypeIdentifierSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> SimpleTypeIdentifierSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `SimpleTypeIdentifierSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> SimpleTypeIdentifierSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `SimpleTypeIdentifierSyntax` with all trivia removed.
  public func withoutTrivia() -> SimpleTypeIdentifierSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `SimpleTypeIdentifierSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `SimpleTypeIdentifierSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `MemberTypeIdentifierSyntax` nodes conform. Extension point to add
/// common methods to all `MemberTypeIdentifierSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol MemberTypeIdentifierSyntaxProtocol: TypeSyntaxProtocol {}


public struct MemberTypeIdentifierSyntax: TypeSyntaxProtocol {
  enum Cursor: Int {
    case baseType
    case period
    case name
    case genericArgumentClause
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `MemberTypeIdentifierSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .memberTypeIdentifier else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `MemberTypeIdentifierSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .memberTypeIdentifier)
    self._syntaxNode = Syntax(data)
  }

  public var baseType: TypeSyntax {
    get {
      let childData = data.child(at: Cursor.baseType, 
                                 parent: Syntax(self))
      return TypeSyntax(childData!)
    }
    set(value) {
      self = withBaseType(value)
    }
  }

  /// Returns a copy of the receiver with its `baseType` replaced.
  /// - param newChild: The new `baseType` to replace the node's
  ///                   current `baseType`, if present.
  public func withBaseType(
    _ newChild: TypeSyntax?) -> MemberTypeIdentifierSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.type)
    let newData = data.replacingChild(raw, at: Cursor.baseType)
    return MemberTypeIdentifierSyntax(newData)
  }
  public var period: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.period, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withPeriod(value)
    }
  }

  /// Returns a copy of the receiver with its `period` replaced.
  /// - param newChild: The new `period` to replace the node's
  ///                   current `period`, if present.
  public func withPeriod(
    _ newChild: TokenSyntax?) -> MemberTypeIdentifierSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.period)
    let newData = data.replacingChild(raw, at: Cursor.period)
    return MemberTypeIdentifierSyntax(newData)
  }
  public var name: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.name, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withName(value)
    }
  }

  /// Returns a copy of the receiver with its `name` replaced.
  /// - param newChild: The new `name` to replace the node's
  ///                   current `name`, if present.
  public func withName(
    _ newChild: TokenSyntax?) -> MemberTypeIdentifierSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let newData = data.replacingChild(raw, at: Cursor.name)
    return MemberTypeIdentifierSyntax(newData)
  }
  public var genericArgumentClause: GenericArgumentClauseSyntax? {
    get {
      let childData = data.child(at: Cursor.genericArgumentClause, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return GenericArgumentClauseSyntax(childData!)
    }
    set(value) {
      self = withGenericArgumentClause(value)
    }
  }

  /// Returns a copy of the receiver with its `genericArgumentClause` replaced.
  /// - param newChild: The new `genericArgumentClause` to replace the node's
  ///                   current `genericArgumentClause`, if present.
  public func withGenericArgumentClause(
    _ newChild: GenericArgumentClauseSyntax?) -> MemberTypeIdentifierSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.genericArgumentClause)
    return MemberTypeIdentifierSyntax(newData)
  }

  /// Returns a new `MemberTypeIdentifierSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> MemberTypeIdentifierSyntax {
    return MemberTypeIdentifierSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `MemberTypeIdentifierSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> MemberTypeIdentifierSyntax {
    return MemberTypeIdentifierSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `MemberTypeIdentifierSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> MemberTypeIdentifierSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `MemberTypeIdentifierSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> MemberTypeIdentifierSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `MemberTypeIdentifierSyntax` with all trivia removed.
  public func withoutTrivia() -> MemberTypeIdentifierSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `MemberTypeIdentifierSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `MemberTypeIdentifierSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `ClassRestrictionTypeSyntax` nodes conform. Extension point to add
/// common methods to all `ClassRestrictionTypeSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol ClassRestrictionTypeSyntaxProtocol: TypeSyntaxProtocol {}


public struct ClassRestrictionTypeSyntax: TypeSyntaxProtocol {
  enum Cursor: Int {
    case classKeyword
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `ClassRestrictionTypeSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .classRestrictionType else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `ClassRestrictionTypeSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .classRestrictionType)
    self._syntaxNode = Syntax(data)
  }

  public var classKeyword: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.classKeyword, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withClassKeyword(value)
    }
  }

  /// Returns a copy of the receiver with its `classKeyword` replaced.
  /// - param newChild: The new `classKeyword` to replace the node's
  ///                   current `classKeyword`, if present.
  public func withClassKeyword(
    _ newChild: TokenSyntax?) -> ClassRestrictionTypeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.classKeyword)
    let newData = data.replacingChild(raw, at: Cursor.classKeyword)
    return ClassRestrictionTypeSyntax(newData)
  }

  /// Returns a new `ClassRestrictionTypeSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> ClassRestrictionTypeSyntax {
    return ClassRestrictionTypeSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `ClassRestrictionTypeSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> ClassRestrictionTypeSyntax {
    return ClassRestrictionTypeSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `ClassRestrictionTypeSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> ClassRestrictionTypeSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `ClassRestrictionTypeSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> ClassRestrictionTypeSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `ClassRestrictionTypeSyntax` with all trivia removed.
  public func withoutTrivia() -> ClassRestrictionTypeSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `ClassRestrictionTypeSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `ClassRestrictionTypeSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `ArrayTypeSyntax` nodes conform. Extension point to add
/// common methods to all `ArrayTypeSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol ArrayTypeSyntaxProtocol: TypeSyntaxProtocol {}


public struct ArrayTypeSyntax: TypeSyntaxProtocol {
  enum Cursor: Int {
    case leftSquareBracket
    case elementType
    case rightSquareBracket
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `ArrayTypeSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .arrayType else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `ArrayTypeSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .arrayType)
    self._syntaxNode = Syntax(data)
  }

  public var leftSquareBracket: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.leftSquareBracket, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withLeftSquareBracket(value)
    }
  }

  /// Returns a copy of the receiver with its `leftSquareBracket` replaced.
  /// - param newChild: The new `leftSquareBracket` to replace the node's
  ///                   current `leftSquareBracket`, if present.
  public func withLeftSquareBracket(
    _ newChild: TokenSyntax?) -> ArrayTypeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.leftSquareBracket)
    let newData = data.replacingChild(raw, at: Cursor.leftSquareBracket)
    return ArrayTypeSyntax(newData)
  }
  public var elementType: TypeSyntax {
    get {
      let childData = data.child(at: Cursor.elementType, 
                                 parent: Syntax(self))
      return TypeSyntax(childData!)
    }
    set(value) {
      self = withElementType(value)
    }
  }

  /// Returns a copy of the receiver with its `elementType` replaced.
  /// - param newChild: The new `elementType` to replace the node's
  ///                   current `elementType`, if present.
  public func withElementType(
    _ newChild: TypeSyntax?) -> ArrayTypeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.type)
    let newData = data.replacingChild(raw, at: Cursor.elementType)
    return ArrayTypeSyntax(newData)
  }
  public var rightSquareBracket: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.rightSquareBracket, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withRightSquareBracket(value)
    }
  }

  /// Returns a copy of the receiver with its `rightSquareBracket` replaced.
  /// - param newChild: The new `rightSquareBracket` to replace the node's
  ///                   current `rightSquareBracket`, if present.
  public func withRightSquareBracket(
    _ newChild: TokenSyntax?) -> ArrayTypeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.rightSquareBracket)
    let newData = data.replacingChild(raw, at: Cursor.rightSquareBracket)
    return ArrayTypeSyntax(newData)
  }

  /// Returns a new `ArrayTypeSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> ArrayTypeSyntax {
    return ArrayTypeSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `ArrayTypeSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> ArrayTypeSyntax {
    return ArrayTypeSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `ArrayTypeSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> ArrayTypeSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `ArrayTypeSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> ArrayTypeSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `ArrayTypeSyntax` with all trivia removed.
  public func withoutTrivia() -> ArrayTypeSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `ArrayTypeSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `ArrayTypeSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `DictionaryTypeSyntax` nodes conform. Extension point to add
/// common methods to all `DictionaryTypeSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol DictionaryTypeSyntaxProtocol: TypeSyntaxProtocol {}


public struct DictionaryTypeSyntax: TypeSyntaxProtocol {
  enum Cursor: Int {
    case leftSquareBracket
    case keyType
    case colon
    case valueType
    case rightSquareBracket
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `DictionaryTypeSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .dictionaryType else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `DictionaryTypeSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .dictionaryType)
    self._syntaxNode = Syntax(data)
  }

  public var leftSquareBracket: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.leftSquareBracket, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withLeftSquareBracket(value)
    }
  }

  /// Returns a copy of the receiver with its `leftSquareBracket` replaced.
  /// - param newChild: The new `leftSquareBracket` to replace the node's
  ///                   current `leftSquareBracket`, if present.
  public func withLeftSquareBracket(
    _ newChild: TokenSyntax?) -> DictionaryTypeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.leftSquareBracket)
    let newData = data.replacingChild(raw, at: Cursor.leftSquareBracket)
    return DictionaryTypeSyntax(newData)
  }
  public var keyType: TypeSyntax {
    get {
      let childData = data.child(at: Cursor.keyType, 
                                 parent: Syntax(self))
      return TypeSyntax(childData!)
    }
    set(value) {
      self = withKeyType(value)
    }
  }

  /// Returns a copy of the receiver with its `keyType` replaced.
  /// - param newChild: The new `keyType` to replace the node's
  ///                   current `keyType`, if present.
  public func withKeyType(
    _ newChild: TypeSyntax?) -> DictionaryTypeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.type)
    let newData = data.replacingChild(raw, at: Cursor.keyType)
    return DictionaryTypeSyntax(newData)
  }
  public var colon: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.colon, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withColon(value)
    }
  }

  /// Returns a copy of the receiver with its `colon` replaced.
  /// - param newChild: The new `colon` to replace the node's
  ///                   current `colon`, if present.
  public func withColon(
    _ newChild: TokenSyntax?) -> DictionaryTypeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.colon)
    let newData = data.replacingChild(raw, at: Cursor.colon)
    return DictionaryTypeSyntax(newData)
  }
  public var valueType: TypeSyntax {
    get {
      let childData = data.child(at: Cursor.valueType, 
                                 parent: Syntax(self))
      return TypeSyntax(childData!)
    }
    set(value) {
      self = withValueType(value)
    }
  }

  /// Returns a copy of the receiver with its `valueType` replaced.
  /// - param newChild: The new `valueType` to replace the node's
  ///                   current `valueType`, if present.
  public func withValueType(
    _ newChild: TypeSyntax?) -> DictionaryTypeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.type)
    let newData = data.replacingChild(raw, at: Cursor.valueType)
    return DictionaryTypeSyntax(newData)
  }
  public var rightSquareBracket: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.rightSquareBracket, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withRightSquareBracket(value)
    }
  }

  /// Returns a copy of the receiver with its `rightSquareBracket` replaced.
  /// - param newChild: The new `rightSquareBracket` to replace the node's
  ///                   current `rightSquareBracket`, if present.
  public func withRightSquareBracket(
    _ newChild: TokenSyntax?) -> DictionaryTypeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.rightSquareBracket)
    let newData = data.replacingChild(raw, at: Cursor.rightSquareBracket)
    return DictionaryTypeSyntax(newData)
  }

  /// Returns a new `DictionaryTypeSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> DictionaryTypeSyntax {
    return DictionaryTypeSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `DictionaryTypeSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> DictionaryTypeSyntax {
    return DictionaryTypeSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `DictionaryTypeSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> DictionaryTypeSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `DictionaryTypeSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> DictionaryTypeSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `DictionaryTypeSyntax` with all trivia removed.
  public func withoutTrivia() -> DictionaryTypeSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `DictionaryTypeSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `DictionaryTypeSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `MetatypeTypeSyntax` nodes conform. Extension point to add
/// common methods to all `MetatypeTypeSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol MetatypeTypeSyntaxProtocol: TypeSyntaxProtocol {}


public struct MetatypeTypeSyntax: TypeSyntaxProtocol {
  enum Cursor: Int {
    case baseType
    case period
    case typeOrProtocol
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `MetatypeTypeSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .metatypeType else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `MetatypeTypeSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .metatypeType)
    self._syntaxNode = Syntax(data)
  }

  public var baseType: TypeSyntax {
    get {
      let childData = data.child(at: Cursor.baseType, 
                                 parent: Syntax(self))
      return TypeSyntax(childData!)
    }
    set(value) {
      self = withBaseType(value)
    }
  }

  /// Returns a copy of the receiver with its `baseType` replaced.
  /// - param newChild: The new `baseType` to replace the node's
  ///                   current `baseType`, if present.
  public func withBaseType(
    _ newChild: TypeSyntax?) -> MetatypeTypeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.type)
    let newData = data.replacingChild(raw, at: Cursor.baseType)
    return MetatypeTypeSyntax(newData)
  }
  public var period: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.period, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withPeriod(value)
    }
  }

  /// Returns a copy of the receiver with its `period` replaced.
  /// - param newChild: The new `period` to replace the node's
  ///                   current `period`, if present.
  public func withPeriod(
    _ newChild: TokenSyntax?) -> MetatypeTypeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.period)
    let newData = data.replacingChild(raw, at: Cursor.period)
    return MetatypeTypeSyntax(newData)
  }
  public var typeOrProtocol: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.typeOrProtocol, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withTypeOrProtocol(value)
    }
  }

  /// Returns a copy of the receiver with its `typeOrProtocol` replaced.
  /// - param newChild: The new `typeOrProtocol` to replace the node's
  ///                   current `typeOrProtocol`, if present.
  public func withTypeOrProtocol(
    _ newChild: TokenSyntax?) -> MetatypeTypeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let newData = data.replacingChild(raw, at: Cursor.typeOrProtocol)
    return MetatypeTypeSyntax(newData)
  }

  /// Returns a new `MetatypeTypeSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> MetatypeTypeSyntax {
    return MetatypeTypeSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `MetatypeTypeSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> MetatypeTypeSyntax {
    return MetatypeTypeSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `MetatypeTypeSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> MetatypeTypeSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `MetatypeTypeSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> MetatypeTypeSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `MetatypeTypeSyntax` with all trivia removed.
  public func withoutTrivia() -> MetatypeTypeSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `MetatypeTypeSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `MetatypeTypeSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `OptionalTypeSyntax` nodes conform. Extension point to add
/// common methods to all `OptionalTypeSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol OptionalTypeSyntaxProtocol: TypeSyntaxProtocol {}


public struct OptionalTypeSyntax: TypeSyntaxProtocol {
  enum Cursor: Int {
    case wrappedType
    case questionMark
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `OptionalTypeSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .optionalType else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `OptionalTypeSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .optionalType)
    self._syntaxNode = Syntax(data)
  }

  public var wrappedType: TypeSyntax {
    get {
      let childData = data.child(at: Cursor.wrappedType, 
                                 parent: Syntax(self))
      return TypeSyntax(childData!)
    }
    set(value) {
      self = withWrappedType(value)
    }
  }

  /// Returns a copy of the receiver with its `wrappedType` replaced.
  /// - param newChild: The new `wrappedType` to replace the node's
  ///                   current `wrappedType`, if present.
  public func withWrappedType(
    _ newChild: TypeSyntax?) -> OptionalTypeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.type)
    let newData = data.replacingChild(raw, at: Cursor.wrappedType)
    return OptionalTypeSyntax(newData)
  }
  public var questionMark: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.questionMark, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withQuestionMark(value)
    }
  }

  /// Returns a copy of the receiver with its `questionMark` replaced.
  /// - param newChild: The new `questionMark` to replace the node's
  ///                   current `questionMark`, if present.
  public func withQuestionMark(
    _ newChild: TokenSyntax?) -> OptionalTypeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.postfixQuestionMark)
    let newData = data.replacingChild(raw, at: Cursor.questionMark)
    return OptionalTypeSyntax(newData)
  }

  /// Returns a new `OptionalTypeSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> OptionalTypeSyntax {
    return OptionalTypeSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `OptionalTypeSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> OptionalTypeSyntax {
    return OptionalTypeSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `OptionalTypeSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> OptionalTypeSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `OptionalTypeSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> OptionalTypeSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `OptionalTypeSyntax` with all trivia removed.
  public func withoutTrivia() -> OptionalTypeSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `OptionalTypeSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `OptionalTypeSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `SomeTypeSyntax` nodes conform. Extension point to add
/// common methods to all `SomeTypeSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol SomeTypeSyntaxProtocol: TypeSyntaxProtocol {}


public struct SomeTypeSyntax: TypeSyntaxProtocol {
  enum Cursor: Int {
    case someSpecifier
    case baseType
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `SomeTypeSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .someType else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `SomeTypeSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .someType)
    self._syntaxNode = Syntax(data)
  }

  public var someSpecifier: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.someSpecifier, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withSomeSpecifier(value)
    }
  }

  /// Returns a copy of the receiver with its `someSpecifier` replaced.
  /// - param newChild: The new `someSpecifier` to replace the node's
  ///                   current `someSpecifier`, if present.
  public func withSomeSpecifier(
    _ newChild: TokenSyntax?) -> SomeTypeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let newData = data.replacingChild(raw, at: Cursor.someSpecifier)
    return SomeTypeSyntax(newData)
  }
  public var baseType: TypeSyntax {
    get {
      let childData = data.child(at: Cursor.baseType, 
                                 parent: Syntax(self))
      return TypeSyntax(childData!)
    }
    set(value) {
      self = withBaseType(value)
    }
  }

  /// Returns a copy of the receiver with its `baseType` replaced.
  /// - param newChild: The new `baseType` to replace the node's
  ///                   current `baseType`, if present.
  public func withBaseType(
    _ newChild: TypeSyntax?) -> SomeTypeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.type)
    let newData = data.replacingChild(raw, at: Cursor.baseType)
    return SomeTypeSyntax(newData)
  }

  /// Returns a new `SomeTypeSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> SomeTypeSyntax {
    return SomeTypeSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `SomeTypeSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> SomeTypeSyntax {
    return SomeTypeSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `SomeTypeSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> SomeTypeSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `SomeTypeSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> SomeTypeSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `SomeTypeSyntax` with all trivia removed.
  public func withoutTrivia() -> SomeTypeSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `SomeTypeSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `SomeTypeSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `ImplicitlyUnwrappedOptionalTypeSyntax` nodes conform. Extension point to add
/// common methods to all `ImplicitlyUnwrappedOptionalTypeSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol ImplicitlyUnwrappedOptionalTypeSyntaxProtocol: TypeSyntaxProtocol {}


public struct ImplicitlyUnwrappedOptionalTypeSyntax: TypeSyntaxProtocol {
  enum Cursor: Int {
    case wrappedType
    case exclamationMark
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `ImplicitlyUnwrappedOptionalTypeSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .implicitlyUnwrappedOptionalType else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `ImplicitlyUnwrappedOptionalTypeSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .implicitlyUnwrappedOptionalType)
    self._syntaxNode = Syntax(data)
  }

  public var wrappedType: TypeSyntax {
    get {
      let childData = data.child(at: Cursor.wrappedType, 
                                 parent: Syntax(self))
      return TypeSyntax(childData!)
    }
    set(value) {
      self = withWrappedType(value)
    }
  }

  /// Returns a copy of the receiver with its `wrappedType` replaced.
  /// - param newChild: The new `wrappedType` to replace the node's
  ///                   current `wrappedType`, if present.
  public func withWrappedType(
    _ newChild: TypeSyntax?) -> ImplicitlyUnwrappedOptionalTypeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.type)
    let newData = data.replacingChild(raw, at: Cursor.wrappedType)
    return ImplicitlyUnwrappedOptionalTypeSyntax(newData)
  }
  public var exclamationMark: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.exclamationMark, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withExclamationMark(value)
    }
  }

  /// Returns a copy of the receiver with its `exclamationMark` replaced.
  /// - param newChild: The new `exclamationMark` to replace the node's
  ///                   current `exclamationMark`, if present.
  public func withExclamationMark(
    _ newChild: TokenSyntax?) -> ImplicitlyUnwrappedOptionalTypeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.exclamationMark)
    let newData = data.replacingChild(raw, at: Cursor.exclamationMark)
    return ImplicitlyUnwrappedOptionalTypeSyntax(newData)
  }

  /// Returns a new `ImplicitlyUnwrappedOptionalTypeSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> ImplicitlyUnwrappedOptionalTypeSyntax {
    return ImplicitlyUnwrappedOptionalTypeSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `ImplicitlyUnwrappedOptionalTypeSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> ImplicitlyUnwrappedOptionalTypeSyntax {
    return ImplicitlyUnwrappedOptionalTypeSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `ImplicitlyUnwrappedOptionalTypeSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> ImplicitlyUnwrappedOptionalTypeSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `ImplicitlyUnwrappedOptionalTypeSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> ImplicitlyUnwrappedOptionalTypeSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `ImplicitlyUnwrappedOptionalTypeSyntax` with all trivia removed.
  public func withoutTrivia() -> ImplicitlyUnwrappedOptionalTypeSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `ImplicitlyUnwrappedOptionalTypeSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `ImplicitlyUnwrappedOptionalTypeSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `CompositionTypeElementSyntax` nodes conform. Extension point to add
/// common methods to all `CompositionTypeElementSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol CompositionTypeElementSyntaxProtocol: SyntaxProtocol {}


public struct CompositionTypeElementSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case type
    case ampersand
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `CompositionTypeElementSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .compositionTypeElement else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `CompositionTypeElementSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .compositionTypeElement)
    self._syntaxNode = Syntax(data)
  }

  public var type: TypeSyntax {
    get {
      let childData = data.child(at: Cursor.type, 
                                 parent: Syntax(self))
      return TypeSyntax(childData!)
    }
    set(value) {
      self = withType(value)
    }
  }

  /// Returns a copy of the receiver with its `type` replaced.
  /// - param newChild: The new `type` to replace the node's
  ///                   current `type`, if present.
  public func withType(
    _ newChild: TypeSyntax?) -> CompositionTypeElementSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.type)
    let newData = data.replacingChild(raw, at: Cursor.type)
    return CompositionTypeElementSyntax(newData)
  }
  public var ampersand: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.ampersand, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withAmpersand(value)
    }
  }

  /// Returns a copy of the receiver with its `ampersand` replaced.
  /// - param newChild: The new `ampersand` to replace the node's
  ///                   current `ampersand`, if present.
  public func withAmpersand(
    _ newChild: TokenSyntax?) -> CompositionTypeElementSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.ampersand)
    return CompositionTypeElementSyntax(newData)
  }

  /// Returns a new `CompositionTypeElementSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> CompositionTypeElementSyntax {
    return CompositionTypeElementSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `CompositionTypeElementSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> CompositionTypeElementSyntax {
    return CompositionTypeElementSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `CompositionTypeElementSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> CompositionTypeElementSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `CompositionTypeElementSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> CompositionTypeElementSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `CompositionTypeElementSyntax` with all trivia removed.
  public func withoutTrivia() -> CompositionTypeElementSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `CompositionTypeElementSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `CompositionTypeElementSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `CompositionTypeElementListSyntax` nodes conform. Extension point to add
/// common methods to all `CompositionTypeElementListSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol CompositionTypeElementListSyntaxProtocol: SyntaxProtocol {}

/// Protocol to which all `CompositionTypeSyntax` nodes conform. Extension point to add
/// common methods to all `CompositionTypeSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol CompositionTypeSyntaxProtocol: TypeSyntaxProtocol {}


public struct CompositionTypeSyntax: TypeSyntaxProtocol {
  enum Cursor: Int {
    case elements
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `CompositionTypeSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .compositionType else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `CompositionTypeSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .compositionType)
    self._syntaxNode = Syntax(data)
  }

  public var elements: CompositionTypeElementListSyntax {
    get {
      let childData = data.child(at: Cursor.elements, 
                                 parent: Syntax(self))
      return CompositionTypeElementListSyntax(childData!)
    }
    set(value) {
      self = withElements(value)
    }
  }

  /// Adds the provided `Element` to the node's `elements`
  /// collection.
  /// - param element: The new `Element` to add to the node's
  ///                  `elements` collection.
  /// - returns: A copy of the receiver with the provided `Element`
  ///            appended to its `elements` collection.
  public func addElement(_ element: CompositionTypeElementSyntax) -> CompositionTypeSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.elements] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.compositionTypeElementList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.elements)
    return CompositionTypeSyntax(newData)
  }

  /// Returns a copy of the receiver with its `elements` replaced.
  /// - param newChild: The new `elements` to replace the node's
  ///                   current `elements`, if present.
  public func withElements(
    _ newChild: CompositionTypeElementListSyntax?) -> CompositionTypeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.compositionTypeElementList)
    let newData = data.replacingChild(raw, at: Cursor.elements)
    return CompositionTypeSyntax(newData)
  }

  /// Returns a new `CompositionTypeSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> CompositionTypeSyntax {
    return CompositionTypeSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `CompositionTypeSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> CompositionTypeSyntax {
    return CompositionTypeSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `CompositionTypeSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> CompositionTypeSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `CompositionTypeSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> CompositionTypeSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `CompositionTypeSyntax` with all trivia removed.
  public func withoutTrivia() -> CompositionTypeSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `CompositionTypeSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `CompositionTypeSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `TupleTypeElementSyntax` nodes conform. Extension point to add
/// common methods to all `TupleTypeElementSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol TupleTypeElementSyntaxProtocol: SyntaxProtocol {}


public struct TupleTypeElementSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case inOut
    case name
    case secondName
    case colon
    case type
    case ellipsis
    case initializer
    case trailingComma
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `TupleTypeElementSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .tupleTypeElement else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `TupleTypeElementSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .tupleTypeElement)
    self._syntaxNode = Syntax(data)
  }

  public var inOut: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.inOut, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withInOut(value)
    }
  }

  /// Returns a copy of the receiver with its `inOut` replaced.
  /// - param newChild: The new `inOut` to replace the node's
  ///                   current `inOut`, if present.
  public func withInOut(
    _ newChild: TokenSyntax?) -> TupleTypeElementSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.inOut)
    return TupleTypeElementSyntax(newData)
  }
  public var name: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.name, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withName(value)
    }
  }

  /// Returns a copy of the receiver with its `name` replaced.
  /// - param newChild: The new `name` to replace the node's
  ///                   current `name`, if present.
  public func withName(
    _ newChild: TokenSyntax?) -> TupleTypeElementSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.name)
    return TupleTypeElementSyntax(newData)
  }
  public var secondName: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.secondName, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withSecondName(value)
    }
  }

  /// Returns a copy of the receiver with its `secondName` replaced.
  /// - param newChild: The new `secondName` to replace the node's
  ///                   current `secondName`, if present.
  public func withSecondName(
    _ newChild: TokenSyntax?) -> TupleTypeElementSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.secondName)
    return TupleTypeElementSyntax(newData)
  }
  public var colon: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.colon, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withColon(value)
    }
  }

  /// Returns a copy of the receiver with its `colon` replaced.
  /// - param newChild: The new `colon` to replace the node's
  ///                   current `colon`, if present.
  public func withColon(
    _ newChild: TokenSyntax?) -> TupleTypeElementSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.colon)
    return TupleTypeElementSyntax(newData)
  }
  public var type: TypeSyntax {
    get {
      let childData = data.child(at: Cursor.type, 
                                 parent: Syntax(self))
      return TypeSyntax(childData!)
    }
    set(value) {
      self = withType(value)
    }
  }

  /// Returns a copy of the receiver with its `type` replaced.
  /// - param newChild: The new `type` to replace the node's
  ///                   current `type`, if present.
  public func withType(
    _ newChild: TypeSyntax?) -> TupleTypeElementSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.type)
    let newData = data.replacingChild(raw, at: Cursor.type)
    return TupleTypeElementSyntax(newData)
  }
  public var ellipsis: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.ellipsis, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withEllipsis(value)
    }
  }

  /// Returns a copy of the receiver with its `ellipsis` replaced.
  /// - param newChild: The new `ellipsis` to replace the node's
  ///                   current `ellipsis`, if present.
  public func withEllipsis(
    _ newChild: TokenSyntax?) -> TupleTypeElementSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.ellipsis)
    return TupleTypeElementSyntax(newData)
  }
  public var initializer: InitializerClauseSyntax? {
    get {
      let childData = data.child(at: Cursor.initializer, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return InitializerClauseSyntax(childData!)
    }
    set(value) {
      self = withInitializer(value)
    }
  }

  /// Returns a copy of the receiver with its `initializer` replaced.
  /// - param newChild: The new `initializer` to replace the node's
  ///                   current `initializer`, if present.
  public func withInitializer(
    _ newChild: InitializerClauseSyntax?) -> TupleTypeElementSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.initializer)
    return TupleTypeElementSyntax(newData)
  }
  public var trailingComma: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.trailingComma, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withTrailingComma(value)
    }
  }

  /// Returns a copy of the receiver with its `trailingComma` replaced.
  /// - param newChild: The new `trailingComma` to replace the node's
  ///                   current `trailingComma`, if present.
  public func withTrailingComma(
    _ newChild: TokenSyntax?) -> TupleTypeElementSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.trailingComma)
    return TupleTypeElementSyntax(newData)
  }

  /// Returns a new `TupleTypeElementSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> TupleTypeElementSyntax {
    return TupleTypeElementSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `TupleTypeElementSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> TupleTypeElementSyntax {
    return TupleTypeElementSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `TupleTypeElementSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> TupleTypeElementSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `TupleTypeElementSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> TupleTypeElementSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `TupleTypeElementSyntax` with all trivia removed.
  public func withoutTrivia() -> TupleTypeElementSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `TupleTypeElementSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `TupleTypeElementSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `TupleTypeElementListSyntax` nodes conform. Extension point to add
/// common methods to all `TupleTypeElementListSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol TupleTypeElementListSyntaxProtocol: SyntaxProtocol {}

/// Protocol to which all `TupleTypeSyntax` nodes conform. Extension point to add
/// common methods to all `TupleTypeSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol TupleTypeSyntaxProtocol: TypeSyntaxProtocol {}


public struct TupleTypeSyntax: TypeSyntaxProtocol {
  enum Cursor: Int {
    case leftParen
    case elements
    case rightParen
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `TupleTypeSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .tupleType else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `TupleTypeSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .tupleType)
    self._syntaxNode = Syntax(data)
  }

  public var leftParen: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.leftParen, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withLeftParen(value)
    }
  }

  /// Returns a copy of the receiver with its `leftParen` replaced.
  /// - param newChild: The new `leftParen` to replace the node's
  ///                   current `leftParen`, if present.
  public func withLeftParen(
    _ newChild: TokenSyntax?) -> TupleTypeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.leftParen)
    let newData = data.replacingChild(raw, at: Cursor.leftParen)
    return TupleTypeSyntax(newData)
  }
  public var elements: TupleTypeElementListSyntax {
    get {
      let childData = data.child(at: Cursor.elements, 
                                 parent: Syntax(self))
      return TupleTypeElementListSyntax(childData!)
    }
    set(value) {
      self = withElements(value)
    }
  }

  /// Adds the provided `Element` to the node's `elements`
  /// collection.
  /// - param element: The new `Element` to add to the node's
  ///                  `elements` collection.
  /// - returns: A copy of the receiver with the provided `Element`
  ///            appended to its `elements` collection.
  public func addElement(_ element: TupleTypeElementSyntax) -> TupleTypeSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.elements] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.tupleTypeElementList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.elements)
    return TupleTypeSyntax(newData)
  }

  /// Returns a copy of the receiver with its `elements` replaced.
  /// - param newChild: The new `elements` to replace the node's
  ///                   current `elements`, if present.
  public func withElements(
    _ newChild: TupleTypeElementListSyntax?) -> TupleTypeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.tupleTypeElementList)
    let newData = data.replacingChild(raw, at: Cursor.elements)
    return TupleTypeSyntax(newData)
  }
  public var rightParen: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.rightParen, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withRightParen(value)
    }
  }

  /// Returns a copy of the receiver with its `rightParen` replaced.
  /// - param newChild: The new `rightParen` to replace the node's
  ///                   current `rightParen`, if present.
  public func withRightParen(
    _ newChild: TokenSyntax?) -> TupleTypeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.rightParen)
    let newData = data.replacingChild(raw, at: Cursor.rightParen)
    return TupleTypeSyntax(newData)
  }

  /// Returns a new `TupleTypeSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> TupleTypeSyntax {
    return TupleTypeSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `TupleTypeSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> TupleTypeSyntax {
    return TupleTypeSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `TupleTypeSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> TupleTypeSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `TupleTypeSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> TupleTypeSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `TupleTypeSyntax` with all trivia removed.
  public func withoutTrivia() -> TupleTypeSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `TupleTypeSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `TupleTypeSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `FunctionTypeSyntax` nodes conform. Extension point to add
/// common methods to all `FunctionTypeSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol FunctionTypeSyntaxProtocol: TypeSyntaxProtocol {}


public struct FunctionTypeSyntax: TypeSyntaxProtocol {
  enum Cursor: Int {
    case leftParen
    case arguments
    case rightParen
    case throwsOrRethrowsKeyword
    case arrow
    case returnType
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `FunctionTypeSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .functionType else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `FunctionTypeSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .functionType)
    self._syntaxNode = Syntax(data)
  }

  public var leftParen: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.leftParen, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withLeftParen(value)
    }
  }

  /// Returns a copy of the receiver with its `leftParen` replaced.
  /// - param newChild: The new `leftParen` to replace the node's
  ///                   current `leftParen`, if present.
  public func withLeftParen(
    _ newChild: TokenSyntax?) -> FunctionTypeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.leftParen)
    let newData = data.replacingChild(raw, at: Cursor.leftParen)
    return FunctionTypeSyntax(newData)
  }
  public var arguments: TupleTypeElementListSyntax {
    get {
      let childData = data.child(at: Cursor.arguments, 
                                 parent: Syntax(self))
      return TupleTypeElementListSyntax(childData!)
    }
    set(value) {
      self = withArguments(value)
    }
  }

  /// Adds the provided `Argument` to the node's `arguments`
  /// collection.
  /// - param element: The new `Argument` to add to the node's
  ///                  `arguments` collection.
  /// - returns: A copy of the receiver with the provided `Argument`
  ///            appended to its `arguments` collection.
  public func addArgument(_ element: TupleTypeElementSyntax) -> FunctionTypeSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.arguments] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.tupleTypeElementList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.arguments)
    return FunctionTypeSyntax(newData)
  }

  /// Returns a copy of the receiver with its `arguments` replaced.
  /// - param newChild: The new `arguments` to replace the node's
  ///                   current `arguments`, if present.
  public func withArguments(
    _ newChild: TupleTypeElementListSyntax?) -> FunctionTypeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.tupleTypeElementList)
    let newData = data.replacingChild(raw, at: Cursor.arguments)
    return FunctionTypeSyntax(newData)
  }
  public var rightParen: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.rightParen, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withRightParen(value)
    }
  }

  /// Returns a copy of the receiver with its `rightParen` replaced.
  /// - param newChild: The new `rightParen` to replace the node's
  ///                   current `rightParen`, if present.
  public func withRightParen(
    _ newChild: TokenSyntax?) -> FunctionTypeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.rightParen)
    let newData = data.replacingChild(raw, at: Cursor.rightParen)
    return FunctionTypeSyntax(newData)
  }
  public var throwsOrRethrowsKeyword: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.throwsOrRethrowsKeyword, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withThrowsOrRethrowsKeyword(value)
    }
  }

  /// Returns a copy of the receiver with its `throwsOrRethrowsKeyword` replaced.
  /// - param newChild: The new `throwsOrRethrowsKeyword` to replace the node's
  ///                   current `throwsOrRethrowsKeyword`, if present.
  public func withThrowsOrRethrowsKeyword(
    _ newChild: TokenSyntax?) -> FunctionTypeSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.throwsOrRethrowsKeyword)
    return FunctionTypeSyntax(newData)
  }
  public var arrow: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.arrow, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withArrow(value)
    }
  }

  /// Returns a copy of the receiver with its `arrow` replaced.
  /// - param newChild: The new `arrow` to replace the node's
  ///                   current `arrow`, if present.
  public func withArrow(
    _ newChild: TokenSyntax?) -> FunctionTypeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.arrow)
    let newData = data.replacingChild(raw, at: Cursor.arrow)
    return FunctionTypeSyntax(newData)
  }
  public var returnType: TypeSyntax {
    get {
      let childData = data.child(at: Cursor.returnType, 
                                 parent: Syntax(self))
      return TypeSyntax(childData!)
    }
    set(value) {
      self = withReturnType(value)
    }
  }

  /// Returns a copy of the receiver with its `returnType` replaced.
  /// - param newChild: The new `returnType` to replace the node's
  ///                   current `returnType`, if present.
  public func withReturnType(
    _ newChild: TypeSyntax?) -> FunctionTypeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.type)
    let newData = data.replacingChild(raw, at: Cursor.returnType)
    return FunctionTypeSyntax(newData)
  }

  /// Returns a new `FunctionTypeSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> FunctionTypeSyntax {
    return FunctionTypeSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `FunctionTypeSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> FunctionTypeSyntax {
    return FunctionTypeSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `FunctionTypeSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> FunctionTypeSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `FunctionTypeSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> FunctionTypeSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `FunctionTypeSyntax` with all trivia removed.
  public func withoutTrivia() -> FunctionTypeSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `FunctionTypeSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `FunctionTypeSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `AttributedTypeSyntax` nodes conform. Extension point to add
/// common methods to all `AttributedTypeSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol AttributedTypeSyntaxProtocol: TypeSyntaxProtocol {}


public struct AttributedTypeSyntax: TypeSyntaxProtocol {
  enum Cursor: Int {
    case specifier
    case attributes
    case baseType
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `AttributedTypeSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .attributedType else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `AttributedTypeSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .attributedType)
    self._syntaxNode = Syntax(data)
  }

  public var specifier: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.specifier, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withSpecifier(value)
    }
  }

  /// Returns a copy of the receiver with its `specifier` replaced.
  /// - param newChild: The new `specifier` to replace the node's
  ///                   current `specifier`, if present.
  public func withSpecifier(
    _ newChild: TokenSyntax?) -> AttributedTypeSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.specifier)
    return AttributedTypeSyntax(newData)
  }
  public var attributes: AttributeListSyntax? {
    get {
      let childData = data.child(at: Cursor.attributes, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return AttributeListSyntax(childData!)
    }
    set(value) {
      self = withAttributes(value)
    }
  }

  /// Adds the provided `Attribute` to the node's `attributes`
  /// collection.
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  public func addAttribute(_ element: Syntax) -> AttributedTypeSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.attributes] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.attributeList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.attributes)
    return AttributedTypeSyntax(newData)
  }

  /// Returns a copy of the receiver with its `attributes` replaced.
  /// - param newChild: The new `attributes` to replace the node's
  ///                   current `attributes`, if present.
  public func withAttributes(
    _ newChild: AttributeListSyntax?) -> AttributedTypeSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.attributes)
    return AttributedTypeSyntax(newData)
  }
  public var baseType: TypeSyntax {
    get {
      let childData = data.child(at: Cursor.baseType, 
                                 parent: Syntax(self))
      return TypeSyntax(childData!)
    }
    set(value) {
      self = withBaseType(value)
    }
  }

  /// Returns a copy of the receiver with its `baseType` replaced.
  /// - param newChild: The new `baseType` to replace the node's
  ///                   current `baseType`, if present.
  public func withBaseType(
    _ newChild: TypeSyntax?) -> AttributedTypeSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.type)
    let newData = data.replacingChild(raw, at: Cursor.baseType)
    return AttributedTypeSyntax(newData)
  }

  /// Returns a new `AttributedTypeSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> AttributedTypeSyntax {
    return AttributedTypeSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `AttributedTypeSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> AttributedTypeSyntax {
    return AttributedTypeSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `AttributedTypeSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> AttributedTypeSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `AttributedTypeSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> AttributedTypeSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `AttributedTypeSyntax` with all trivia removed.
  public func withoutTrivia() -> AttributedTypeSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `AttributedTypeSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `AttributedTypeSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `GenericArgumentListSyntax` nodes conform. Extension point to add
/// common methods to all `GenericArgumentListSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol GenericArgumentListSyntaxProtocol: SyntaxProtocol {}

/// Protocol to which all `GenericArgumentSyntax` nodes conform. Extension point to add
/// common methods to all `GenericArgumentSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol GenericArgumentSyntaxProtocol: SyntaxProtocol {}


public struct GenericArgumentSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case argumentType
    case trailingComma
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `GenericArgumentSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .genericArgument else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `GenericArgumentSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .genericArgument)
    self._syntaxNode = Syntax(data)
  }

  public var argumentType: TypeSyntax {
    get {
      let childData = data.child(at: Cursor.argumentType, 
                                 parent: Syntax(self))
      return TypeSyntax(childData!)
    }
    set(value) {
      self = withArgumentType(value)
    }
  }

  /// Returns a copy of the receiver with its `argumentType` replaced.
  /// - param newChild: The new `argumentType` to replace the node's
  ///                   current `argumentType`, if present.
  public func withArgumentType(
    _ newChild: TypeSyntax?) -> GenericArgumentSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.type)
    let newData = data.replacingChild(raw, at: Cursor.argumentType)
    return GenericArgumentSyntax(newData)
  }
  public var trailingComma: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.trailingComma, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withTrailingComma(value)
    }
  }

  /// Returns a copy of the receiver with its `trailingComma` replaced.
  /// - param newChild: The new `trailingComma` to replace the node's
  ///                   current `trailingComma`, if present.
  public func withTrailingComma(
    _ newChild: TokenSyntax?) -> GenericArgumentSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.trailingComma)
    return GenericArgumentSyntax(newData)
  }

  /// Returns a new `GenericArgumentSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> GenericArgumentSyntax {
    return GenericArgumentSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `GenericArgumentSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> GenericArgumentSyntax {
    return GenericArgumentSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `GenericArgumentSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> GenericArgumentSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `GenericArgumentSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> GenericArgumentSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `GenericArgumentSyntax` with all trivia removed.
  public func withoutTrivia() -> GenericArgumentSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `GenericArgumentSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `GenericArgumentSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `GenericArgumentClauseSyntax` nodes conform. Extension point to add
/// common methods to all `GenericArgumentClauseSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol GenericArgumentClauseSyntaxProtocol: SyntaxProtocol {}


public struct GenericArgumentClauseSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case leftAngleBracket
    case arguments
    case rightAngleBracket
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `GenericArgumentClauseSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .genericArgumentClause else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `GenericArgumentClauseSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .genericArgumentClause)
    self._syntaxNode = Syntax(data)
  }

  public var leftAngleBracket: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.leftAngleBracket, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withLeftAngleBracket(value)
    }
  }

  /// Returns a copy of the receiver with its `leftAngleBracket` replaced.
  /// - param newChild: The new `leftAngleBracket` to replace the node's
  ///                   current `leftAngleBracket`, if present.
  public func withLeftAngleBracket(
    _ newChild: TokenSyntax?) -> GenericArgumentClauseSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.leftAngle)
    let newData = data.replacingChild(raw, at: Cursor.leftAngleBracket)
    return GenericArgumentClauseSyntax(newData)
  }
  public var arguments: GenericArgumentListSyntax {
    get {
      let childData = data.child(at: Cursor.arguments, 
                                 parent: Syntax(self))
      return GenericArgumentListSyntax(childData!)
    }
    set(value) {
      self = withArguments(value)
    }
  }

  /// Adds the provided `Argument` to the node's `arguments`
  /// collection.
  /// - param element: The new `Argument` to add to the node's
  ///                  `arguments` collection.
  /// - returns: A copy of the receiver with the provided `Argument`
  ///            appended to its `arguments` collection.
  public func addArgument(_ element: GenericArgumentSyntax) -> GenericArgumentClauseSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.arguments] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.genericArgumentList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.arguments)
    return GenericArgumentClauseSyntax(newData)
  }

  /// Returns a copy of the receiver with its `arguments` replaced.
  /// - param newChild: The new `arguments` to replace the node's
  ///                   current `arguments`, if present.
  public func withArguments(
    _ newChild: GenericArgumentListSyntax?) -> GenericArgumentClauseSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.genericArgumentList)
    let newData = data.replacingChild(raw, at: Cursor.arguments)
    return GenericArgumentClauseSyntax(newData)
  }
  public var rightAngleBracket: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.rightAngleBracket, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withRightAngleBracket(value)
    }
  }

  /// Returns a copy of the receiver with its `rightAngleBracket` replaced.
  /// - param newChild: The new `rightAngleBracket` to replace the node's
  ///                   current `rightAngleBracket`, if present.
  public func withRightAngleBracket(
    _ newChild: TokenSyntax?) -> GenericArgumentClauseSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.rightAngle)
    let newData = data.replacingChild(raw, at: Cursor.rightAngleBracket)
    return GenericArgumentClauseSyntax(newData)
  }

  /// Returns a new `GenericArgumentClauseSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> GenericArgumentClauseSyntax {
    return GenericArgumentClauseSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `GenericArgumentClauseSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> GenericArgumentClauseSyntax {
    return GenericArgumentClauseSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `GenericArgumentClauseSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> GenericArgumentClauseSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `GenericArgumentClauseSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> GenericArgumentClauseSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `GenericArgumentClauseSyntax` with all trivia removed.
  public func withoutTrivia() -> GenericArgumentClauseSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `GenericArgumentClauseSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `GenericArgumentClauseSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `TypeAnnotationSyntax` nodes conform. Extension point to add
/// common methods to all `TypeAnnotationSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol TypeAnnotationSyntaxProtocol: SyntaxProtocol {}


public struct TypeAnnotationSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case colon
    case type
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `TypeAnnotationSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .typeAnnotation else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `TypeAnnotationSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .typeAnnotation)
    self._syntaxNode = Syntax(data)
  }

  public var colon: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.colon, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withColon(value)
    }
  }

  /// Returns a copy of the receiver with its `colon` replaced.
  /// - param newChild: The new `colon` to replace the node's
  ///                   current `colon`, if present.
  public func withColon(
    _ newChild: TokenSyntax?) -> TypeAnnotationSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.colon)
    let newData = data.replacingChild(raw, at: Cursor.colon)
    return TypeAnnotationSyntax(newData)
  }
  public var type: TypeSyntax {
    get {
      let childData = data.child(at: Cursor.type, 
                                 parent: Syntax(self))
      return TypeSyntax(childData!)
    }
    set(value) {
      self = withType(value)
    }
  }

  /// Returns a copy of the receiver with its `type` replaced.
  /// - param newChild: The new `type` to replace the node's
  ///                   current `type`, if present.
  public func withType(
    _ newChild: TypeSyntax?) -> TypeAnnotationSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.type)
    let newData = data.replacingChild(raw, at: Cursor.type)
    return TypeAnnotationSyntax(newData)
  }

  /// Returns a new `TypeAnnotationSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> TypeAnnotationSyntax {
    return TypeAnnotationSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `TypeAnnotationSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> TypeAnnotationSyntax {
    return TypeAnnotationSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `TypeAnnotationSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> TypeAnnotationSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `TypeAnnotationSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> TypeAnnotationSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `TypeAnnotationSyntax` with all trivia removed.
  public func withoutTrivia() -> TypeAnnotationSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `TypeAnnotationSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `TypeAnnotationSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `EnumCasePatternSyntax` nodes conform. Extension point to add
/// common methods to all `EnumCasePatternSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol EnumCasePatternSyntaxProtocol: PatternSyntaxProtocol {}


public struct EnumCasePatternSyntax: PatternSyntaxProtocol {
  enum Cursor: Int {
    case type
    case period
    case caseName
    case associatedTuple
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `EnumCasePatternSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .enumCasePattern else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `EnumCasePatternSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .enumCasePattern)
    self._syntaxNode = Syntax(data)
  }

  public var type: TypeSyntax? {
    get {
      let childData = data.child(at: Cursor.type, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TypeSyntax(childData!)
    }
    set(value) {
      self = withType(value)
    }
  }

  /// Returns a copy of the receiver with its `type` replaced.
  /// - param newChild: The new `type` to replace the node's
  ///                   current `type`, if present.
  public func withType(
    _ newChild: TypeSyntax?) -> EnumCasePatternSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.type)
    return EnumCasePatternSyntax(newData)
  }
  public var period: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.period, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withPeriod(value)
    }
  }

  /// Returns a copy of the receiver with its `period` replaced.
  /// - param newChild: The new `period` to replace the node's
  ///                   current `period`, if present.
  public func withPeriod(
    _ newChild: TokenSyntax?) -> EnumCasePatternSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.period)
    let newData = data.replacingChild(raw, at: Cursor.period)
    return EnumCasePatternSyntax(newData)
  }
  public var caseName: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.caseName, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withCaseName(value)
    }
  }

  /// Returns a copy of the receiver with its `caseName` replaced.
  /// - param newChild: The new `caseName` to replace the node's
  ///                   current `caseName`, if present.
  public func withCaseName(
    _ newChild: TokenSyntax?) -> EnumCasePatternSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let newData = data.replacingChild(raw, at: Cursor.caseName)
    return EnumCasePatternSyntax(newData)
  }
  public var associatedTuple: TuplePatternSyntax? {
    get {
      let childData = data.child(at: Cursor.associatedTuple, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TuplePatternSyntax(childData!)
    }
    set(value) {
      self = withAssociatedTuple(value)
    }
  }

  /// Returns a copy of the receiver with its `associatedTuple` replaced.
  /// - param newChild: The new `associatedTuple` to replace the node's
  ///                   current `associatedTuple`, if present.
  public func withAssociatedTuple(
    _ newChild: TuplePatternSyntax?) -> EnumCasePatternSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.associatedTuple)
    return EnumCasePatternSyntax(newData)
  }

  /// Returns a new `EnumCasePatternSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> EnumCasePatternSyntax {
    return EnumCasePatternSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `EnumCasePatternSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> EnumCasePatternSyntax {
    return EnumCasePatternSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `EnumCasePatternSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> EnumCasePatternSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `EnumCasePatternSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> EnumCasePatternSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `EnumCasePatternSyntax` with all trivia removed.
  public func withoutTrivia() -> EnumCasePatternSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `EnumCasePatternSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `EnumCasePatternSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `IsTypePatternSyntax` nodes conform. Extension point to add
/// common methods to all `IsTypePatternSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol IsTypePatternSyntaxProtocol: PatternSyntaxProtocol {}


public struct IsTypePatternSyntax: PatternSyntaxProtocol {
  enum Cursor: Int {
    case isKeyword
    case type
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `IsTypePatternSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .isTypePattern else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `IsTypePatternSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .isTypePattern)
    self._syntaxNode = Syntax(data)
  }

  public var isKeyword: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.isKeyword, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withIsKeyword(value)
    }
  }

  /// Returns a copy of the receiver with its `isKeyword` replaced.
  /// - param newChild: The new `isKeyword` to replace the node's
  ///                   current `isKeyword`, if present.
  public func withIsKeyword(
    _ newChild: TokenSyntax?) -> IsTypePatternSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.isKeyword)
    let newData = data.replacingChild(raw, at: Cursor.isKeyword)
    return IsTypePatternSyntax(newData)
  }
  public var type: TypeSyntax {
    get {
      let childData = data.child(at: Cursor.type, 
                                 parent: Syntax(self))
      return TypeSyntax(childData!)
    }
    set(value) {
      self = withType(value)
    }
  }

  /// Returns a copy of the receiver with its `type` replaced.
  /// - param newChild: The new `type` to replace the node's
  ///                   current `type`, if present.
  public func withType(
    _ newChild: TypeSyntax?) -> IsTypePatternSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.type)
    let newData = data.replacingChild(raw, at: Cursor.type)
    return IsTypePatternSyntax(newData)
  }

  /// Returns a new `IsTypePatternSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> IsTypePatternSyntax {
    return IsTypePatternSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `IsTypePatternSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> IsTypePatternSyntax {
    return IsTypePatternSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `IsTypePatternSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> IsTypePatternSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `IsTypePatternSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> IsTypePatternSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `IsTypePatternSyntax` with all trivia removed.
  public func withoutTrivia() -> IsTypePatternSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `IsTypePatternSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `IsTypePatternSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `OptionalPatternSyntax` nodes conform. Extension point to add
/// common methods to all `OptionalPatternSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol OptionalPatternSyntaxProtocol: PatternSyntaxProtocol {}


public struct OptionalPatternSyntax: PatternSyntaxProtocol {
  enum Cursor: Int {
    case subPattern
    case questionMark
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `OptionalPatternSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .optionalPattern else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `OptionalPatternSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .optionalPattern)
    self._syntaxNode = Syntax(data)
  }

  public var subPattern: PatternSyntax {
    get {
      let childData = data.child(at: Cursor.subPattern, 
                                 parent: Syntax(self))
      return PatternSyntax(childData!)
    }
    set(value) {
      self = withSubPattern(value)
    }
  }

  /// Returns a copy of the receiver with its `subPattern` replaced.
  /// - param newChild: The new `subPattern` to replace the node's
  ///                   current `subPattern`, if present.
  public func withSubPattern(
    _ newChild: PatternSyntax?) -> OptionalPatternSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.pattern)
    let newData = data.replacingChild(raw, at: Cursor.subPattern)
    return OptionalPatternSyntax(newData)
  }
  public var questionMark: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.questionMark, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withQuestionMark(value)
    }
  }

  /// Returns a copy of the receiver with its `questionMark` replaced.
  /// - param newChild: The new `questionMark` to replace the node's
  ///                   current `questionMark`, if present.
  public func withQuestionMark(
    _ newChild: TokenSyntax?) -> OptionalPatternSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.postfixQuestionMark)
    let newData = data.replacingChild(raw, at: Cursor.questionMark)
    return OptionalPatternSyntax(newData)
  }

  /// Returns a new `OptionalPatternSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> OptionalPatternSyntax {
    return OptionalPatternSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `OptionalPatternSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> OptionalPatternSyntax {
    return OptionalPatternSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `OptionalPatternSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> OptionalPatternSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `OptionalPatternSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> OptionalPatternSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `OptionalPatternSyntax` with all trivia removed.
  public func withoutTrivia() -> OptionalPatternSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `OptionalPatternSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `OptionalPatternSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `IdentifierPatternSyntax` nodes conform. Extension point to add
/// common methods to all `IdentifierPatternSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol IdentifierPatternSyntaxProtocol: PatternSyntaxProtocol {}


public struct IdentifierPatternSyntax: PatternSyntaxProtocol {
  enum Cursor: Int {
    case identifier
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `IdentifierPatternSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .identifierPattern else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `IdentifierPatternSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .identifierPattern)
    self._syntaxNode = Syntax(data)
  }

  public var identifier: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.identifier, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withIdentifier(value)
    }
  }

  /// Returns a copy of the receiver with its `identifier` replaced.
  /// - param newChild: The new `identifier` to replace the node's
  ///                   current `identifier`, if present.
  public func withIdentifier(
    _ newChild: TokenSyntax?) -> IdentifierPatternSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.selfKeyword)
    let newData = data.replacingChild(raw, at: Cursor.identifier)
    return IdentifierPatternSyntax(newData)
  }

  /// Returns a new `IdentifierPatternSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> IdentifierPatternSyntax {
    return IdentifierPatternSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `IdentifierPatternSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> IdentifierPatternSyntax {
    return IdentifierPatternSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `IdentifierPatternSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> IdentifierPatternSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `IdentifierPatternSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> IdentifierPatternSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `IdentifierPatternSyntax` with all trivia removed.
  public func withoutTrivia() -> IdentifierPatternSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `IdentifierPatternSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `IdentifierPatternSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `AsTypePatternSyntax` nodes conform. Extension point to add
/// common methods to all `AsTypePatternSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol AsTypePatternSyntaxProtocol: PatternSyntaxProtocol {}


public struct AsTypePatternSyntax: PatternSyntaxProtocol {
  enum Cursor: Int {
    case pattern
    case asKeyword
    case type
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `AsTypePatternSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .asTypePattern else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `AsTypePatternSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .asTypePattern)
    self._syntaxNode = Syntax(data)
  }

  public var pattern: PatternSyntax {
    get {
      let childData = data.child(at: Cursor.pattern, 
                                 parent: Syntax(self))
      return PatternSyntax(childData!)
    }
    set(value) {
      self = withPattern(value)
    }
  }

  /// Returns a copy of the receiver with its `pattern` replaced.
  /// - param newChild: The new `pattern` to replace the node's
  ///                   current `pattern`, if present.
  public func withPattern(
    _ newChild: PatternSyntax?) -> AsTypePatternSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.pattern)
    let newData = data.replacingChild(raw, at: Cursor.pattern)
    return AsTypePatternSyntax(newData)
  }
  public var asKeyword: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.asKeyword, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withAsKeyword(value)
    }
  }

  /// Returns a copy of the receiver with its `asKeyword` replaced.
  /// - param newChild: The new `asKeyword` to replace the node's
  ///                   current `asKeyword`, if present.
  public func withAsKeyword(
    _ newChild: TokenSyntax?) -> AsTypePatternSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.asKeyword)
    let newData = data.replacingChild(raw, at: Cursor.asKeyword)
    return AsTypePatternSyntax(newData)
  }
  public var type: TypeSyntax {
    get {
      let childData = data.child(at: Cursor.type, 
                                 parent: Syntax(self))
      return TypeSyntax(childData!)
    }
    set(value) {
      self = withType(value)
    }
  }

  /// Returns a copy of the receiver with its `type` replaced.
  /// - param newChild: The new `type` to replace the node's
  ///                   current `type`, if present.
  public func withType(
    _ newChild: TypeSyntax?) -> AsTypePatternSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.type)
    let newData = data.replacingChild(raw, at: Cursor.type)
    return AsTypePatternSyntax(newData)
  }

  /// Returns a new `AsTypePatternSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> AsTypePatternSyntax {
    return AsTypePatternSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `AsTypePatternSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> AsTypePatternSyntax {
    return AsTypePatternSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `AsTypePatternSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> AsTypePatternSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `AsTypePatternSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> AsTypePatternSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `AsTypePatternSyntax` with all trivia removed.
  public func withoutTrivia() -> AsTypePatternSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `AsTypePatternSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `AsTypePatternSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `TuplePatternSyntax` nodes conform. Extension point to add
/// common methods to all `TuplePatternSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol TuplePatternSyntaxProtocol: PatternSyntaxProtocol {}


public struct TuplePatternSyntax: PatternSyntaxProtocol {
  enum Cursor: Int {
    case leftParen
    case elements
    case rightParen
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `TuplePatternSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .tuplePattern else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `TuplePatternSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .tuplePattern)
    self._syntaxNode = Syntax(data)
  }

  public var leftParen: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.leftParen, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withLeftParen(value)
    }
  }

  /// Returns a copy of the receiver with its `leftParen` replaced.
  /// - param newChild: The new `leftParen` to replace the node's
  ///                   current `leftParen`, if present.
  public func withLeftParen(
    _ newChild: TokenSyntax?) -> TuplePatternSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.leftParen)
    let newData = data.replacingChild(raw, at: Cursor.leftParen)
    return TuplePatternSyntax(newData)
  }
  public var elements: TuplePatternElementListSyntax {
    get {
      let childData = data.child(at: Cursor.elements, 
                                 parent: Syntax(self))
      return TuplePatternElementListSyntax(childData!)
    }
    set(value) {
      self = withElements(value)
    }
  }

  /// Adds the provided `Element` to the node's `elements`
  /// collection.
  /// - param element: The new `Element` to add to the node's
  ///                  `elements` collection.
  /// - returns: A copy of the receiver with the provided `Element`
  ///            appended to its `elements` collection.
  public func addElement(_ element: TuplePatternElementSyntax) -> TuplePatternSyntax {
    var collection: RawSyntax
    if let col = raw[Cursor.elements] {
      collection = col.appending(element.raw)
    } else {
      collection = RawSyntax.create(kind: SyntaxKind.tuplePatternElementList,
        layout: [element.raw], length: element.raw.totalLength, presence: .present)
    }
    let newData = data.replacingChild(collection,
                                      at: Cursor.elements)
    return TuplePatternSyntax(newData)
  }

  /// Returns a copy of the receiver with its `elements` replaced.
  /// - param newChild: The new `elements` to replace the node's
  ///                   current `elements`, if present.
  public func withElements(
    _ newChild: TuplePatternElementListSyntax?) -> TuplePatternSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.tuplePatternElementList)
    let newData = data.replacingChild(raw, at: Cursor.elements)
    return TuplePatternSyntax(newData)
  }
  public var rightParen: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.rightParen, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withRightParen(value)
    }
  }

  /// Returns a copy of the receiver with its `rightParen` replaced.
  /// - param newChild: The new `rightParen` to replace the node's
  ///                   current `rightParen`, if present.
  public func withRightParen(
    _ newChild: TokenSyntax?) -> TuplePatternSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.rightParen)
    let newData = data.replacingChild(raw, at: Cursor.rightParen)
    return TuplePatternSyntax(newData)
  }

  /// Returns a new `TuplePatternSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> TuplePatternSyntax {
    return TuplePatternSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `TuplePatternSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> TuplePatternSyntax {
    return TuplePatternSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `TuplePatternSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> TuplePatternSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `TuplePatternSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> TuplePatternSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `TuplePatternSyntax` with all trivia removed.
  public func withoutTrivia() -> TuplePatternSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `TuplePatternSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `TuplePatternSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `WildcardPatternSyntax` nodes conform. Extension point to add
/// common methods to all `WildcardPatternSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol WildcardPatternSyntaxProtocol: PatternSyntaxProtocol {}


public struct WildcardPatternSyntax: PatternSyntaxProtocol {
  enum Cursor: Int {
    case wildcard
    case typeAnnotation
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `WildcardPatternSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .wildcardPattern else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `WildcardPatternSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .wildcardPattern)
    self._syntaxNode = Syntax(data)
  }

  public var wildcard: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.wildcard, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withWildcard(value)
    }
  }

  /// Returns a copy of the receiver with its `wildcard` replaced.
  /// - param newChild: The new `wildcard` to replace the node's
  ///                   current `wildcard`, if present.
  public func withWildcard(
    _ newChild: TokenSyntax?) -> WildcardPatternSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.wildcardKeyword)
    let newData = data.replacingChild(raw, at: Cursor.wildcard)
    return WildcardPatternSyntax(newData)
  }
  public var typeAnnotation: TypeAnnotationSyntax? {
    get {
      let childData = data.child(at: Cursor.typeAnnotation, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TypeAnnotationSyntax(childData!)
    }
    set(value) {
      self = withTypeAnnotation(value)
    }
  }

  /// Returns a copy of the receiver with its `typeAnnotation` replaced.
  /// - param newChild: The new `typeAnnotation` to replace the node's
  ///                   current `typeAnnotation`, if present.
  public func withTypeAnnotation(
    _ newChild: TypeAnnotationSyntax?) -> WildcardPatternSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.typeAnnotation)
    return WildcardPatternSyntax(newData)
  }

  /// Returns a new `WildcardPatternSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> WildcardPatternSyntax {
    return WildcardPatternSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `WildcardPatternSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> WildcardPatternSyntax {
    return WildcardPatternSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `WildcardPatternSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> WildcardPatternSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `WildcardPatternSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> WildcardPatternSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `WildcardPatternSyntax` with all trivia removed.
  public func withoutTrivia() -> WildcardPatternSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `WildcardPatternSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `WildcardPatternSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `TuplePatternElementSyntax` nodes conform. Extension point to add
/// common methods to all `TuplePatternElementSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol TuplePatternElementSyntaxProtocol: SyntaxProtocol {}


public struct TuplePatternElementSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case labelName
    case labelColon
    case pattern
    case trailingComma
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `TuplePatternElementSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .tuplePatternElement else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `TuplePatternElementSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .tuplePatternElement)
    self._syntaxNode = Syntax(data)
  }

  public var labelName: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.labelName, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withLabelName(value)
    }
  }

  /// Returns a copy of the receiver with its `labelName` replaced.
  /// - param newChild: The new `labelName` to replace the node's
  ///                   current `labelName`, if present.
  public func withLabelName(
    _ newChild: TokenSyntax?) -> TuplePatternElementSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.labelName)
    return TuplePatternElementSyntax(newData)
  }
  public var labelColon: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.labelColon, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withLabelColon(value)
    }
  }

  /// Returns a copy of the receiver with its `labelColon` replaced.
  /// - param newChild: The new `labelColon` to replace the node's
  ///                   current `labelColon`, if present.
  public func withLabelColon(
    _ newChild: TokenSyntax?) -> TuplePatternElementSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.labelColon)
    return TuplePatternElementSyntax(newData)
  }
  public var pattern: PatternSyntax {
    get {
      let childData = data.child(at: Cursor.pattern, 
                                 parent: Syntax(self))
      return PatternSyntax(childData!)
    }
    set(value) {
      self = withPattern(value)
    }
  }

  /// Returns a copy of the receiver with its `pattern` replaced.
  /// - param newChild: The new `pattern` to replace the node's
  ///                   current `pattern`, if present.
  public func withPattern(
    _ newChild: PatternSyntax?) -> TuplePatternElementSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.pattern)
    let newData = data.replacingChild(raw, at: Cursor.pattern)
    return TuplePatternElementSyntax(newData)
  }
  public var trailingComma: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.trailingComma, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withTrailingComma(value)
    }
  }

  /// Returns a copy of the receiver with its `trailingComma` replaced.
  /// - param newChild: The new `trailingComma` to replace the node's
  ///                   current `trailingComma`, if present.
  public func withTrailingComma(
    _ newChild: TokenSyntax?) -> TuplePatternElementSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.trailingComma)
    return TuplePatternElementSyntax(newData)
  }

  /// Returns a new `TuplePatternElementSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> TuplePatternElementSyntax {
    return TuplePatternElementSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `TuplePatternElementSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> TuplePatternElementSyntax {
    return TuplePatternElementSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `TuplePatternElementSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> TuplePatternElementSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `TuplePatternElementSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> TuplePatternElementSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `TuplePatternElementSyntax` with all trivia removed.
  public func withoutTrivia() -> TuplePatternElementSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `TuplePatternElementSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `TuplePatternElementSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `ExpressionPatternSyntax` nodes conform. Extension point to add
/// common methods to all `ExpressionPatternSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol ExpressionPatternSyntaxProtocol: PatternSyntaxProtocol {}


public struct ExpressionPatternSyntax: PatternSyntaxProtocol {
  enum Cursor: Int {
    case expression
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `ExpressionPatternSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .expressionPattern else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `ExpressionPatternSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .expressionPattern)
    self._syntaxNode = Syntax(data)
  }

  public var expression: ExprSyntax {
    get {
      let childData = data.child(at: Cursor.expression, 
                                 parent: Syntax(self))
      return ExprSyntax(childData!)
    }
    set(value) {
      self = withExpression(value)
    }
  }

  /// Returns a copy of the receiver with its `expression` replaced.
  /// - param newChild: The new `expression` to replace the node's
  ///                   current `expression`, if present.
  public func withExpression(
    _ newChild: ExprSyntax?) -> ExpressionPatternSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.expr)
    let newData = data.replacingChild(raw, at: Cursor.expression)
    return ExpressionPatternSyntax(newData)
  }

  /// Returns a new `ExpressionPatternSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> ExpressionPatternSyntax {
    return ExpressionPatternSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `ExpressionPatternSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> ExpressionPatternSyntax {
    return ExpressionPatternSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `ExpressionPatternSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> ExpressionPatternSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `ExpressionPatternSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> ExpressionPatternSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `ExpressionPatternSyntax` with all trivia removed.
  public func withoutTrivia() -> ExpressionPatternSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `ExpressionPatternSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `ExpressionPatternSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `TuplePatternElementListSyntax` nodes conform. Extension point to add
/// common methods to all `TuplePatternElementListSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol TuplePatternElementListSyntaxProtocol: SyntaxProtocol {}

/// Protocol to which all `ValueBindingPatternSyntax` nodes conform. Extension point to add
/// common methods to all `ValueBindingPatternSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol ValueBindingPatternSyntaxProtocol: PatternSyntaxProtocol {}


public struct ValueBindingPatternSyntax: PatternSyntaxProtocol {
  enum Cursor: Int {
    case letOrVarKeyword
    case valuePattern
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `ValueBindingPatternSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .valueBindingPattern else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `ValueBindingPatternSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .valueBindingPattern)
    self._syntaxNode = Syntax(data)
  }

  public var letOrVarKeyword: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.letOrVarKeyword, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withLetOrVarKeyword(value)
    }
  }

  /// Returns a copy of the receiver with its `letOrVarKeyword` replaced.
  /// - param newChild: The new `letOrVarKeyword` to replace the node's
  ///                   current `letOrVarKeyword`, if present.
  public func withLetOrVarKeyword(
    _ newChild: TokenSyntax?) -> ValueBindingPatternSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.letKeyword)
    let newData = data.replacingChild(raw, at: Cursor.letOrVarKeyword)
    return ValueBindingPatternSyntax(newData)
  }
  public var valuePattern: PatternSyntax {
    get {
      let childData = data.child(at: Cursor.valuePattern, 
                                 parent: Syntax(self))
      return PatternSyntax(childData!)
    }
    set(value) {
      self = withValuePattern(value)
    }
  }

  /// Returns a copy of the receiver with its `valuePattern` replaced.
  /// - param newChild: The new `valuePattern` to replace the node's
  ///                   current `valuePattern`, if present.
  public func withValuePattern(
    _ newChild: PatternSyntax?) -> ValueBindingPatternSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.pattern)
    let newData = data.replacingChild(raw, at: Cursor.valuePattern)
    return ValueBindingPatternSyntax(newData)
  }

  /// Returns a new `ValueBindingPatternSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> ValueBindingPatternSyntax {
    return ValueBindingPatternSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `ValueBindingPatternSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> ValueBindingPatternSyntax {
    return ValueBindingPatternSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `ValueBindingPatternSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> ValueBindingPatternSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `ValueBindingPatternSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> ValueBindingPatternSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `ValueBindingPatternSyntax` with all trivia removed.
  public func withoutTrivia() -> ValueBindingPatternSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `ValueBindingPatternSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `ValueBindingPatternSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `AvailabilitySpecListSyntax` nodes conform. Extension point to add
/// common methods to all `AvailabilitySpecListSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol AvailabilitySpecListSyntaxProtocol: SyntaxProtocol {}

/// Protocol to which all `AvailabilityArgumentSyntax` nodes conform. Extension point to add
/// common methods to all `AvailabilityArgumentSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol AvailabilityArgumentSyntaxProtocol: SyntaxProtocol {}


/// 
/// A single argument to an `@available` argument like `*`, `iOS 10.1`,          or `message: "This has been deprecated"`.
/// 
public struct AvailabilityArgumentSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case entry
    case trailingComma
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `AvailabilityArgumentSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .availabilityArgument else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `AvailabilityArgumentSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .availabilityArgument)
    self._syntaxNode = Syntax(data)
  }

  /// The actual argument
  public var entry: Syntax {
    get {
      let childData = data.child(at: Cursor.entry, 
                                 parent: Syntax(self))
      return Syntax(childData!)
    }
    set(value) {
      self = withEntry(value)
    }
  }

  /// Returns a copy of the receiver with its `entry` replaced.
  /// - param newChild: The new `entry` to replace the node's
  ///                   current `entry`, if present.
  public func withEntry(
    _ newChild: Syntax?) -> AvailabilityArgumentSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.unknown)
    let newData = data.replacingChild(raw, at: Cursor.entry)
    return AvailabilityArgumentSyntax(newData)
  }
  /// 
  /// A trailing comma if the argument is followed by another                    argument
  /// 
  public var trailingComma: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.trailingComma, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withTrailingComma(value)
    }
  }

  /// Returns a copy of the receiver with its `trailingComma` replaced.
  /// - param newChild: The new `trailingComma` to replace the node's
  ///                   current `trailingComma`, if present.
  public func withTrailingComma(
    _ newChild: TokenSyntax?) -> AvailabilityArgumentSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.trailingComma)
    return AvailabilityArgumentSyntax(newData)
  }

  /// Returns a new `AvailabilityArgumentSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> AvailabilityArgumentSyntax {
    return AvailabilityArgumentSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `AvailabilityArgumentSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> AvailabilityArgumentSyntax {
    return AvailabilityArgumentSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `AvailabilityArgumentSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> AvailabilityArgumentSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `AvailabilityArgumentSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> AvailabilityArgumentSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `AvailabilityArgumentSyntax` with all trivia removed.
  public func withoutTrivia() -> AvailabilityArgumentSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `AvailabilityArgumentSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `AvailabilityArgumentSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `AvailabilityLabeledArgumentSyntax` nodes conform. Extension point to add
/// common methods to all `AvailabilityLabeledArgumentSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol AvailabilityLabeledArgumentSyntaxProtocol: SyntaxProtocol {}


/// 
/// A argument to an `@available` attribute that consists of a label and          a value, e.g. `message: "This has been deprecated"`.
/// 
public struct AvailabilityLabeledArgumentSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case label
    case colon
    case value
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `AvailabilityLabeledArgumentSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .availabilityLabeledArgument else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `AvailabilityLabeledArgumentSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .availabilityLabeledArgument)
    self._syntaxNode = Syntax(data)
  }

  /// The label of the argument
  public var label: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.label, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withLabel(value)
    }
  }

  /// Returns a copy of the receiver with its `label` replaced.
  /// - param newChild: The new `label` to replace the node's
  ///                   current `label`, if present.
  public func withLabel(
    _ newChild: TokenSyntax?) -> AvailabilityLabeledArgumentSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let newData = data.replacingChild(raw, at: Cursor.label)
    return AvailabilityLabeledArgumentSyntax(newData)
  }
  /// The colon separating label and value
  public var colon: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.colon, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withColon(value)
    }
  }

  /// Returns a copy of the receiver with its `colon` replaced.
  /// - param newChild: The new `colon` to replace the node's
  ///                   current `colon`, if present.
  public func withColon(
    _ newChild: TokenSyntax?) -> AvailabilityLabeledArgumentSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.colon)
    let newData = data.replacingChild(raw, at: Cursor.colon)
    return AvailabilityLabeledArgumentSyntax(newData)
  }
  /// The value of this labeled argument
  public var value: Syntax {
    get {
      let childData = data.child(at: Cursor.value, 
                                 parent: Syntax(self))
      return Syntax(childData!)
    }
    set(value) {
      self = withValue(value)
    }
  }

  /// Returns a copy of the receiver with its `value` replaced.
  /// - param newChild: The new `value` to replace the node's
  ///                   current `value`, if present.
  public func withValue(
    _ newChild: Syntax?) -> AvailabilityLabeledArgumentSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.unknown)
    let newData = data.replacingChild(raw, at: Cursor.value)
    return AvailabilityLabeledArgumentSyntax(newData)
  }

  /// Returns a new `AvailabilityLabeledArgumentSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> AvailabilityLabeledArgumentSyntax {
    return AvailabilityLabeledArgumentSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `AvailabilityLabeledArgumentSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> AvailabilityLabeledArgumentSyntax {
    return AvailabilityLabeledArgumentSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `AvailabilityLabeledArgumentSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> AvailabilityLabeledArgumentSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `AvailabilityLabeledArgumentSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> AvailabilityLabeledArgumentSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `AvailabilityLabeledArgumentSyntax` with all trivia removed.
  public func withoutTrivia() -> AvailabilityLabeledArgumentSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `AvailabilityLabeledArgumentSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `AvailabilityLabeledArgumentSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `AvailabilityVersionRestrictionSyntax` nodes conform. Extension point to add
/// common methods to all `AvailabilityVersionRestrictionSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol AvailabilityVersionRestrictionSyntaxProtocol: SyntaxProtocol {}


/// 
/// An argument to `@available` that restricts the availability on a          certain platform to a version, e.g. `iOS 10` or `swift 3.4`.
/// 
public struct AvailabilityVersionRestrictionSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case platform
    case version
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `AvailabilityVersionRestrictionSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .availabilityVersionRestriction else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `AvailabilityVersionRestrictionSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .availabilityVersionRestriction)
    self._syntaxNode = Syntax(data)
  }

  /// 
  /// The name of the OS on which the availability should be                    restricted or 'swift' if the availability should be                    restricted based on a Swift version.
  /// 
  public var platform: TokenSyntax {
    get {
      let childData = data.child(at: Cursor.platform, 
                                 parent: Syntax(self))
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withPlatform(value)
    }
  }

  /// Returns a copy of the receiver with its `platform` replaced.
  /// - param newChild: The new `platform` to replace the node's
  ///                   current `platform`, if present.
  public func withPlatform(
    _ newChild: TokenSyntax?) -> AvailabilityVersionRestrictionSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(TokenKind.identifier(""))
    let newData = data.replacingChild(raw, at: Cursor.platform)
    return AvailabilityVersionRestrictionSyntax(newData)
  }
  public var version: VersionTupleSyntax {
    get {
      let childData = data.child(at: Cursor.version, 
                                 parent: Syntax(self))
      return VersionTupleSyntax(childData!)
    }
    set(value) {
      self = withVersion(value)
    }
  }

  /// Returns a copy of the receiver with its `version` replaced.
  /// - param newChild: The new `version` to replace the node's
  ///                   current `version`, if present.
  public func withVersion(
    _ newChild: VersionTupleSyntax?) -> AvailabilityVersionRestrictionSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.versionTuple)
    let newData = data.replacingChild(raw, at: Cursor.version)
    return AvailabilityVersionRestrictionSyntax(newData)
  }

  /// Returns a new `AvailabilityVersionRestrictionSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> AvailabilityVersionRestrictionSyntax {
    return AvailabilityVersionRestrictionSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `AvailabilityVersionRestrictionSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> AvailabilityVersionRestrictionSyntax {
    return AvailabilityVersionRestrictionSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `AvailabilityVersionRestrictionSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> AvailabilityVersionRestrictionSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `AvailabilityVersionRestrictionSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> AvailabilityVersionRestrictionSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `AvailabilityVersionRestrictionSyntax` with all trivia removed.
  public func withoutTrivia() -> AvailabilityVersionRestrictionSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `AvailabilityVersionRestrictionSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `AvailabilityVersionRestrictionSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}
/// Protocol to which all `VersionTupleSyntax` nodes conform. Extension point to add
/// common methods to all `VersionTupleSyntax` nodes. 
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol VersionTupleSyntaxProtocol: SyntaxProtocol {}


/// 
/// A version number of the form major.minor.patch in which the minor          and patch part may be ommited.
/// 
public struct VersionTupleSyntax: SyntaxProtocol {
  enum Cursor: Int {
    case majorMinor
    case patchPeriod
    case patchVersion
  }

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `VersionTupleSyntax` if possible. Returns 
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .versionTuple else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a `VersionTupleSyntax` node from the given `SyntaxData`. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .versionTuple)
    self._syntaxNode = Syntax(data)
  }

  /// 
  /// In case the version consists only of the major version, an                    integer literal that specifies the major version. In case                    the version consists of major and minor version number, a                    floating literal in which the decimal part is interpreted                    as the minor version.
  /// 
  public var majorMinor: Syntax {
    get {
      let childData = data.child(at: Cursor.majorMinor, 
                                 parent: Syntax(self))
      return Syntax(childData!)
    }
    set(value) {
      self = withMajorMinor(value)
    }
  }

  /// Returns a copy of the receiver with its `majorMinor` replaced.
  /// - param newChild: The new `majorMinor` to replace the node's
  ///                   current `majorMinor`, if present.
  public func withMajorMinor(
    _ newChild: Syntax?) -> VersionTupleSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(SyntaxKind.unknown)
    let newData = data.replacingChild(raw, at: Cursor.majorMinor)
    return VersionTupleSyntax(newData)
  }
  /// 
  /// If the version contains a patch number, the period                    separating the minor from the patch number.
  /// 
  public var patchPeriod: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.patchPeriod, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withPatchPeriod(value)
    }
  }

  /// Returns a copy of the receiver with its `patchPeriod` replaced.
  /// - param newChild: The new `patchPeriod` to replace the node's
  ///                   current `patchPeriod`, if present.
  public func withPatchPeriod(
    _ newChild: TokenSyntax?) -> VersionTupleSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.patchPeriod)
    return VersionTupleSyntax(newData)
  }
  /// 
  /// The patch version if specified.
  /// 
  public var patchVersion: TokenSyntax? {
    get {
      let childData = data.child(at: Cursor.patchVersion, 
                                 parent: Syntax(self))
      if childData == nil { return nil }
      return TokenSyntax(childData!)
    }
    set(value) {
      self = withPatchVersion(value)
    }
  }

  /// Returns a copy of the receiver with its `patchVersion` replaced.
  /// - param newChild: The new `patchVersion` to replace the node's
  ///                   current `patchVersion`, if present.
  public func withPatchVersion(
    _ newChild: TokenSyntax?) -> VersionTupleSyntax {
    let raw = newChild?.raw
    let newData = data.replacingChild(raw, at: Cursor.patchVersion)
    return VersionTupleSyntax(newData)
  }

  /// Returns a new `VersionTupleSyntax` with its leading trivia replaced
  /// by the provided trivia.
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> VersionTupleSyntax {
    return VersionTupleSyntax(data.withLeadingTrivia(leadingTrivia))
  }

  /// Returns a new `VersionTupleSyntax` with its trailing trivia replaced
  /// by the provided trivia.
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> VersionTupleSyntax {
    return VersionTupleSyntax(data.withTrailingTrivia(trailingTrivia))
  }

  /// Returns a new `VersionTupleSyntax` with its leading trivia removed.
  public func withoutLeadingTrivia() -> VersionTupleSyntax {
    return withLeadingTrivia([])
  }

  /// Returns a new `VersionTupleSyntax` with its trailing trivia removed.
  public func withoutTrailingTrivia() -> VersionTupleSyntax {
    return withTrailingTrivia([])
  }

  /// Returns a new `VersionTupleSyntax` with all trivia removed.
  public func withoutTrivia() -> VersionTupleSyntax {
    return withoutLeadingTrivia().withoutTrailingTrivia()
  }

  /// The leading trivia (spaces, newlines, etc.) associated with this `VersionTupleSyntax`.
  public var leadingTrivia: Trivia? {
    get {
      return raw.formLeadingTrivia()
    }
    set {
      self = withLeadingTrivia(newValue ?? [])
    }
  }

  /// The trailing trivia (spaces, newlines, etc.) associated with this `VersionTupleSyntax`.
  public var trailingTrivia: Trivia? {
    get {
      return raw.formTrailingTrivia()
    }
    set {
      self = withTrailingTrivia(newValue ?? [])
    }
  }
}

/// Enum to exhaustively switch over all different syntax nodes.
public enum SyntaxEnum {
  case unknown(UnknownSyntax)
  case token(TokenSyntax)
  case decl(UnknownDeclSyntax)
  case expr(UnknownExprSyntax)
  case stmt(UnknownStmtSyntax)
  case type(UnknownTypeSyntax)
  case pattern(UnknownPatternSyntax)
  case unknownDecl(UnknownDeclSyntax)
  case unknownExpr(UnknownExprSyntax)
  case unknownStmt(UnknownStmtSyntax)
  case unknownType(UnknownTypeSyntax)
  case unknownPattern(UnknownPatternSyntax)
  case codeBlockItem(CodeBlockItemSyntax)
  case codeBlockItemList(CodeBlockItemListSyntax)
  case codeBlock(CodeBlockSyntax)
  case inOutExpr(InOutExprSyntax)
  case poundColumnExpr(PoundColumnExprSyntax)
  case tupleExprElementList(TupleExprElementListSyntax)
  case arrayElementList(ArrayElementListSyntax)
  case dictionaryElementList(DictionaryElementListSyntax)
  case stringLiteralSegments(StringLiteralSegmentsSyntax)
  case tryExpr(TryExprSyntax)
  case declNameArgument(DeclNameArgumentSyntax)
  case declNameArgumentList(DeclNameArgumentListSyntax)
  case declNameArguments(DeclNameArgumentsSyntax)
  case identifierExpr(IdentifierExprSyntax)
  case superRefExpr(SuperRefExprSyntax)
  case nilLiteralExpr(NilLiteralExprSyntax)
  case discardAssignmentExpr(DiscardAssignmentExprSyntax)
  case assignmentExpr(AssignmentExprSyntax)
  case sequenceExpr(SequenceExprSyntax)
  case exprList(ExprListSyntax)
  case poundLineExpr(PoundLineExprSyntax)
  case poundFileExpr(PoundFileExprSyntax)
  case poundFunctionExpr(PoundFunctionExprSyntax)
  case poundDsohandleExpr(PoundDsohandleExprSyntax)
  case symbolicReferenceExpr(SymbolicReferenceExprSyntax)
  case prefixOperatorExpr(PrefixOperatorExprSyntax)
  case binaryOperatorExpr(BinaryOperatorExprSyntax)
  case arrowExpr(ArrowExprSyntax)
  case floatLiteralExpr(FloatLiteralExprSyntax)
  case tupleExpr(TupleExprSyntax)
  case arrayExpr(ArrayExprSyntax)
  case dictionaryExpr(DictionaryExprSyntax)
  case tupleExprElement(TupleExprElementSyntax)
  case arrayElement(ArrayElementSyntax)
  case dictionaryElement(DictionaryElementSyntax)
  case integerLiteralExpr(IntegerLiteralExprSyntax)
  case booleanLiteralExpr(BooleanLiteralExprSyntax)
  case ternaryExpr(TernaryExprSyntax)
  case memberAccessExpr(MemberAccessExprSyntax)
  case isExpr(IsExprSyntax)
  case asExpr(AsExprSyntax)
  case typeExpr(TypeExprSyntax)
  case closureCaptureItem(ClosureCaptureItemSyntax)
  case closureCaptureItemList(ClosureCaptureItemListSyntax)
  case closureCaptureSignature(ClosureCaptureSignatureSyntax)
  case closureParam(ClosureParamSyntax)
  case closureParamList(ClosureParamListSyntax)
  case closureSignature(ClosureSignatureSyntax)
  case closureExpr(ClosureExprSyntax)
  case unresolvedPatternExpr(UnresolvedPatternExprSyntax)
  case functionCallExpr(FunctionCallExprSyntax)
  case subscriptExpr(SubscriptExprSyntax)
  case optionalChainingExpr(OptionalChainingExprSyntax)
  case forcedValueExpr(ForcedValueExprSyntax)
  case postfixUnaryExpr(PostfixUnaryExprSyntax)
  case specializeExpr(SpecializeExprSyntax)
  case stringSegment(StringSegmentSyntax)
  case expressionSegment(ExpressionSegmentSyntax)
  case stringLiteralExpr(StringLiteralExprSyntax)
  case keyPathExpr(KeyPathExprSyntax)
  case keyPathBaseExpr(KeyPathBaseExprSyntax)
  case objcNamePiece(ObjcNamePieceSyntax)
  case objcName(ObjcNameSyntax)
  case objcKeyPathExpr(ObjcKeyPathExprSyntax)
  case objcSelectorExpr(ObjcSelectorExprSyntax)
  case editorPlaceholderExpr(EditorPlaceholderExprSyntax)
  case objectLiteralExpr(ObjectLiteralExprSyntax)
  case typeInitializerClause(TypeInitializerClauseSyntax)
  case typealiasDecl(TypealiasDeclSyntax)
  case associatedtypeDecl(AssociatedtypeDeclSyntax)
  case functionParameterList(FunctionParameterListSyntax)
  case parameterClause(ParameterClauseSyntax)
  case returnClause(ReturnClauseSyntax)
  case functionSignature(FunctionSignatureSyntax)
  case ifConfigClause(IfConfigClauseSyntax)
  case ifConfigClauseList(IfConfigClauseListSyntax)
  case ifConfigDecl(IfConfigDeclSyntax)
  case poundErrorDecl(PoundErrorDeclSyntax)
  case poundWarningDecl(PoundWarningDeclSyntax)
  case poundSourceLocation(PoundSourceLocationSyntax)
  case poundSourceLocationArgs(PoundSourceLocationArgsSyntax)
  case declModifier(DeclModifierSyntax)
  case inheritedType(InheritedTypeSyntax)
  case inheritedTypeList(InheritedTypeListSyntax)
  case typeInheritanceClause(TypeInheritanceClauseSyntax)
  case classDecl(ClassDeclSyntax)
  case structDecl(StructDeclSyntax)
  case protocolDecl(ProtocolDeclSyntax)
  case extensionDecl(ExtensionDeclSyntax)
  case memberDeclBlock(MemberDeclBlockSyntax)
  case memberDeclList(MemberDeclListSyntax)
  case memberDeclListItem(MemberDeclListItemSyntax)
  case sourceFile(SourceFileSyntax)
  case initializerClause(InitializerClauseSyntax)
  case functionParameter(FunctionParameterSyntax)
  case modifierList(ModifierListSyntax)
  case functionDecl(FunctionDeclSyntax)
  case initializerDecl(InitializerDeclSyntax)
  case deinitializerDecl(DeinitializerDeclSyntax)
  case subscriptDecl(SubscriptDeclSyntax)
  case accessLevelModifier(AccessLevelModifierSyntax)
  case accessPathComponent(AccessPathComponentSyntax)
  case accessPath(AccessPathSyntax)
  case importDecl(ImportDeclSyntax)
  case accessorParameter(AccessorParameterSyntax)
  case accessorDecl(AccessorDeclSyntax)
  case accessorList(AccessorListSyntax)
  case accessorBlock(AccessorBlockSyntax)
  case patternBinding(PatternBindingSyntax)
  case patternBindingList(PatternBindingListSyntax)
  case variableDecl(VariableDeclSyntax)
  case enumCaseElement(EnumCaseElementSyntax)
  case enumCaseElementList(EnumCaseElementListSyntax)
  case enumCaseDecl(EnumCaseDeclSyntax)
  case enumDecl(EnumDeclSyntax)
  case operatorDecl(OperatorDeclSyntax)
  case identifierList(IdentifierListSyntax)
  case operatorPrecedenceAndTypes(OperatorPrecedenceAndTypesSyntax)
  case precedenceGroupDecl(PrecedenceGroupDeclSyntax)
  case precedenceGroupAttributeList(PrecedenceGroupAttributeListSyntax)
  case precedenceGroupRelation(PrecedenceGroupRelationSyntax)
  case precedenceGroupNameList(PrecedenceGroupNameListSyntax)
  case precedenceGroupNameElement(PrecedenceGroupNameElementSyntax)
  case precedenceGroupAssignment(PrecedenceGroupAssignmentSyntax)
  case precedenceGroupAssociativity(PrecedenceGroupAssociativitySyntax)
  case tokenList(TokenListSyntax)
  case nonEmptyTokenList(NonEmptyTokenListSyntax)
  case customAttribute(CustomAttributeSyntax)
  case attribute(AttributeSyntax)
  case attributeList(AttributeListSyntax)
  case specializeAttributeSpecList(SpecializeAttributeSpecListSyntax)
  case labeledSpecializeEntry(LabeledSpecializeEntrySyntax)
  case namedAttributeStringArgument(NamedAttributeStringArgumentSyntax)
  case declName(DeclNameSyntax)
  case implementsAttributeArguments(ImplementsAttributeArgumentsSyntax)
  case objCSelectorPiece(ObjCSelectorPieceSyntax)
  case objCSelector(ObjCSelectorSyntax)
  case continueStmt(ContinueStmtSyntax)
  case whileStmt(WhileStmtSyntax)
  case deferStmt(DeferStmtSyntax)
  case expressionStmt(ExpressionStmtSyntax)
  case switchCaseList(SwitchCaseListSyntax)
  case repeatWhileStmt(RepeatWhileStmtSyntax)
  case guardStmt(GuardStmtSyntax)
  case whereClause(WhereClauseSyntax)
  case forInStmt(ForInStmtSyntax)
  case switchStmt(SwitchStmtSyntax)
  case catchClauseList(CatchClauseListSyntax)
  case doStmt(DoStmtSyntax)
  case returnStmt(ReturnStmtSyntax)
  case yieldStmt(YieldStmtSyntax)
  case yieldList(YieldListSyntax)
  case fallthroughStmt(FallthroughStmtSyntax)
  case breakStmt(BreakStmtSyntax)
  case caseItemList(CaseItemListSyntax)
  case conditionElement(ConditionElementSyntax)
  case availabilityCondition(AvailabilityConditionSyntax)
  case matchingPatternCondition(MatchingPatternConditionSyntax)
  case optionalBindingCondition(OptionalBindingConditionSyntax)
  case conditionElementList(ConditionElementListSyntax)
  case declarationStmt(DeclarationStmtSyntax)
  case throwStmt(ThrowStmtSyntax)
  case ifStmt(IfStmtSyntax)
  case elseIfContinuation(ElseIfContinuationSyntax)
  case elseBlock(ElseBlockSyntax)
  case switchCase(SwitchCaseSyntax)
  case switchDefaultLabel(SwitchDefaultLabelSyntax)
  case caseItem(CaseItemSyntax)
  case switchCaseLabel(SwitchCaseLabelSyntax)
  case catchClause(CatchClauseSyntax)
  case poundAssertStmt(PoundAssertStmtSyntax)
  case genericWhereClause(GenericWhereClauseSyntax)
  case genericRequirementList(GenericRequirementListSyntax)
  case genericRequirement(GenericRequirementSyntax)
  case sameTypeRequirement(SameTypeRequirementSyntax)
  case genericParameterList(GenericParameterListSyntax)
  case genericParameter(GenericParameterSyntax)
  case genericParameterClause(GenericParameterClauseSyntax)
  case conformanceRequirement(ConformanceRequirementSyntax)
  case simpleTypeIdentifier(SimpleTypeIdentifierSyntax)
  case memberTypeIdentifier(MemberTypeIdentifierSyntax)
  case classRestrictionType(ClassRestrictionTypeSyntax)
  case arrayType(ArrayTypeSyntax)
  case dictionaryType(DictionaryTypeSyntax)
  case metatypeType(MetatypeTypeSyntax)
  case optionalType(OptionalTypeSyntax)
  case someType(SomeTypeSyntax)
  case implicitlyUnwrappedOptionalType(ImplicitlyUnwrappedOptionalTypeSyntax)
  case compositionTypeElement(CompositionTypeElementSyntax)
  case compositionTypeElementList(CompositionTypeElementListSyntax)
  case compositionType(CompositionTypeSyntax)
  case tupleTypeElement(TupleTypeElementSyntax)
  case tupleTypeElementList(TupleTypeElementListSyntax)
  case tupleType(TupleTypeSyntax)
  case functionType(FunctionTypeSyntax)
  case attributedType(AttributedTypeSyntax)
  case genericArgumentList(GenericArgumentListSyntax)
  case genericArgument(GenericArgumentSyntax)
  case genericArgumentClause(GenericArgumentClauseSyntax)
  case typeAnnotation(TypeAnnotationSyntax)
  case enumCasePattern(EnumCasePatternSyntax)
  case isTypePattern(IsTypePatternSyntax)
  case optionalPattern(OptionalPatternSyntax)
  case identifierPattern(IdentifierPatternSyntax)
  case asTypePattern(AsTypePatternSyntax)
  case tuplePattern(TuplePatternSyntax)
  case wildcardPattern(WildcardPatternSyntax)
  case tuplePatternElement(TuplePatternElementSyntax)
  case expressionPattern(ExpressionPatternSyntax)
  case tuplePatternElementList(TuplePatternElementListSyntax)
  case valueBindingPattern(ValueBindingPatternSyntax)
  case availabilitySpecList(AvailabilitySpecListSyntax)
  case availabilityArgument(AvailabilityArgumentSyntax)
  case availabilityLabeledArgument(AvailabilityLabeledArgumentSyntax)
  case availabilityVersionRestriction(AvailabilityVersionRestrictionSyntax)
  case versionTuple(VersionTupleSyntax)
}

public extension Syntax {
  /// Get an enum that can be used to exhaustively switch over all syntax nodes.
  var asSyntaxEnum: SyntaxEnum {
    switch raw.kind {
    case .token:
      return .token(TokenSyntax(self)!)
    case .unknown:
      return .unknown(UnknownSyntax(self)!)
    case .decl:
      return .decl(UnknownDeclSyntax(self)!)
    case .expr:
      return .expr(UnknownExprSyntax(self)!)
    case .stmt:
      return .stmt(UnknownStmtSyntax(self)!)
    case .type:
      return .type(UnknownTypeSyntax(self)!)
    case .pattern:
      return .pattern(UnknownPatternSyntax(self)!)
    case .unknownDecl:
      return .unknownDecl(UnknownDeclSyntax(self)!)
    case .unknownExpr:
      return .unknownExpr(UnknownExprSyntax(self)!)
    case .unknownStmt:
      return .unknownStmt(UnknownStmtSyntax(self)!)
    case .unknownType:
      return .unknownType(UnknownTypeSyntax(self)!)
    case .unknownPattern:
      return .unknownPattern(UnknownPatternSyntax(self)!)
    case .codeBlockItem:
      return .codeBlockItem(CodeBlockItemSyntax(self)!)
    case .codeBlockItemList:
      return .codeBlockItemList(CodeBlockItemListSyntax(self)!)
    case .codeBlock:
      return .codeBlock(CodeBlockSyntax(self)!)
    case .inOutExpr:
      return .inOutExpr(InOutExprSyntax(self)!)
    case .poundColumnExpr:
      return .poundColumnExpr(PoundColumnExprSyntax(self)!)
    case .tupleExprElementList:
      return .tupleExprElementList(TupleExprElementListSyntax(self)!)
    case .arrayElementList:
      return .arrayElementList(ArrayElementListSyntax(self)!)
    case .dictionaryElementList:
      return .dictionaryElementList(DictionaryElementListSyntax(self)!)
    case .stringLiteralSegments:
      return .stringLiteralSegments(StringLiteralSegmentsSyntax(self)!)
    case .tryExpr:
      return .tryExpr(TryExprSyntax(self)!)
    case .declNameArgument:
      return .declNameArgument(DeclNameArgumentSyntax(self)!)
    case .declNameArgumentList:
      return .declNameArgumentList(DeclNameArgumentListSyntax(self)!)
    case .declNameArguments:
      return .declNameArguments(DeclNameArgumentsSyntax(self)!)
    case .identifierExpr:
      return .identifierExpr(IdentifierExprSyntax(self)!)
    case .superRefExpr:
      return .superRefExpr(SuperRefExprSyntax(self)!)
    case .nilLiteralExpr:
      return .nilLiteralExpr(NilLiteralExprSyntax(self)!)
    case .discardAssignmentExpr:
      return .discardAssignmentExpr(DiscardAssignmentExprSyntax(self)!)
    case .assignmentExpr:
      return .assignmentExpr(AssignmentExprSyntax(self)!)
    case .sequenceExpr:
      return .sequenceExpr(SequenceExprSyntax(self)!)
    case .exprList:
      return .exprList(ExprListSyntax(self)!)
    case .poundLineExpr:
      return .poundLineExpr(PoundLineExprSyntax(self)!)
    case .poundFileExpr:
      return .poundFileExpr(PoundFileExprSyntax(self)!)
    case .poundFunctionExpr:
      return .poundFunctionExpr(PoundFunctionExprSyntax(self)!)
    case .poundDsohandleExpr:
      return .poundDsohandleExpr(PoundDsohandleExprSyntax(self)!)
    case .symbolicReferenceExpr:
      return .symbolicReferenceExpr(SymbolicReferenceExprSyntax(self)!)
    case .prefixOperatorExpr:
      return .prefixOperatorExpr(PrefixOperatorExprSyntax(self)!)
    case .binaryOperatorExpr:
      return .binaryOperatorExpr(BinaryOperatorExprSyntax(self)!)
    case .arrowExpr:
      return .arrowExpr(ArrowExprSyntax(self)!)
    case .floatLiteralExpr:
      return .floatLiteralExpr(FloatLiteralExprSyntax(self)!)
    case .tupleExpr:
      return .tupleExpr(TupleExprSyntax(self)!)
    case .arrayExpr:
      return .arrayExpr(ArrayExprSyntax(self)!)
    case .dictionaryExpr:
      return .dictionaryExpr(DictionaryExprSyntax(self)!)
    case .tupleExprElement:
      return .tupleExprElement(TupleExprElementSyntax(self)!)
    case .arrayElement:
      return .arrayElement(ArrayElementSyntax(self)!)
    case .dictionaryElement:
      return .dictionaryElement(DictionaryElementSyntax(self)!)
    case .integerLiteralExpr:
      return .integerLiteralExpr(IntegerLiteralExprSyntax(self)!)
    case .booleanLiteralExpr:
      return .booleanLiteralExpr(BooleanLiteralExprSyntax(self)!)
    case .ternaryExpr:
      return .ternaryExpr(TernaryExprSyntax(self)!)
    case .memberAccessExpr:
      return .memberAccessExpr(MemberAccessExprSyntax(self)!)
    case .isExpr:
      return .isExpr(IsExprSyntax(self)!)
    case .asExpr:
      return .asExpr(AsExprSyntax(self)!)
    case .typeExpr:
      return .typeExpr(TypeExprSyntax(self)!)
    case .closureCaptureItem:
      return .closureCaptureItem(ClosureCaptureItemSyntax(self)!)
    case .closureCaptureItemList:
      return .closureCaptureItemList(ClosureCaptureItemListSyntax(self)!)
    case .closureCaptureSignature:
      return .closureCaptureSignature(ClosureCaptureSignatureSyntax(self)!)
    case .closureParam:
      return .closureParam(ClosureParamSyntax(self)!)
    case .closureParamList:
      return .closureParamList(ClosureParamListSyntax(self)!)
    case .closureSignature:
      return .closureSignature(ClosureSignatureSyntax(self)!)
    case .closureExpr:
      return .closureExpr(ClosureExprSyntax(self)!)
    case .unresolvedPatternExpr:
      return .unresolvedPatternExpr(UnresolvedPatternExprSyntax(self)!)
    case .functionCallExpr:
      return .functionCallExpr(FunctionCallExprSyntax(self)!)
    case .subscriptExpr:
      return .subscriptExpr(SubscriptExprSyntax(self)!)
    case .optionalChainingExpr:
      return .optionalChainingExpr(OptionalChainingExprSyntax(self)!)
    case .forcedValueExpr:
      return .forcedValueExpr(ForcedValueExprSyntax(self)!)
    case .postfixUnaryExpr:
      return .postfixUnaryExpr(PostfixUnaryExprSyntax(self)!)
    case .specializeExpr:
      return .specializeExpr(SpecializeExprSyntax(self)!)
    case .stringSegment:
      return .stringSegment(StringSegmentSyntax(self)!)
    case .expressionSegment:
      return .expressionSegment(ExpressionSegmentSyntax(self)!)
    case .stringLiteralExpr:
      return .stringLiteralExpr(StringLiteralExprSyntax(self)!)
    case .keyPathExpr:
      return .keyPathExpr(KeyPathExprSyntax(self)!)
    case .keyPathBaseExpr:
      return .keyPathBaseExpr(KeyPathBaseExprSyntax(self)!)
    case .objcNamePiece:
      return .objcNamePiece(ObjcNamePieceSyntax(self)!)
    case .objcName:
      return .objcName(ObjcNameSyntax(self)!)
    case .objcKeyPathExpr:
      return .objcKeyPathExpr(ObjcKeyPathExprSyntax(self)!)
    case .objcSelectorExpr:
      return .objcSelectorExpr(ObjcSelectorExprSyntax(self)!)
    case .editorPlaceholderExpr:
      return .editorPlaceholderExpr(EditorPlaceholderExprSyntax(self)!)
    case .objectLiteralExpr:
      return .objectLiteralExpr(ObjectLiteralExprSyntax(self)!)
    case .typeInitializerClause:
      return .typeInitializerClause(TypeInitializerClauseSyntax(self)!)
    case .typealiasDecl:
      return .typealiasDecl(TypealiasDeclSyntax(self)!)
    case .associatedtypeDecl:
      return .associatedtypeDecl(AssociatedtypeDeclSyntax(self)!)
    case .functionParameterList:
      return .functionParameterList(FunctionParameterListSyntax(self)!)
    case .parameterClause:
      return .parameterClause(ParameterClauseSyntax(self)!)
    case .returnClause:
      return .returnClause(ReturnClauseSyntax(self)!)
    case .functionSignature:
      return .functionSignature(FunctionSignatureSyntax(self)!)
    case .ifConfigClause:
      return .ifConfigClause(IfConfigClauseSyntax(self)!)
    case .ifConfigClauseList:
      return .ifConfigClauseList(IfConfigClauseListSyntax(self)!)
    case .ifConfigDecl:
      return .ifConfigDecl(IfConfigDeclSyntax(self)!)
    case .poundErrorDecl:
      return .poundErrorDecl(PoundErrorDeclSyntax(self)!)
    case .poundWarningDecl:
      return .poundWarningDecl(PoundWarningDeclSyntax(self)!)
    case .poundSourceLocation:
      return .poundSourceLocation(PoundSourceLocationSyntax(self)!)
    case .poundSourceLocationArgs:
      return .poundSourceLocationArgs(PoundSourceLocationArgsSyntax(self)!)
    case .declModifier:
      return .declModifier(DeclModifierSyntax(self)!)
    case .inheritedType:
      return .inheritedType(InheritedTypeSyntax(self)!)
    case .inheritedTypeList:
      return .inheritedTypeList(InheritedTypeListSyntax(self)!)
    case .typeInheritanceClause:
      return .typeInheritanceClause(TypeInheritanceClauseSyntax(self)!)
    case .classDecl:
      return .classDecl(ClassDeclSyntax(self)!)
    case .structDecl:
      return .structDecl(StructDeclSyntax(self)!)
    case .protocolDecl:
      return .protocolDecl(ProtocolDeclSyntax(self)!)
    case .extensionDecl:
      return .extensionDecl(ExtensionDeclSyntax(self)!)
    case .memberDeclBlock:
      return .memberDeclBlock(MemberDeclBlockSyntax(self)!)
    case .memberDeclList:
      return .memberDeclList(MemberDeclListSyntax(self)!)
    case .memberDeclListItem:
      return .memberDeclListItem(MemberDeclListItemSyntax(self)!)
    case .sourceFile:
      return .sourceFile(SourceFileSyntax(self)!)
    case .initializerClause:
      return .initializerClause(InitializerClauseSyntax(self)!)
    case .functionParameter:
      return .functionParameter(FunctionParameterSyntax(self)!)
    case .modifierList:
      return .modifierList(ModifierListSyntax(self)!)
    case .functionDecl:
      return .functionDecl(FunctionDeclSyntax(self)!)
    case .initializerDecl:
      return .initializerDecl(InitializerDeclSyntax(self)!)
    case .deinitializerDecl:
      return .deinitializerDecl(DeinitializerDeclSyntax(self)!)
    case .subscriptDecl:
      return .subscriptDecl(SubscriptDeclSyntax(self)!)
    case .accessLevelModifier:
      return .accessLevelModifier(AccessLevelModifierSyntax(self)!)
    case .accessPathComponent:
      return .accessPathComponent(AccessPathComponentSyntax(self)!)
    case .accessPath:
      return .accessPath(AccessPathSyntax(self)!)
    case .importDecl:
      return .importDecl(ImportDeclSyntax(self)!)
    case .accessorParameter:
      return .accessorParameter(AccessorParameterSyntax(self)!)
    case .accessorDecl:
      return .accessorDecl(AccessorDeclSyntax(self)!)
    case .accessorList:
      return .accessorList(AccessorListSyntax(self)!)
    case .accessorBlock:
      return .accessorBlock(AccessorBlockSyntax(self)!)
    case .patternBinding:
      return .patternBinding(PatternBindingSyntax(self)!)
    case .patternBindingList:
      return .patternBindingList(PatternBindingListSyntax(self)!)
    case .variableDecl:
      return .variableDecl(VariableDeclSyntax(self)!)
    case .enumCaseElement:
      return .enumCaseElement(EnumCaseElementSyntax(self)!)
    case .enumCaseElementList:
      return .enumCaseElementList(EnumCaseElementListSyntax(self)!)
    case .enumCaseDecl:
      return .enumCaseDecl(EnumCaseDeclSyntax(self)!)
    case .enumDecl:
      return .enumDecl(EnumDeclSyntax(self)!)
    case .operatorDecl:
      return .operatorDecl(OperatorDeclSyntax(self)!)
    case .identifierList:
      return .identifierList(IdentifierListSyntax(self)!)
    case .operatorPrecedenceAndTypes:
      return .operatorPrecedenceAndTypes(OperatorPrecedenceAndTypesSyntax(self)!)
    case .precedenceGroupDecl:
      return .precedenceGroupDecl(PrecedenceGroupDeclSyntax(self)!)
    case .precedenceGroupAttributeList:
      return .precedenceGroupAttributeList(PrecedenceGroupAttributeListSyntax(self)!)
    case .precedenceGroupRelation:
      return .precedenceGroupRelation(PrecedenceGroupRelationSyntax(self)!)
    case .precedenceGroupNameList:
      return .precedenceGroupNameList(PrecedenceGroupNameListSyntax(self)!)
    case .precedenceGroupNameElement:
      return .precedenceGroupNameElement(PrecedenceGroupNameElementSyntax(self)!)
    case .precedenceGroupAssignment:
      return .precedenceGroupAssignment(PrecedenceGroupAssignmentSyntax(self)!)
    case .precedenceGroupAssociativity:
      return .precedenceGroupAssociativity(PrecedenceGroupAssociativitySyntax(self)!)
    case .tokenList:
      return .tokenList(TokenListSyntax(self)!)
    case .nonEmptyTokenList:
      return .nonEmptyTokenList(NonEmptyTokenListSyntax(self)!)
    case .customAttribute:
      return .customAttribute(CustomAttributeSyntax(self)!)
    case .attribute:
      return .attribute(AttributeSyntax(self)!)
    case .attributeList:
      return .attributeList(AttributeListSyntax(self)!)
    case .specializeAttributeSpecList:
      return .specializeAttributeSpecList(SpecializeAttributeSpecListSyntax(self)!)
    case .labeledSpecializeEntry:
      return .labeledSpecializeEntry(LabeledSpecializeEntrySyntax(self)!)
    case .namedAttributeStringArgument:
      return .namedAttributeStringArgument(NamedAttributeStringArgumentSyntax(self)!)
    case .declName:
      return .declName(DeclNameSyntax(self)!)
    case .implementsAttributeArguments:
      return .implementsAttributeArguments(ImplementsAttributeArgumentsSyntax(self)!)
    case .objCSelectorPiece:
      return .objCSelectorPiece(ObjCSelectorPieceSyntax(self)!)
    case .objCSelector:
      return .objCSelector(ObjCSelectorSyntax(self)!)
    case .continueStmt:
      return .continueStmt(ContinueStmtSyntax(self)!)
    case .whileStmt:
      return .whileStmt(WhileStmtSyntax(self)!)
    case .deferStmt:
      return .deferStmt(DeferStmtSyntax(self)!)
    case .expressionStmt:
      return .expressionStmt(ExpressionStmtSyntax(self)!)
    case .switchCaseList:
      return .switchCaseList(SwitchCaseListSyntax(self)!)
    case .repeatWhileStmt:
      return .repeatWhileStmt(RepeatWhileStmtSyntax(self)!)
    case .guardStmt:
      return .guardStmt(GuardStmtSyntax(self)!)
    case .whereClause:
      return .whereClause(WhereClauseSyntax(self)!)
    case .forInStmt:
      return .forInStmt(ForInStmtSyntax(self)!)
    case .switchStmt:
      return .switchStmt(SwitchStmtSyntax(self)!)
    case .catchClauseList:
      return .catchClauseList(CatchClauseListSyntax(self)!)
    case .doStmt:
      return .doStmt(DoStmtSyntax(self)!)
    case .returnStmt:
      return .returnStmt(ReturnStmtSyntax(self)!)
    case .yieldStmt:
      return .yieldStmt(YieldStmtSyntax(self)!)
    case .yieldList:
      return .yieldList(YieldListSyntax(self)!)
    case .fallthroughStmt:
      return .fallthroughStmt(FallthroughStmtSyntax(self)!)
    case .breakStmt:
      return .breakStmt(BreakStmtSyntax(self)!)
    case .caseItemList:
      return .caseItemList(CaseItemListSyntax(self)!)
    case .conditionElement:
      return .conditionElement(ConditionElementSyntax(self)!)
    case .availabilityCondition:
      return .availabilityCondition(AvailabilityConditionSyntax(self)!)
    case .matchingPatternCondition:
      return .matchingPatternCondition(MatchingPatternConditionSyntax(self)!)
    case .optionalBindingCondition:
      return .optionalBindingCondition(OptionalBindingConditionSyntax(self)!)
    case .conditionElementList:
      return .conditionElementList(ConditionElementListSyntax(self)!)
    case .declarationStmt:
      return .declarationStmt(DeclarationStmtSyntax(self)!)
    case .throwStmt:
      return .throwStmt(ThrowStmtSyntax(self)!)
    case .ifStmt:
      return .ifStmt(IfStmtSyntax(self)!)
    case .elseIfContinuation:
      return .elseIfContinuation(ElseIfContinuationSyntax(self)!)
    case .elseBlock:
      return .elseBlock(ElseBlockSyntax(self)!)
    case .switchCase:
      return .switchCase(SwitchCaseSyntax(self)!)
    case .switchDefaultLabel:
      return .switchDefaultLabel(SwitchDefaultLabelSyntax(self)!)
    case .caseItem:
      return .caseItem(CaseItemSyntax(self)!)
    case .switchCaseLabel:
      return .switchCaseLabel(SwitchCaseLabelSyntax(self)!)
    case .catchClause:
      return .catchClause(CatchClauseSyntax(self)!)
    case .poundAssertStmt:
      return .poundAssertStmt(PoundAssertStmtSyntax(self)!)
    case .genericWhereClause:
      return .genericWhereClause(GenericWhereClauseSyntax(self)!)
    case .genericRequirementList:
      return .genericRequirementList(GenericRequirementListSyntax(self)!)
    case .genericRequirement:
      return .genericRequirement(GenericRequirementSyntax(self)!)
    case .sameTypeRequirement:
      return .sameTypeRequirement(SameTypeRequirementSyntax(self)!)
    case .genericParameterList:
      return .genericParameterList(GenericParameterListSyntax(self)!)
    case .genericParameter:
      return .genericParameter(GenericParameterSyntax(self)!)
    case .genericParameterClause:
      return .genericParameterClause(GenericParameterClauseSyntax(self)!)
    case .conformanceRequirement:
      return .conformanceRequirement(ConformanceRequirementSyntax(self)!)
    case .simpleTypeIdentifier:
      return .simpleTypeIdentifier(SimpleTypeIdentifierSyntax(self)!)
    case .memberTypeIdentifier:
      return .memberTypeIdentifier(MemberTypeIdentifierSyntax(self)!)
    case .classRestrictionType:
      return .classRestrictionType(ClassRestrictionTypeSyntax(self)!)
    case .arrayType:
      return .arrayType(ArrayTypeSyntax(self)!)
    case .dictionaryType:
      return .dictionaryType(DictionaryTypeSyntax(self)!)
    case .metatypeType:
      return .metatypeType(MetatypeTypeSyntax(self)!)
    case .optionalType:
      return .optionalType(OptionalTypeSyntax(self)!)
    case .someType:
      return .someType(SomeTypeSyntax(self)!)
    case .implicitlyUnwrappedOptionalType:
      return .implicitlyUnwrappedOptionalType(ImplicitlyUnwrappedOptionalTypeSyntax(self)!)
    case .compositionTypeElement:
      return .compositionTypeElement(CompositionTypeElementSyntax(self)!)
    case .compositionTypeElementList:
      return .compositionTypeElementList(CompositionTypeElementListSyntax(self)!)
    case .compositionType:
      return .compositionType(CompositionTypeSyntax(self)!)
    case .tupleTypeElement:
      return .tupleTypeElement(TupleTypeElementSyntax(self)!)
    case .tupleTypeElementList:
      return .tupleTypeElementList(TupleTypeElementListSyntax(self)!)
    case .tupleType:
      return .tupleType(TupleTypeSyntax(self)!)
    case .functionType:
      return .functionType(FunctionTypeSyntax(self)!)
    case .attributedType:
      return .attributedType(AttributedTypeSyntax(self)!)
    case .genericArgumentList:
      return .genericArgumentList(GenericArgumentListSyntax(self)!)
    case .genericArgument:
      return .genericArgument(GenericArgumentSyntax(self)!)
    case .genericArgumentClause:
      return .genericArgumentClause(GenericArgumentClauseSyntax(self)!)
    case .typeAnnotation:
      return .typeAnnotation(TypeAnnotationSyntax(self)!)
    case .enumCasePattern:
      return .enumCasePattern(EnumCasePatternSyntax(self)!)
    case .isTypePattern:
      return .isTypePattern(IsTypePatternSyntax(self)!)
    case .optionalPattern:
      return .optionalPattern(OptionalPatternSyntax(self)!)
    case .identifierPattern:
      return .identifierPattern(IdentifierPatternSyntax(self)!)
    case .asTypePattern:
      return .asTypePattern(AsTypePatternSyntax(self)!)
    case .tuplePattern:
      return .tuplePattern(TuplePatternSyntax(self)!)
    case .wildcardPattern:
      return .wildcardPattern(WildcardPatternSyntax(self)!)
    case .tuplePatternElement:
      return .tuplePatternElement(TuplePatternElementSyntax(self)!)
    case .expressionPattern:
      return .expressionPattern(ExpressionPatternSyntax(self)!)
    case .tuplePatternElementList:
      return .tuplePatternElementList(TuplePatternElementListSyntax(self)!)
    case .valueBindingPattern:
      return .valueBindingPattern(ValueBindingPatternSyntax(self)!)
    case .availabilitySpecList:
      return .availabilitySpecList(AvailabilitySpecListSyntax(self)!)
    case .availabilityArgument:
      return .availabilityArgument(AvailabilityArgumentSyntax(self)!)
    case .availabilityLabeledArgument:
      return .availabilityLabeledArgument(AvailabilityLabeledArgumentSyntax(self)!)
    case .availabilityVersionRestriction:
      return .availabilityVersionRestriction(AvailabilityVersionRestrictionSyntax(self)!)
    case .versionTuple:
      return .versionTuple(VersionTupleSyntax(self)!)
    }
  }

  /// Retrieve the concretely typed node that this Syntax node wraps.
  /// This property is exposed for testing purposes only.
  var _asConcreteType: Any {
    switch self.asSyntaxEnum {
    case .token(let node):
      return node
    case .unknown(let node):
      return node
    case .decl(let node):
      return node
    case .expr(let node):
      return node
    case .stmt(let node):
      return node
    case .type(let node):
      return node
    case .pattern(let node):
      return node
    case .unknownDecl(let node):
      return node
    case .unknownExpr(let node):
      return node
    case .unknownStmt(let node):
      return node
    case .unknownType(let node):
      return node
    case .unknownPattern(let node):
      return node
    case .codeBlockItem(let node):
      return node
    case .codeBlockItemList(let node):
      return node
    case .codeBlock(let node):
      return node
    case .inOutExpr(let node):
      return node
    case .poundColumnExpr(let node):
      return node
    case .tupleExprElementList(let node):
      return node
    case .arrayElementList(let node):
      return node
    case .dictionaryElementList(let node):
      return node
    case .stringLiteralSegments(let node):
      return node
    case .tryExpr(let node):
      return node
    case .declNameArgument(let node):
      return node
    case .declNameArgumentList(let node):
      return node
    case .declNameArguments(let node):
      return node
    case .identifierExpr(let node):
      return node
    case .superRefExpr(let node):
      return node
    case .nilLiteralExpr(let node):
      return node
    case .discardAssignmentExpr(let node):
      return node
    case .assignmentExpr(let node):
      return node
    case .sequenceExpr(let node):
      return node
    case .exprList(let node):
      return node
    case .poundLineExpr(let node):
      return node
    case .poundFileExpr(let node):
      return node
    case .poundFunctionExpr(let node):
      return node
    case .poundDsohandleExpr(let node):
      return node
    case .symbolicReferenceExpr(let node):
      return node
    case .prefixOperatorExpr(let node):
      return node
    case .binaryOperatorExpr(let node):
      return node
    case .arrowExpr(let node):
      return node
    case .floatLiteralExpr(let node):
      return node
    case .tupleExpr(let node):
      return node
    case .arrayExpr(let node):
      return node
    case .dictionaryExpr(let node):
      return node
    case .tupleExprElement(let node):
      return node
    case .arrayElement(let node):
      return node
    case .dictionaryElement(let node):
      return node
    case .integerLiteralExpr(let node):
      return node
    case .booleanLiteralExpr(let node):
      return node
    case .ternaryExpr(let node):
      return node
    case .memberAccessExpr(let node):
      return node
    case .isExpr(let node):
      return node
    case .asExpr(let node):
      return node
    case .typeExpr(let node):
      return node
    case .closureCaptureItem(let node):
      return node
    case .closureCaptureItemList(let node):
      return node
    case .closureCaptureSignature(let node):
      return node
    case .closureParam(let node):
      return node
    case .closureParamList(let node):
      return node
    case .closureSignature(let node):
      return node
    case .closureExpr(let node):
      return node
    case .unresolvedPatternExpr(let node):
      return node
    case .functionCallExpr(let node):
      return node
    case .subscriptExpr(let node):
      return node
    case .optionalChainingExpr(let node):
      return node
    case .forcedValueExpr(let node):
      return node
    case .postfixUnaryExpr(let node):
      return node
    case .specializeExpr(let node):
      return node
    case .stringSegment(let node):
      return node
    case .expressionSegment(let node):
      return node
    case .stringLiteralExpr(let node):
      return node
    case .keyPathExpr(let node):
      return node
    case .keyPathBaseExpr(let node):
      return node
    case .objcNamePiece(let node):
      return node
    case .objcName(let node):
      return node
    case .objcKeyPathExpr(let node):
      return node
    case .objcSelectorExpr(let node):
      return node
    case .editorPlaceholderExpr(let node):
      return node
    case .objectLiteralExpr(let node):
      return node
    case .typeInitializerClause(let node):
      return node
    case .typealiasDecl(let node):
      return node
    case .associatedtypeDecl(let node):
      return node
    case .functionParameterList(let node):
      return node
    case .parameterClause(let node):
      return node
    case .returnClause(let node):
      return node
    case .functionSignature(let node):
      return node
    case .ifConfigClause(let node):
      return node
    case .ifConfigClauseList(let node):
      return node
    case .ifConfigDecl(let node):
      return node
    case .poundErrorDecl(let node):
      return node
    case .poundWarningDecl(let node):
      return node
    case .poundSourceLocation(let node):
      return node
    case .poundSourceLocationArgs(let node):
      return node
    case .declModifier(let node):
      return node
    case .inheritedType(let node):
      return node
    case .inheritedTypeList(let node):
      return node
    case .typeInheritanceClause(let node):
      return node
    case .classDecl(let node):
      return node
    case .structDecl(let node):
      return node
    case .protocolDecl(let node):
      return node
    case .extensionDecl(let node):
      return node
    case .memberDeclBlock(let node):
      return node
    case .memberDeclList(let node):
      return node
    case .memberDeclListItem(let node):
      return node
    case .sourceFile(let node):
      return node
    case .initializerClause(let node):
      return node
    case .functionParameter(let node):
      return node
    case .modifierList(let node):
      return node
    case .functionDecl(let node):
      return node
    case .initializerDecl(let node):
      return node
    case .deinitializerDecl(let node):
      return node
    case .subscriptDecl(let node):
      return node
    case .accessLevelModifier(let node):
      return node
    case .accessPathComponent(let node):
      return node
    case .accessPath(let node):
      return node
    case .importDecl(let node):
      return node
    case .accessorParameter(let node):
      return node
    case .accessorDecl(let node):
      return node
    case .accessorList(let node):
      return node
    case .accessorBlock(let node):
      return node
    case .patternBinding(let node):
      return node
    case .patternBindingList(let node):
      return node
    case .variableDecl(let node):
      return node
    case .enumCaseElement(let node):
      return node
    case .enumCaseElementList(let node):
      return node
    case .enumCaseDecl(let node):
      return node
    case .enumDecl(let node):
      return node
    case .operatorDecl(let node):
      return node
    case .identifierList(let node):
      return node
    case .operatorPrecedenceAndTypes(let node):
      return node
    case .precedenceGroupDecl(let node):
      return node
    case .precedenceGroupAttributeList(let node):
      return node
    case .precedenceGroupRelation(let node):
      return node
    case .precedenceGroupNameList(let node):
      return node
    case .precedenceGroupNameElement(let node):
      return node
    case .precedenceGroupAssignment(let node):
      return node
    case .precedenceGroupAssociativity(let node):
      return node
    case .tokenList(let node):
      return node
    case .nonEmptyTokenList(let node):
      return node
    case .customAttribute(let node):
      return node
    case .attribute(let node):
      return node
    case .attributeList(let node):
      return node
    case .specializeAttributeSpecList(let node):
      return node
    case .labeledSpecializeEntry(let node):
      return node
    case .namedAttributeStringArgument(let node):
      return node
    case .declName(let node):
      return node
    case .implementsAttributeArguments(let node):
      return node
    case .objCSelectorPiece(let node):
      return node
    case .objCSelector(let node):
      return node
    case .continueStmt(let node):
      return node
    case .whileStmt(let node):
      return node
    case .deferStmt(let node):
      return node
    case .expressionStmt(let node):
      return node
    case .switchCaseList(let node):
      return node
    case .repeatWhileStmt(let node):
      return node
    case .guardStmt(let node):
      return node
    case .whereClause(let node):
      return node
    case .forInStmt(let node):
      return node
    case .switchStmt(let node):
      return node
    case .catchClauseList(let node):
      return node
    case .doStmt(let node):
      return node
    case .returnStmt(let node):
      return node
    case .yieldStmt(let node):
      return node
    case .yieldList(let node):
      return node
    case .fallthroughStmt(let node):
      return node
    case .breakStmt(let node):
      return node
    case .caseItemList(let node):
      return node
    case .conditionElement(let node):
      return node
    case .availabilityCondition(let node):
      return node
    case .matchingPatternCondition(let node):
      return node
    case .optionalBindingCondition(let node):
      return node
    case .conditionElementList(let node):
      return node
    case .declarationStmt(let node):
      return node
    case .throwStmt(let node):
      return node
    case .ifStmt(let node):
      return node
    case .elseIfContinuation(let node):
      return node
    case .elseBlock(let node):
      return node
    case .switchCase(let node):
      return node
    case .switchDefaultLabel(let node):
      return node
    case .caseItem(let node):
      return node
    case .switchCaseLabel(let node):
      return node
    case .catchClause(let node):
      return node
    case .poundAssertStmt(let node):
      return node
    case .genericWhereClause(let node):
      return node
    case .genericRequirementList(let node):
      return node
    case .genericRequirement(let node):
      return node
    case .sameTypeRequirement(let node):
      return node
    case .genericParameterList(let node):
      return node
    case .genericParameter(let node):
      return node
    case .genericParameterClause(let node):
      return node
    case .conformanceRequirement(let node):
      return node
    case .simpleTypeIdentifier(let node):
      return node
    case .memberTypeIdentifier(let node):
      return node
    case .classRestrictionType(let node):
      return node
    case .arrayType(let node):
      return node
    case .dictionaryType(let node):
      return node
    case .metatypeType(let node):
      return node
    case .optionalType(let node):
      return node
    case .someType(let node):
      return node
    case .implicitlyUnwrappedOptionalType(let node):
      return node
    case .compositionTypeElement(let node):
      return node
    case .compositionTypeElementList(let node):
      return node
    case .compositionType(let node):
      return node
    case .tupleTypeElement(let node):
      return node
    case .tupleTypeElementList(let node):
      return node
    case .tupleType(let node):
      return node
    case .functionType(let node):
      return node
    case .attributedType(let node):
      return node
    case .genericArgumentList(let node):
      return node
    case .genericArgument(let node):
      return node
    case .genericArgumentClause(let node):
      return node
    case .typeAnnotation(let node):
      return node
    case .enumCasePattern(let node):
      return node
    case .isTypePattern(let node):
      return node
    case .optionalPattern(let node):
      return node
    case .identifierPattern(let node):
      return node
    case .asTypePattern(let node):
      return node
    case .tuplePattern(let node):
      return node
    case .wildcardPattern(let node):
      return node
    case .tuplePatternElement(let node):
      return node
    case .expressionPattern(let node):
      return node
    case .tuplePatternElementList(let node):
      return node
    case .valueBindingPattern(let node):
      return node
    case .availabilitySpecList(let node):
      return node
    case .availabilityArgument(let node):
      return node
    case .availabilityLabeledArgument(let node):
      return node
    case .availabilityVersionRestriction(let node):
      return node
    case .versionTuple(let node):
      return node
    }
  }
}

extension Syntax: CustomReflectable {
  /// Reconstructs the real syntax type for this type from the node's kind and 
  /// provides a mirror that reflects this type.
  public var customMirror: Mirror {
    return Mirror(reflecting: self._asConcreteType)
  }
}

extension DeclSyntax: CustomReflectable {
  /// Reconstructs the real syntax type for this type from the node's kind and 
  /// provides a mirror that reflects this type.
  public var customMirror: Mirror {
    return Mirror(reflecting: Syntax(self)._asConcreteType)
  }
}
extension ExprSyntax: CustomReflectable {
  /// Reconstructs the real syntax type for this type from the node's kind and 
  /// provides a mirror that reflects this type.
  public var customMirror: Mirror {
    return Mirror(reflecting: Syntax(self)._asConcreteType)
  }
}
extension StmtSyntax: CustomReflectable {
  /// Reconstructs the real syntax type for this type from the node's kind and 
  /// provides a mirror that reflects this type.
  public var customMirror: Mirror {
    return Mirror(reflecting: Syntax(self)._asConcreteType)
  }
}
extension TypeSyntax: CustomReflectable {
  /// Reconstructs the real syntax type for this type from the node's kind and 
  /// provides a mirror that reflects this type.
  public var customMirror: Mirror {
    return Mirror(reflecting: Syntax(self)._asConcreteType)
  }
}
extension PatternSyntax: CustomReflectable {
  /// Reconstructs the real syntax type for this type from the node's kind and 
  /// provides a mirror that reflects this type.
  public var customMirror: Mirror {
    return Mirror(reflecting: Syntax(self)._asConcreteType)
  }
}
extension UnknownDeclSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
    ])
  }
}
extension UnknownExprSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
    ])
  }
}
extension UnknownStmtSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
    ])
  }
}
extension UnknownTypeSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
    ])
  }
}
extension UnknownPatternSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
    ])
  }
}
extension CodeBlockItemSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "item": Syntax(item)._asConcreteType,
      "semicolon": semicolon.map(Syntax.init)?._asConcreteType as Any,
      "errorTokens": errorTokens.map(Syntax.init)?._asConcreteType as Any,
    ])
  }
}
extension CodeBlockSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "leftBrace": Syntax(leftBrace)._asConcreteType,
      "statements": Syntax(statements)._asConcreteType,
      "rightBrace": Syntax(rightBrace)._asConcreteType,
    ])
  }
}
extension InOutExprSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "ampersand": Syntax(ampersand)._asConcreteType,
      "expression": Syntax(expression)._asConcreteType,
    ])
  }
}
extension PoundColumnExprSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "poundColumn": Syntax(poundColumn)._asConcreteType,
    ])
  }
}
extension TryExprSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "tryKeyword": Syntax(tryKeyword)._asConcreteType,
      "questionOrExclamationMark": questionOrExclamationMark.map(Syntax.init)?._asConcreteType as Any,
      "expression": Syntax(expression)._asConcreteType,
    ])
  }
}
extension DeclNameArgumentSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "name": Syntax(name)._asConcreteType,
      "colon": Syntax(colon)._asConcreteType,
    ])
  }
}
extension DeclNameArgumentsSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "leftParen": Syntax(leftParen)._asConcreteType,
      "arguments": Syntax(arguments)._asConcreteType,
      "rightParen": Syntax(rightParen)._asConcreteType,
    ])
  }
}
extension IdentifierExprSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "identifier": Syntax(identifier)._asConcreteType,
      "declNameArguments": declNameArguments.map(Syntax.init)?._asConcreteType as Any,
    ])
  }
}
extension SuperRefExprSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "superKeyword": Syntax(superKeyword)._asConcreteType,
    ])
  }
}
extension NilLiteralExprSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "nilKeyword": Syntax(nilKeyword)._asConcreteType,
    ])
  }
}
extension DiscardAssignmentExprSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "wildcard": Syntax(wildcard)._asConcreteType,
    ])
  }
}
extension AssignmentExprSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "assignToken": Syntax(assignToken)._asConcreteType,
    ])
  }
}
extension SequenceExprSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "elements": Syntax(elements)._asConcreteType,
    ])
  }
}
extension PoundLineExprSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "poundLine": Syntax(poundLine)._asConcreteType,
    ])
  }
}
extension PoundFileExprSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "poundFile": Syntax(poundFile)._asConcreteType,
    ])
  }
}
extension PoundFunctionExprSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "poundFunction": Syntax(poundFunction)._asConcreteType,
    ])
  }
}
extension PoundDsohandleExprSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "poundDsohandle": Syntax(poundDsohandle)._asConcreteType,
    ])
  }
}
extension SymbolicReferenceExprSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "identifier": Syntax(identifier)._asConcreteType,
      "genericArgumentClause": genericArgumentClause.map(Syntax.init)?._asConcreteType as Any,
    ])
  }
}
extension PrefixOperatorExprSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "operatorToken": operatorToken.map(Syntax.init)?._asConcreteType as Any,
      "postfixExpression": Syntax(postfixExpression)._asConcreteType,
    ])
  }
}
extension BinaryOperatorExprSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "operatorToken": Syntax(operatorToken)._asConcreteType,
    ])
  }
}
extension ArrowExprSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "throwsToken": throwsToken.map(Syntax.init)?._asConcreteType as Any,
      "arrowToken": Syntax(arrowToken)._asConcreteType,
    ])
  }
}
extension FloatLiteralExprSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "floatingDigits": Syntax(floatingDigits)._asConcreteType,
    ])
  }
}
extension TupleExprSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "leftParen": Syntax(leftParen)._asConcreteType,
      "elementList": Syntax(elementList)._asConcreteType,
      "rightParen": Syntax(rightParen)._asConcreteType,
    ])
  }
}
extension ArrayExprSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "leftSquare": Syntax(leftSquare)._asConcreteType,
      "elements": Syntax(elements)._asConcreteType,
      "rightSquare": Syntax(rightSquare)._asConcreteType,
    ])
  }
}
extension DictionaryExprSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "leftSquare": Syntax(leftSquare)._asConcreteType,
      "content": Syntax(content)._asConcreteType,
      "rightSquare": Syntax(rightSquare)._asConcreteType,
    ])
  }
}
extension TupleExprElementSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "label": label.map(Syntax.init)?._asConcreteType as Any,
      "colon": colon.map(Syntax.init)?._asConcreteType as Any,
      "expression": Syntax(expression)._asConcreteType,
      "trailingComma": trailingComma.map(Syntax.init)?._asConcreteType as Any,
    ])
  }
}
extension ArrayElementSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "expression": Syntax(expression)._asConcreteType,
      "trailingComma": trailingComma.map(Syntax.init)?._asConcreteType as Any,
    ])
  }
}
extension DictionaryElementSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "keyExpression": Syntax(keyExpression)._asConcreteType,
      "colon": Syntax(colon)._asConcreteType,
      "valueExpression": Syntax(valueExpression)._asConcreteType,
      "trailingComma": trailingComma.map(Syntax.init)?._asConcreteType as Any,
    ])
  }
}
extension IntegerLiteralExprSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "digits": Syntax(digits)._asConcreteType,
    ])
  }
}
extension BooleanLiteralExprSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "booleanLiteral": Syntax(booleanLiteral)._asConcreteType,
    ])
  }
}
extension TernaryExprSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "conditionExpression": Syntax(conditionExpression)._asConcreteType,
      "questionMark": Syntax(questionMark)._asConcreteType,
      "firstChoice": Syntax(firstChoice)._asConcreteType,
      "colonMark": Syntax(colonMark)._asConcreteType,
      "secondChoice": Syntax(secondChoice)._asConcreteType,
    ])
  }
}
extension MemberAccessExprSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "base": base.map(Syntax.init)?._asConcreteType as Any,
      "dot": Syntax(dot)._asConcreteType,
      "name": Syntax(name)._asConcreteType,
      "declNameArguments": declNameArguments.map(Syntax.init)?._asConcreteType as Any,
    ])
  }
}
extension IsExprSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "isTok": Syntax(isTok)._asConcreteType,
      "typeName": Syntax(typeName)._asConcreteType,
    ])
  }
}
extension AsExprSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "asTok": Syntax(asTok)._asConcreteType,
      "questionOrExclamationMark": questionOrExclamationMark.map(Syntax.init)?._asConcreteType as Any,
      "typeName": Syntax(typeName)._asConcreteType,
    ])
  }
}
extension TypeExprSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "type": Syntax(type)._asConcreteType,
    ])
  }
}
extension ClosureCaptureItemSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "specifier": specifier.map(Syntax.init)?._asConcreteType as Any,
      "name": name.map(Syntax.init)?._asConcreteType as Any,
      "assignToken": assignToken.map(Syntax.init)?._asConcreteType as Any,
      "expression": Syntax(expression)._asConcreteType,
      "trailingComma": trailingComma.map(Syntax.init)?._asConcreteType as Any,
    ])
  }
}
extension ClosureCaptureSignatureSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "leftSquare": Syntax(leftSquare)._asConcreteType,
      "items": items.map(Syntax.init)?._asConcreteType as Any,
      "rightSquare": Syntax(rightSquare)._asConcreteType,
    ])
  }
}
extension ClosureParamSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "name": Syntax(name)._asConcreteType,
      "trailingComma": trailingComma.map(Syntax.init)?._asConcreteType as Any,
    ])
  }
}
extension ClosureSignatureSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "capture": capture.map(Syntax.init)?._asConcreteType as Any,
      "input": input.map(Syntax.init)?._asConcreteType as Any,
      "throwsTok": throwsTok.map(Syntax.init)?._asConcreteType as Any,
      "output": output.map(Syntax.init)?._asConcreteType as Any,
      "inTok": Syntax(inTok)._asConcreteType,
    ])
  }
}
extension ClosureExprSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "leftBrace": Syntax(leftBrace)._asConcreteType,
      "signature": signature.map(Syntax.init)?._asConcreteType as Any,
      "statements": Syntax(statements)._asConcreteType,
      "rightBrace": Syntax(rightBrace)._asConcreteType,
    ])
  }
}
extension UnresolvedPatternExprSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "pattern": Syntax(pattern)._asConcreteType,
    ])
  }
}
extension FunctionCallExprSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "calledExpression": Syntax(calledExpression)._asConcreteType,
      "leftParen": leftParen.map(Syntax.init)?._asConcreteType as Any,
      "argumentList": Syntax(argumentList)._asConcreteType,
      "rightParen": rightParen.map(Syntax.init)?._asConcreteType as Any,
      "trailingClosure": trailingClosure.map(Syntax.init)?._asConcreteType as Any,
    ])
  }
}
extension SubscriptExprSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "calledExpression": Syntax(calledExpression)._asConcreteType,
      "leftBracket": Syntax(leftBracket)._asConcreteType,
      "argumentList": Syntax(argumentList)._asConcreteType,
      "rightBracket": Syntax(rightBracket)._asConcreteType,
      "trailingClosure": trailingClosure.map(Syntax.init)?._asConcreteType as Any,
    ])
  }
}
extension OptionalChainingExprSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "expression": Syntax(expression)._asConcreteType,
      "questionMark": Syntax(questionMark)._asConcreteType,
    ])
  }
}
extension ForcedValueExprSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "expression": Syntax(expression)._asConcreteType,
      "exclamationMark": Syntax(exclamationMark)._asConcreteType,
    ])
  }
}
extension PostfixUnaryExprSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "expression": Syntax(expression)._asConcreteType,
      "operatorToken": Syntax(operatorToken)._asConcreteType,
    ])
  }
}
extension SpecializeExprSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "expression": Syntax(expression)._asConcreteType,
      "genericArgumentClause": Syntax(genericArgumentClause)._asConcreteType,
    ])
  }
}
extension StringSegmentSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "content": Syntax(content)._asConcreteType,
    ])
  }
}
extension ExpressionSegmentSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "backslash": Syntax(backslash)._asConcreteType,
      "delimiter": delimiter.map(Syntax.init)?._asConcreteType as Any,
      "leftParen": Syntax(leftParen)._asConcreteType,
      "expressions": Syntax(expressions)._asConcreteType,
      "rightParen": Syntax(rightParen)._asConcreteType,
    ])
  }
}
extension StringLiteralExprSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "openDelimiter": openDelimiter.map(Syntax.init)?._asConcreteType as Any,
      "openQuote": Syntax(openQuote)._asConcreteType,
      "segments": Syntax(segments)._asConcreteType,
      "closeQuote": Syntax(closeQuote)._asConcreteType,
      "closeDelimiter": closeDelimiter.map(Syntax.init)?._asConcreteType as Any,
    ])
  }
}
extension KeyPathExprSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "backslash": Syntax(backslash)._asConcreteType,
      "rootExpr": rootExpr.map(Syntax.init)?._asConcreteType as Any,
      "expression": Syntax(expression)._asConcreteType,
    ])
  }
}
extension KeyPathBaseExprSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "period": Syntax(period)._asConcreteType,
    ])
  }
}
extension ObjcNamePieceSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "name": Syntax(name)._asConcreteType,
      "dot": dot.map(Syntax.init)?._asConcreteType as Any,
    ])
  }
}
extension ObjcKeyPathExprSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "keyPath": Syntax(keyPath)._asConcreteType,
      "leftParen": Syntax(leftParen)._asConcreteType,
      "name": Syntax(name)._asConcreteType,
      "rightParen": Syntax(rightParen)._asConcreteType,
    ])
  }
}
extension ObjcSelectorExprSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "poundSelector": Syntax(poundSelector)._asConcreteType,
      "leftParen": Syntax(leftParen)._asConcreteType,
      "kind": kind.map(Syntax.init)?._asConcreteType as Any,
      "colon": colon.map(Syntax.init)?._asConcreteType as Any,
      "name": Syntax(name)._asConcreteType,
      "rightParen": Syntax(rightParen)._asConcreteType,
    ])
  }
}
extension EditorPlaceholderExprSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "identifier": Syntax(identifier)._asConcreteType,
    ])
  }
}
extension ObjectLiteralExprSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "identifier": Syntax(identifier)._asConcreteType,
      "leftParen": Syntax(leftParen)._asConcreteType,
      "arguments": Syntax(arguments)._asConcreteType,
      "rightParen": Syntax(rightParen)._asConcreteType,
    ])
  }
}
extension TypeInitializerClauseSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "equal": Syntax(equal)._asConcreteType,
      "value": Syntax(value)._asConcreteType,
    ])
  }
}
extension TypealiasDeclSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "attributes": attributes.map(Syntax.init)?._asConcreteType as Any,
      "modifiers": modifiers.map(Syntax.init)?._asConcreteType as Any,
      "typealiasKeyword": Syntax(typealiasKeyword)._asConcreteType,
      "identifier": Syntax(identifier)._asConcreteType,
      "genericParameterClause": genericParameterClause.map(Syntax.init)?._asConcreteType as Any,
      "initializer": initializer.map(Syntax.init)?._asConcreteType as Any,
      "genericWhereClause": genericWhereClause.map(Syntax.init)?._asConcreteType as Any,
    ])
  }
}
extension AssociatedtypeDeclSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "attributes": attributes.map(Syntax.init)?._asConcreteType as Any,
      "modifiers": modifiers.map(Syntax.init)?._asConcreteType as Any,
      "associatedtypeKeyword": Syntax(associatedtypeKeyword)._asConcreteType,
      "identifier": Syntax(identifier)._asConcreteType,
      "inheritanceClause": inheritanceClause.map(Syntax.init)?._asConcreteType as Any,
      "initializer": initializer.map(Syntax.init)?._asConcreteType as Any,
      "genericWhereClause": genericWhereClause.map(Syntax.init)?._asConcreteType as Any,
    ])
  }
}
extension ParameterClauseSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "leftParen": Syntax(leftParen)._asConcreteType,
      "parameterList": Syntax(parameterList)._asConcreteType,
      "rightParen": Syntax(rightParen)._asConcreteType,
    ])
  }
}
extension ReturnClauseSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "arrow": Syntax(arrow)._asConcreteType,
      "returnType": Syntax(returnType)._asConcreteType,
    ])
  }
}
extension FunctionSignatureSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "input": Syntax(input)._asConcreteType,
      "throwsOrRethrowsKeyword": throwsOrRethrowsKeyword.map(Syntax.init)?._asConcreteType as Any,
      "output": output.map(Syntax.init)?._asConcreteType as Any,
    ])
  }
}
extension IfConfigClauseSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "poundKeyword": Syntax(poundKeyword)._asConcreteType,
      "condition": condition.map(Syntax.init)?._asConcreteType as Any,
      "elements": Syntax(elements)._asConcreteType,
    ])
  }
}
extension IfConfigDeclSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "clauses": Syntax(clauses)._asConcreteType,
      "poundEndif": Syntax(poundEndif)._asConcreteType,
    ])
  }
}
extension PoundErrorDeclSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "poundError": Syntax(poundError)._asConcreteType,
      "leftParen": Syntax(leftParen)._asConcreteType,
      "message": Syntax(message)._asConcreteType,
      "rightParen": Syntax(rightParen)._asConcreteType,
    ])
  }
}
extension PoundWarningDeclSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "poundWarning": Syntax(poundWarning)._asConcreteType,
      "leftParen": Syntax(leftParen)._asConcreteType,
      "message": Syntax(message)._asConcreteType,
      "rightParen": Syntax(rightParen)._asConcreteType,
    ])
  }
}
extension PoundSourceLocationSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "poundSourceLocation": Syntax(poundSourceLocation)._asConcreteType,
      "leftParen": Syntax(leftParen)._asConcreteType,
      "args": args.map(Syntax.init)?._asConcreteType as Any,
      "rightParen": Syntax(rightParen)._asConcreteType,
    ])
  }
}
extension PoundSourceLocationArgsSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "fileArgLabel": Syntax(fileArgLabel)._asConcreteType,
      "fileArgColon": Syntax(fileArgColon)._asConcreteType,
      "fileName": Syntax(fileName)._asConcreteType,
      "comma": Syntax(comma)._asConcreteType,
      "lineArgLabel": Syntax(lineArgLabel)._asConcreteType,
      "lineArgColon": Syntax(lineArgColon)._asConcreteType,
      "lineNumber": Syntax(lineNumber)._asConcreteType,
    ])
  }
}
extension DeclModifierSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "name": Syntax(name)._asConcreteType,
      "detailLeftParen": detailLeftParen.map(Syntax.init)?._asConcreteType as Any,
      "detail": detail.map(Syntax.init)?._asConcreteType as Any,
      "detailRightParen": detailRightParen.map(Syntax.init)?._asConcreteType as Any,
    ])
  }
}
extension InheritedTypeSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "typeName": Syntax(typeName)._asConcreteType,
      "trailingComma": trailingComma.map(Syntax.init)?._asConcreteType as Any,
    ])
  }
}
extension TypeInheritanceClauseSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "colon": Syntax(colon)._asConcreteType,
      "inheritedTypeCollection": Syntax(inheritedTypeCollection)._asConcreteType,
    ])
  }
}
extension ClassDeclSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "attributes": attributes.map(Syntax.init)?._asConcreteType as Any,
      "modifiers": modifiers.map(Syntax.init)?._asConcreteType as Any,
      "classKeyword": Syntax(classKeyword)._asConcreteType,
      "identifier": Syntax(identifier)._asConcreteType,
      "genericParameterClause": genericParameterClause.map(Syntax.init)?._asConcreteType as Any,
      "inheritanceClause": inheritanceClause.map(Syntax.init)?._asConcreteType as Any,
      "genericWhereClause": genericWhereClause.map(Syntax.init)?._asConcreteType as Any,
      "members": Syntax(members)._asConcreteType,
    ])
  }
}
extension StructDeclSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "attributes": attributes.map(Syntax.init)?._asConcreteType as Any,
      "modifiers": modifiers.map(Syntax.init)?._asConcreteType as Any,
      "structKeyword": Syntax(structKeyword)._asConcreteType,
      "identifier": Syntax(identifier)._asConcreteType,
      "genericParameterClause": genericParameterClause.map(Syntax.init)?._asConcreteType as Any,
      "inheritanceClause": inheritanceClause.map(Syntax.init)?._asConcreteType as Any,
      "genericWhereClause": genericWhereClause.map(Syntax.init)?._asConcreteType as Any,
      "members": Syntax(members)._asConcreteType,
    ])
  }
}
extension ProtocolDeclSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "attributes": attributes.map(Syntax.init)?._asConcreteType as Any,
      "modifiers": modifiers.map(Syntax.init)?._asConcreteType as Any,
      "protocolKeyword": Syntax(protocolKeyword)._asConcreteType,
      "identifier": Syntax(identifier)._asConcreteType,
      "inheritanceClause": inheritanceClause.map(Syntax.init)?._asConcreteType as Any,
      "genericWhereClause": genericWhereClause.map(Syntax.init)?._asConcreteType as Any,
      "members": Syntax(members)._asConcreteType,
    ])
  }
}
extension ExtensionDeclSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "attributes": attributes.map(Syntax.init)?._asConcreteType as Any,
      "modifiers": modifiers.map(Syntax.init)?._asConcreteType as Any,
      "extensionKeyword": Syntax(extensionKeyword)._asConcreteType,
      "extendedType": Syntax(extendedType)._asConcreteType,
      "inheritanceClause": inheritanceClause.map(Syntax.init)?._asConcreteType as Any,
      "genericWhereClause": genericWhereClause.map(Syntax.init)?._asConcreteType as Any,
      "members": Syntax(members)._asConcreteType,
    ])
  }
}
extension MemberDeclBlockSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "leftBrace": Syntax(leftBrace)._asConcreteType,
      "members": Syntax(members)._asConcreteType,
      "rightBrace": Syntax(rightBrace)._asConcreteType,
    ])
  }
}
extension MemberDeclListItemSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "decl": Syntax(decl)._asConcreteType,
      "semicolon": semicolon.map(Syntax.init)?._asConcreteType as Any,
    ])
  }
}
extension SourceFileSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "statements": Syntax(statements)._asConcreteType,
      "eofToken": Syntax(eofToken)._asConcreteType,
    ])
  }
}
extension InitializerClauseSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "equal": Syntax(equal)._asConcreteType,
      "value": Syntax(value)._asConcreteType,
    ])
  }
}
extension FunctionParameterSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "attributes": attributes.map(Syntax.init)?._asConcreteType as Any,
      "firstName": firstName.map(Syntax.init)?._asConcreteType as Any,
      "secondName": secondName.map(Syntax.init)?._asConcreteType as Any,
      "colon": colon.map(Syntax.init)?._asConcreteType as Any,
      "type": type.map(Syntax.init)?._asConcreteType as Any,
      "ellipsis": ellipsis.map(Syntax.init)?._asConcreteType as Any,
      "defaultArgument": defaultArgument.map(Syntax.init)?._asConcreteType as Any,
      "trailingComma": trailingComma.map(Syntax.init)?._asConcreteType as Any,
    ])
  }
}
extension FunctionDeclSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "attributes": attributes.map(Syntax.init)?._asConcreteType as Any,
      "modifiers": modifiers.map(Syntax.init)?._asConcreteType as Any,
      "funcKeyword": Syntax(funcKeyword)._asConcreteType,
      "identifier": Syntax(identifier)._asConcreteType,
      "genericParameterClause": genericParameterClause.map(Syntax.init)?._asConcreteType as Any,
      "signature": Syntax(signature)._asConcreteType,
      "genericWhereClause": genericWhereClause.map(Syntax.init)?._asConcreteType as Any,
      "body": body.map(Syntax.init)?._asConcreteType as Any,
    ])
  }
}
extension InitializerDeclSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "attributes": attributes.map(Syntax.init)?._asConcreteType as Any,
      "modifiers": modifiers.map(Syntax.init)?._asConcreteType as Any,
      "initKeyword": Syntax(initKeyword)._asConcreteType,
      "optionalMark": optionalMark.map(Syntax.init)?._asConcreteType as Any,
      "genericParameterClause": genericParameterClause.map(Syntax.init)?._asConcreteType as Any,
      "parameters": Syntax(parameters)._asConcreteType,
      "throwsOrRethrowsKeyword": throwsOrRethrowsKeyword.map(Syntax.init)?._asConcreteType as Any,
      "genericWhereClause": genericWhereClause.map(Syntax.init)?._asConcreteType as Any,
      "body": body.map(Syntax.init)?._asConcreteType as Any,
    ])
  }
}
extension DeinitializerDeclSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "attributes": attributes.map(Syntax.init)?._asConcreteType as Any,
      "modifiers": modifiers.map(Syntax.init)?._asConcreteType as Any,
      "deinitKeyword": Syntax(deinitKeyword)._asConcreteType,
      "body": Syntax(body)._asConcreteType,
    ])
  }
}
extension SubscriptDeclSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "attributes": attributes.map(Syntax.init)?._asConcreteType as Any,
      "modifiers": modifiers.map(Syntax.init)?._asConcreteType as Any,
      "subscriptKeyword": Syntax(subscriptKeyword)._asConcreteType,
      "genericParameterClause": genericParameterClause.map(Syntax.init)?._asConcreteType as Any,
      "indices": Syntax(indices)._asConcreteType,
      "result": Syntax(result)._asConcreteType,
      "genericWhereClause": genericWhereClause.map(Syntax.init)?._asConcreteType as Any,
      "accessor": accessor.map(Syntax.init)?._asConcreteType as Any,
    ])
  }
}
extension AccessLevelModifierSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "name": Syntax(name)._asConcreteType,
      "leftParen": leftParen.map(Syntax.init)?._asConcreteType as Any,
      "modifier": modifier.map(Syntax.init)?._asConcreteType as Any,
      "rightParen": rightParen.map(Syntax.init)?._asConcreteType as Any,
    ])
  }
}
extension AccessPathComponentSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "name": Syntax(name)._asConcreteType,
      "trailingDot": trailingDot.map(Syntax.init)?._asConcreteType as Any,
    ])
  }
}
extension ImportDeclSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "attributes": attributes.map(Syntax.init)?._asConcreteType as Any,
      "modifiers": modifiers.map(Syntax.init)?._asConcreteType as Any,
      "importTok": Syntax(importTok)._asConcreteType,
      "importKind": importKind.map(Syntax.init)?._asConcreteType as Any,
      "path": Syntax(path)._asConcreteType,
    ])
  }
}
extension AccessorParameterSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "leftParen": Syntax(leftParen)._asConcreteType,
      "name": Syntax(name)._asConcreteType,
      "rightParen": Syntax(rightParen)._asConcreteType,
    ])
  }
}
extension AccessorDeclSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "attributes": attributes.map(Syntax.init)?._asConcreteType as Any,
      "modifier": modifier.map(Syntax.init)?._asConcreteType as Any,
      "accessorKind": Syntax(accessorKind)._asConcreteType,
      "parameter": parameter.map(Syntax.init)?._asConcreteType as Any,
      "body": body.map(Syntax.init)?._asConcreteType as Any,
    ])
  }
}
extension AccessorBlockSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "leftBrace": Syntax(leftBrace)._asConcreteType,
      "accessors": Syntax(accessors)._asConcreteType,
      "rightBrace": Syntax(rightBrace)._asConcreteType,
    ])
  }
}
extension PatternBindingSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "pattern": Syntax(pattern)._asConcreteType,
      "typeAnnotation": typeAnnotation.map(Syntax.init)?._asConcreteType as Any,
      "initializer": initializer.map(Syntax.init)?._asConcreteType as Any,
      "accessor": accessor.map(Syntax.init)?._asConcreteType as Any,
      "trailingComma": trailingComma.map(Syntax.init)?._asConcreteType as Any,
    ])
  }
}
extension VariableDeclSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "attributes": attributes.map(Syntax.init)?._asConcreteType as Any,
      "modifiers": modifiers.map(Syntax.init)?._asConcreteType as Any,
      "letOrVarKeyword": Syntax(letOrVarKeyword)._asConcreteType,
      "bindings": Syntax(bindings)._asConcreteType,
    ])
  }
}
extension EnumCaseElementSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "identifier": Syntax(identifier)._asConcreteType,
      "associatedValue": associatedValue.map(Syntax.init)?._asConcreteType as Any,
      "rawValue": rawValue.map(Syntax.init)?._asConcreteType as Any,
      "trailingComma": trailingComma.map(Syntax.init)?._asConcreteType as Any,
    ])
  }
}
extension EnumCaseDeclSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "attributes": attributes.map(Syntax.init)?._asConcreteType as Any,
      "modifiers": modifiers.map(Syntax.init)?._asConcreteType as Any,
      "caseKeyword": Syntax(caseKeyword)._asConcreteType,
      "elements": Syntax(elements)._asConcreteType,
    ])
  }
}
extension EnumDeclSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "attributes": attributes.map(Syntax.init)?._asConcreteType as Any,
      "modifiers": modifiers.map(Syntax.init)?._asConcreteType as Any,
      "enumKeyword": Syntax(enumKeyword)._asConcreteType,
      "identifier": Syntax(identifier)._asConcreteType,
      "genericParameters": genericParameters.map(Syntax.init)?._asConcreteType as Any,
      "inheritanceClause": inheritanceClause.map(Syntax.init)?._asConcreteType as Any,
      "genericWhereClause": genericWhereClause.map(Syntax.init)?._asConcreteType as Any,
      "members": Syntax(members)._asConcreteType,
    ])
  }
}
extension OperatorDeclSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "attributes": attributes.map(Syntax.init)?._asConcreteType as Any,
      "modifiers": modifiers.map(Syntax.init)?._asConcreteType as Any,
      "operatorKeyword": Syntax(operatorKeyword)._asConcreteType,
      "identifier": Syntax(identifier)._asConcreteType,
      "operatorPrecedenceAndTypes": operatorPrecedenceAndTypes.map(Syntax.init)?._asConcreteType as Any,
    ])
  }
}
extension OperatorPrecedenceAndTypesSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "colon": Syntax(colon)._asConcreteType,
      "precedenceGroupAndDesignatedTypes": Syntax(precedenceGroupAndDesignatedTypes)._asConcreteType,
    ])
  }
}
extension PrecedenceGroupDeclSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "attributes": attributes.map(Syntax.init)?._asConcreteType as Any,
      "modifiers": modifiers.map(Syntax.init)?._asConcreteType as Any,
      "precedencegroupKeyword": Syntax(precedencegroupKeyword)._asConcreteType,
      "identifier": Syntax(identifier)._asConcreteType,
      "leftBrace": Syntax(leftBrace)._asConcreteType,
      "groupAttributes": Syntax(groupAttributes)._asConcreteType,
      "rightBrace": Syntax(rightBrace)._asConcreteType,
    ])
  }
}
extension PrecedenceGroupRelationSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "higherThanOrLowerThan": Syntax(higherThanOrLowerThan)._asConcreteType,
      "colon": Syntax(colon)._asConcreteType,
      "otherNames": Syntax(otherNames)._asConcreteType,
    ])
  }
}
extension PrecedenceGroupNameElementSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "name": Syntax(name)._asConcreteType,
      "trailingComma": trailingComma.map(Syntax.init)?._asConcreteType as Any,
    ])
  }
}
extension PrecedenceGroupAssignmentSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "assignmentKeyword": Syntax(assignmentKeyword)._asConcreteType,
      "colon": Syntax(colon)._asConcreteType,
      "flag": Syntax(flag)._asConcreteType,
    ])
  }
}
extension PrecedenceGroupAssociativitySyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "associativityKeyword": Syntax(associativityKeyword)._asConcreteType,
      "colon": Syntax(colon)._asConcreteType,
      "value": Syntax(value)._asConcreteType,
    ])
  }
}
extension CustomAttributeSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "atSignToken": Syntax(atSignToken)._asConcreteType,
      "attributeName": Syntax(attributeName)._asConcreteType,
      "leftParen": leftParen.map(Syntax.init)?._asConcreteType as Any,
      "argumentList": argumentList.map(Syntax.init)?._asConcreteType as Any,
      "rightParen": rightParen.map(Syntax.init)?._asConcreteType as Any,
    ])
  }
}
extension AttributeSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "atSignToken": Syntax(atSignToken)._asConcreteType,
      "attributeName": Syntax(attributeName)._asConcreteType,
      "leftParen": leftParen.map(Syntax.init)?._asConcreteType as Any,
      "argument": argument.map(Syntax.init)?._asConcreteType as Any,
      "rightParen": rightParen.map(Syntax.init)?._asConcreteType as Any,
      "tokenList": tokenList.map(Syntax.init)?._asConcreteType as Any,
    ])
  }
}
extension LabeledSpecializeEntrySyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "label": Syntax(label)._asConcreteType,
      "colon": Syntax(colon)._asConcreteType,
      "value": Syntax(value)._asConcreteType,
      "trailingComma": trailingComma.map(Syntax.init)?._asConcreteType as Any,
    ])
  }
}
extension NamedAttributeStringArgumentSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "nameTok": Syntax(nameTok)._asConcreteType,
      "colon": Syntax(colon)._asConcreteType,
      "stringOrDeclname": Syntax(stringOrDeclname)._asConcreteType,
    ])
  }
}
extension DeclNameSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "declBaseName": Syntax(declBaseName)._asConcreteType,
      "declNameArguments": declNameArguments.map(Syntax.init)?._asConcreteType as Any,
    ])
  }
}
extension ImplementsAttributeArgumentsSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "type": Syntax(type)._asConcreteType,
      "comma": Syntax(comma)._asConcreteType,
      "declBaseName": Syntax(declBaseName)._asConcreteType,
      "declNameArguments": declNameArguments.map(Syntax.init)?._asConcreteType as Any,
    ])
  }
}
extension ObjCSelectorPieceSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "name": name.map(Syntax.init)?._asConcreteType as Any,
      "colon": colon.map(Syntax.init)?._asConcreteType as Any,
    ])
  }
}
extension ContinueStmtSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "continueKeyword": Syntax(continueKeyword)._asConcreteType,
      "label": label.map(Syntax.init)?._asConcreteType as Any,
    ])
  }
}
extension WhileStmtSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "labelName": labelName.map(Syntax.init)?._asConcreteType as Any,
      "labelColon": labelColon.map(Syntax.init)?._asConcreteType as Any,
      "whileKeyword": Syntax(whileKeyword)._asConcreteType,
      "conditions": Syntax(conditions)._asConcreteType,
      "body": Syntax(body)._asConcreteType,
    ])
  }
}
extension DeferStmtSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "deferKeyword": Syntax(deferKeyword)._asConcreteType,
      "body": Syntax(body)._asConcreteType,
    ])
  }
}
extension ExpressionStmtSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "expression": Syntax(expression)._asConcreteType,
    ])
  }
}
extension RepeatWhileStmtSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "labelName": labelName.map(Syntax.init)?._asConcreteType as Any,
      "labelColon": labelColon.map(Syntax.init)?._asConcreteType as Any,
      "repeatKeyword": Syntax(repeatKeyword)._asConcreteType,
      "body": Syntax(body)._asConcreteType,
      "whileKeyword": Syntax(whileKeyword)._asConcreteType,
      "condition": Syntax(condition)._asConcreteType,
    ])
  }
}
extension GuardStmtSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "guardKeyword": Syntax(guardKeyword)._asConcreteType,
      "conditions": Syntax(conditions)._asConcreteType,
      "elseKeyword": Syntax(elseKeyword)._asConcreteType,
      "body": Syntax(body)._asConcreteType,
    ])
  }
}
extension WhereClauseSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "whereKeyword": Syntax(whereKeyword)._asConcreteType,
      "guardResult": Syntax(guardResult)._asConcreteType,
    ])
  }
}
extension ForInStmtSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "labelName": labelName.map(Syntax.init)?._asConcreteType as Any,
      "labelColon": labelColon.map(Syntax.init)?._asConcreteType as Any,
      "forKeyword": Syntax(forKeyword)._asConcreteType,
      "caseKeyword": caseKeyword.map(Syntax.init)?._asConcreteType as Any,
      "pattern": Syntax(pattern)._asConcreteType,
      "typeAnnotation": typeAnnotation.map(Syntax.init)?._asConcreteType as Any,
      "inKeyword": Syntax(inKeyword)._asConcreteType,
      "sequenceExpr": Syntax(sequenceExpr)._asConcreteType,
      "whereClause": whereClause.map(Syntax.init)?._asConcreteType as Any,
      "body": Syntax(body)._asConcreteType,
    ])
  }
}
extension SwitchStmtSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "labelName": labelName.map(Syntax.init)?._asConcreteType as Any,
      "labelColon": labelColon.map(Syntax.init)?._asConcreteType as Any,
      "switchKeyword": Syntax(switchKeyword)._asConcreteType,
      "expression": Syntax(expression)._asConcreteType,
      "leftBrace": Syntax(leftBrace)._asConcreteType,
      "cases": Syntax(cases)._asConcreteType,
      "rightBrace": Syntax(rightBrace)._asConcreteType,
    ])
  }
}
extension DoStmtSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "labelName": labelName.map(Syntax.init)?._asConcreteType as Any,
      "labelColon": labelColon.map(Syntax.init)?._asConcreteType as Any,
      "doKeyword": Syntax(doKeyword)._asConcreteType,
      "body": Syntax(body)._asConcreteType,
      "catchClauses": catchClauses.map(Syntax.init)?._asConcreteType as Any,
    ])
  }
}
extension ReturnStmtSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "returnKeyword": Syntax(returnKeyword)._asConcreteType,
      "expression": expression.map(Syntax.init)?._asConcreteType as Any,
    ])
  }
}
extension YieldStmtSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "yieldKeyword": Syntax(yieldKeyword)._asConcreteType,
      "yields": Syntax(yields)._asConcreteType,
    ])
  }
}
extension YieldListSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "leftParen": Syntax(leftParen)._asConcreteType,
      "elementList": Syntax(elementList)._asConcreteType,
      "trailingComma": trailingComma.map(Syntax.init)?._asConcreteType as Any,
      "rightParen": Syntax(rightParen)._asConcreteType,
    ])
  }
}
extension FallthroughStmtSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "fallthroughKeyword": Syntax(fallthroughKeyword)._asConcreteType,
    ])
  }
}
extension BreakStmtSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "breakKeyword": Syntax(breakKeyword)._asConcreteType,
      "label": label.map(Syntax.init)?._asConcreteType as Any,
    ])
  }
}
extension ConditionElementSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "condition": Syntax(condition)._asConcreteType,
      "trailingComma": trailingComma.map(Syntax.init)?._asConcreteType as Any,
    ])
  }
}
extension AvailabilityConditionSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "poundAvailableKeyword": Syntax(poundAvailableKeyword)._asConcreteType,
      "leftParen": Syntax(leftParen)._asConcreteType,
      "availabilitySpec": Syntax(availabilitySpec)._asConcreteType,
      "rightParen": Syntax(rightParen)._asConcreteType,
    ])
  }
}
extension MatchingPatternConditionSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "caseKeyword": Syntax(caseKeyword)._asConcreteType,
      "pattern": Syntax(pattern)._asConcreteType,
      "typeAnnotation": typeAnnotation.map(Syntax.init)?._asConcreteType as Any,
      "initializer": Syntax(initializer)._asConcreteType,
    ])
  }
}
extension OptionalBindingConditionSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "letOrVarKeyword": Syntax(letOrVarKeyword)._asConcreteType,
      "pattern": Syntax(pattern)._asConcreteType,
      "typeAnnotation": typeAnnotation.map(Syntax.init)?._asConcreteType as Any,
      "initializer": Syntax(initializer)._asConcreteType,
    ])
  }
}
extension DeclarationStmtSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "declaration": Syntax(declaration)._asConcreteType,
    ])
  }
}
extension ThrowStmtSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "throwKeyword": Syntax(throwKeyword)._asConcreteType,
      "expression": Syntax(expression)._asConcreteType,
    ])
  }
}
extension IfStmtSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "labelName": labelName.map(Syntax.init)?._asConcreteType as Any,
      "labelColon": labelColon.map(Syntax.init)?._asConcreteType as Any,
      "ifKeyword": Syntax(ifKeyword)._asConcreteType,
      "conditions": Syntax(conditions)._asConcreteType,
      "body": Syntax(body)._asConcreteType,
      "elseKeyword": elseKeyword.map(Syntax.init)?._asConcreteType as Any,
      "elseBody": elseBody.map(Syntax.init)?._asConcreteType as Any,
    ])
  }
}
extension ElseIfContinuationSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "ifStatement": Syntax(ifStatement)._asConcreteType,
    ])
  }
}
extension ElseBlockSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "elseKeyword": Syntax(elseKeyword)._asConcreteType,
      "body": Syntax(body)._asConcreteType,
    ])
  }
}
extension SwitchCaseSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "unknownAttr": unknownAttr.map(Syntax.init)?._asConcreteType as Any,
      "label": Syntax(label)._asConcreteType,
      "statements": Syntax(statements)._asConcreteType,
    ])
  }
}
extension SwitchDefaultLabelSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "defaultKeyword": Syntax(defaultKeyword)._asConcreteType,
      "colon": Syntax(colon)._asConcreteType,
    ])
  }
}
extension CaseItemSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "pattern": Syntax(pattern)._asConcreteType,
      "whereClause": whereClause.map(Syntax.init)?._asConcreteType as Any,
      "trailingComma": trailingComma.map(Syntax.init)?._asConcreteType as Any,
    ])
  }
}
extension SwitchCaseLabelSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "caseKeyword": Syntax(caseKeyword)._asConcreteType,
      "caseItems": Syntax(caseItems)._asConcreteType,
      "colon": Syntax(colon)._asConcreteType,
    ])
  }
}
extension CatchClauseSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "catchKeyword": Syntax(catchKeyword)._asConcreteType,
      "pattern": pattern.map(Syntax.init)?._asConcreteType as Any,
      "whereClause": whereClause.map(Syntax.init)?._asConcreteType as Any,
      "body": Syntax(body)._asConcreteType,
    ])
  }
}
extension PoundAssertStmtSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "poundAssert": Syntax(poundAssert)._asConcreteType,
      "leftParen": Syntax(leftParen)._asConcreteType,
      "condition": Syntax(condition)._asConcreteType,
      "comma": comma.map(Syntax.init)?._asConcreteType as Any,
      "message": message.map(Syntax.init)?._asConcreteType as Any,
      "rightParen": Syntax(rightParen)._asConcreteType,
    ])
  }
}
extension GenericWhereClauseSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "whereKeyword": Syntax(whereKeyword)._asConcreteType,
      "requirementList": Syntax(requirementList)._asConcreteType,
    ])
  }
}
extension GenericRequirementSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "body": Syntax(body)._asConcreteType,
      "trailingComma": trailingComma.map(Syntax.init)?._asConcreteType as Any,
    ])
  }
}
extension SameTypeRequirementSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "leftTypeIdentifier": Syntax(leftTypeIdentifier)._asConcreteType,
      "equalityToken": Syntax(equalityToken)._asConcreteType,
      "rightTypeIdentifier": Syntax(rightTypeIdentifier)._asConcreteType,
    ])
  }
}
extension GenericParameterSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "attributes": attributes.map(Syntax.init)?._asConcreteType as Any,
      "name": Syntax(name)._asConcreteType,
      "colon": colon.map(Syntax.init)?._asConcreteType as Any,
      "inheritedType": inheritedType.map(Syntax.init)?._asConcreteType as Any,
      "trailingComma": trailingComma.map(Syntax.init)?._asConcreteType as Any,
    ])
  }
}
extension GenericParameterClauseSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "leftAngleBracket": Syntax(leftAngleBracket)._asConcreteType,
      "genericParameterList": Syntax(genericParameterList)._asConcreteType,
      "rightAngleBracket": Syntax(rightAngleBracket)._asConcreteType,
    ])
  }
}
extension ConformanceRequirementSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "leftTypeIdentifier": Syntax(leftTypeIdentifier)._asConcreteType,
      "colon": Syntax(colon)._asConcreteType,
      "rightTypeIdentifier": Syntax(rightTypeIdentifier)._asConcreteType,
    ])
  }
}
extension SimpleTypeIdentifierSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "name": Syntax(name)._asConcreteType,
      "genericArgumentClause": genericArgumentClause.map(Syntax.init)?._asConcreteType as Any,
    ])
  }
}
extension MemberTypeIdentifierSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "baseType": Syntax(baseType)._asConcreteType,
      "period": Syntax(period)._asConcreteType,
      "name": Syntax(name)._asConcreteType,
      "genericArgumentClause": genericArgumentClause.map(Syntax.init)?._asConcreteType as Any,
    ])
  }
}
extension ClassRestrictionTypeSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "classKeyword": Syntax(classKeyword)._asConcreteType,
    ])
  }
}
extension ArrayTypeSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "leftSquareBracket": Syntax(leftSquareBracket)._asConcreteType,
      "elementType": Syntax(elementType)._asConcreteType,
      "rightSquareBracket": Syntax(rightSquareBracket)._asConcreteType,
    ])
  }
}
extension DictionaryTypeSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "leftSquareBracket": Syntax(leftSquareBracket)._asConcreteType,
      "keyType": Syntax(keyType)._asConcreteType,
      "colon": Syntax(colon)._asConcreteType,
      "valueType": Syntax(valueType)._asConcreteType,
      "rightSquareBracket": Syntax(rightSquareBracket)._asConcreteType,
    ])
  }
}
extension MetatypeTypeSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "baseType": Syntax(baseType)._asConcreteType,
      "period": Syntax(period)._asConcreteType,
      "typeOrProtocol": Syntax(typeOrProtocol)._asConcreteType,
    ])
  }
}
extension OptionalTypeSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "wrappedType": Syntax(wrappedType)._asConcreteType,
      "questionMark": Syntax(questionMark)._asConcreteType,
    ])
  }
}
extension SomeTypeSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "someSpecifier": Syntax(someSpecifier)._asConcreteType,
      "baseType": Syntax(baseType)._asConcreteType,
    ])
  }
}
extension ImplicitlyUnwrappedOptionalTypeSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "wrappedType": Syntax(wrappedType)._asConcreteType,
      "exclamationMark": Syntax(exclamationMark)._asConcreteType,
    ])
  }
}
extension CompositionTypeElementSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "type": Syntax(type)._asConcreteType,
      "ampersand": ampersand.map(Syntax.init)?._asConcreteType as Any,
    ])
  }
}
extension CompositionTypeSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "elements": Syntax(elements)._asConcreteType,
    ])
  }
}
extension TupleTypeElementSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "inOut": inOut.map(Syntax.init)?._asConcreteType as Any,
      "name": name.map(Syntax.init)?._asConcreteType as Any,
      "secondName": secondName.map(Syntax.init)?._asConcreteType as Any,
      "colon": colon.map(Syntax.init)?._asConcreteType as Any,
      "type": Syntax(type)._asConcreteType,
      "ellipsis": ellipsis.map(Syntax.init)?._asConcreteType as Any,
      "initializer": initializer.map(Syntax.init)?._asConcreteType as Any,
      "trailingComma": trailingComma.map(Syntax.init)?._asConcreteType as Any,
    ])
  }
}
extension TupleTypeSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "leftParen": Syntax(leftParen)._asConcreteType,
      "elements": Syntax(elements)._asConcreteType,
      "rightParen": Syntax(rightParen)._asConcreteType,
    ])
  }
}
extension FunctionTypeSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "leftParen": Syntax(leftParen)._asConcreteType,
      "arguments": Syntax(arguments)._asConcreteType,
      "rightParen": Syntax(rightParen)._asConcreteType,
      "throwsOrRethrowsKeyword": throwsOrRethrowsKeyword.map(Syntax.init)?._asConcreteType as Any,
      "arrow": Syntax(arrow)._asConcreteType,
      "returnType": Syntax(returnType)._asConcreteType,
    ])
  }
}
extension AttributedTypeSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "specifier": specifier.map(Syntax.init)?._asConcreteType as Any,
      "attributes": attributes.map(Syntax.init)?._asConcreteType as Any,
      "baseType": Syntax(baseType)._asConcreteType,
    ])
  }
}
extension GenericArgumentSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "argumentType": Syntax(argumentType)._asConcreteType,
      "trailingComma": trailingComma.map(Syntax.init)?._asConcreteType as Any,
    ])
  }
}
extension GenericArgumentClauseSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "leftAngleBracket": Syntax(leftAngleBracket)._asConcreteType,
      "arguments": Syntax(arguments)._asConcreteType,
      "rightAngleBracket": Syntax(rightAngleBracket)._asConcreteType,
    ])
  }
}
extension TypeAnnotationSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "colon": Syntax(colon)._asConcreteType,
      "type": Syntax(type)._asConcreteType,
    ])
  }
}
extension EnumCasePatternSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "type": type.map(Syntax.init)?._asConcreteType as Any,
      "period": Syntax(period)._asConcreteType,
      "caseName": Syntax(caseName)._asConcreteType,
      "associatedTuple": associatedTuple.map(Syntax.init)?._asConcreteType as Any,
    ])
  }
}
extension IsTypePatternSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "isKeyword": Syntax(isKeyword)._asConcreteType,
      "type": Syntax(type)._asConcreteType,
    ])
  }
}
extension OptionalPatternSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "subPattern": Syntax(subPattern)._asConcreteType,
      "questionMark": Syntax(questionMark)._asConcreteType,
    ])
  }
}
extension IdentifierPatternSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "identifier": Syntax(identifier)._asConcreteType,
    ])
  }
}
extension AsTypePatternSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "pattern": Syntax(pattern)._asConcreteType,
      "asKeyword": Syntax(asKeyword)._asConcreteType,
      "type": Syntax(type)._asConcreteType,
    ])
  }
}
extension TuplePatternSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "leftParen": Syntax(leftParen)._asConcreteType,
      "elements": Syntax(elements)._asConcreteType,
      "rightParen": Syntax(rightParen)._asConcreteType,
    ])
  }
}
extension WildcardPatternSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "wildcard": Syntax(wildcard)._asConcreteType,
      "typeAnnotation": typeAnnotation.map(Syntax.init)?._asConcreteType as Any,
    ])
  }
}
extension TuplePatternElementSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "labelName": labelName.map(Syntax.init)?._asConcreteType as Any,
      "labelColon": labelColon.map(Syntax.init)?._asConcreteType as Any,
      "pattern": Syntax(pattern)._asConcreteType,
      "trailingComma": trailingComma.map(Syntax.init)?._asConcreteType as Any,
    ])
  }
}
extension ExpressionPatternSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "expression": Syntax(expression)._asConcreteType,
    ])
  }
}
extension ValueBindingPatternSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "letOrVarKeyword": Syntax(letOrVarKeyword)._asConcreteType,
      "valuePattern": Syntax(valuePattern)._asConcreteType,
    ])
  }
}
extension AvailabilityArgumentSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "entry": Syntax(entry)._asConcreteType,
      "trailingComma": trailingComma.map(Syntax.init)?._asConcreteType as Any,
    ])
  }
}
extension AvailabilityLabeledArgumentSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "label": Syntax(label)._asConcreteType,
      "colon": Syntax(colon)._asConcreteType,
      "value": Syntax(value)._asConcreteType,
    ])
  }
}
extension AvailabilityVersionRestrictionSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "platform": Syntax(platform)._asConcreteType,
      "version": Syntax(version)._asConcreteType,
    ])
  }
}
extension VersionTupleSyntax: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [
      "majorMinor": Syntax(majorMinor)._asConcreteType,
      "patchPeriod": patchPeriod.map(Syntax.init)?._asConcreteType as Any,
      "patchVersion": patchVersion.map(Syntax.init)?._asConcreteType as Any,
    ])
  }
}

public protocol DeclGroupSyntax: SyntaxProtocol {
  var attributes: AttributeListSyntax? { get }
  func withAttributes(_ newChild: AttributeListSyntax?) -> Self
  var modifiers: ModifierListSyntax? { get }
  func withModifiers(_ newChild: ModifierListSyntax?) -> Self
  var members: MemberDeclBlockSyntax { get }
  func withMembers(_ newChild: MemberDeclBlockSyntax?) -> Self
}
public protocol BracedSyntax: SyntaxProtocol {
  var leftBrace: TokenSyntax { get }
  func withLeftBrace(_ newChild: TokenSyntax?) -> Self
  var rightBrace: TokenSyntax { get }
  func withRightBrace(_ newChild: TokenSyntax?) -> Self
}
public protocol IdentifiedDeclSyntax: SyntaxProtocol {
  var identifier: TokenSyntax { get }
  func withIdentifier(_ newChild: TokenSyntax?) -> Self
}
public protocol WithCodeBlockSyntax: SyntaxProtocol {
  var body: CodeBlockSyntax { get }
  func withBody(_ newChild: CodeBlockSyntax?) -> Self
}
public protocol ParenthesizedSyntax: SyntaxProtocol {
  var leftParen: TokenSyntax { get }
  func withLeftParen(_ newChild: TokenSyntax?) -> Self
  var rightParen: TokenSyntax { get }
  func withRightParen(_ newChild: TokenSyntax?) -> Self
}
public protocol WithTrailingCommaSyntax: SyntaxProtocol {
  var trailingComma: TokenSyntax? { get }
  func withTrailingComma(_ newChild: TokenSyntax?) -> Self
}
public protocol LabeledSyntax: SyntaxProtocol {
  var labelName: TokenSyntax? { get }
  func withLabelName(_ newChild: TokenSyntax?) -> Self
  var labelColon: TokenSyntax? { get }
  func withLabelColon(_ newChild: TokenSyntax?) -> Self
}
public protocol WithStatementsSyntax: SyntaxProtocol {
  var statements: CodeBlockItemListSyntax { get }
  func withStatements(_ newChild: CodeBlockItemListSyntax?) -> Self
}

extension CodeBlockSyntax: BracedSyntax, WithStatementsSyntax {}
extension DeclNameArgumentsSyntax: ParenthesizedSyntax {}
extension TupleExprSyntax: ParenthesizedSyntax {}
extension TupleExprElementSyntax: WithTrailingCommaSyntax {}
extension ArrayElementSyntax: WithTrailingCommaSyntax {}
extension DictionaryElementSyntax: WithTrailingCommaSyntax {}
extension ClosureCaptureItemSyntax: WithTrailingCommaSyntax {}
extension ClosureParamSyntax: WithTrailingCommaSyntax {}
extension ClosureExprSyntax: BracedSyntax, WithStatementsSyntax {}
extension ExpressionSegmentSyntax: ParenthesizedSyntax {}
extension ObjcKeyPathExprSyntax: ParenthesizedSyntax {}
extension ObjcSelectorExprSyntax: ParenthesizedSyntax {}
extension ObjectLiteralExprSyntax: ParenthesizedSyntax {}
extension TypealiasDeclSyntax: IdentifiedDeclSyntax {}
extension AssociatedtypeDeclSyntax: IdentifiedDeclSyntax {}
extension ParameterClauseSyntax: ParenthesizedSyntax {}
extension PoundErrorDeclSyntax: ParenthesizedSyntax {}
extension PoundWarningDeclSyntax: ParenthesizedSyntax {}
extension PoundSourceLocationSyntax: ParenthesizedSyntax {}
extension InheritedTypeSyntax: WithTrailingCommaSyntax {}
extension ClassDeclSyntax: DeclGroupSyntax, IdentifiedDeclSyntax {}
extension StructDeclSyntax: DeclGroupSyntax, IdentifiedDeclSyntax {}
extension ProtocolDeclSyntax: DeclGroupSyntax, IdentifiedDeclSyntax {}
extension ExtensionDeclSyntax: DeclGroupSyntax {}
extension MemberDeclBlockSyntax: BracedSyntax {}
extension SourceFileSyntax: WithStatementsSyntax {}
extension FunctionParameterSyntax: WithTrailingCommaSyntax {}
extension FunctionDeclSyntax: IdentifiedDeclSyntax {}
extension AccessorParameterSyntax: ParenthesizedSyntax {}
extension AccessorBlockSyntax: BracedSyntax {}
extension PatternBindingSyntax: WithTrailingCommaSyntax {}
extension EnumCaseElementSyntax: WithTrailingCommaSyntax {}
extension EnumDeclSyntax: IdentifiedDeclSyntax {}
extension OperatorDeclSyntax: IdentifiedDeclSyntax {}
extension PrecedenceGroupDeclSyntax: IdentifiedDeclSyntax {}
extension LabeledSpecializeEntrySyntax: WithTrailingCommaSyntax {}
extension WhileStmtSyntax: WithCodeBlockSyntax, LabeledSyntax {}
extension DeferStmtSyntax: WithCodeBlockSyntax {}
extension RepeatWhileStmtSyntax: WithCodeBlockSyntax, LabeledSyntax {}
extension GuardStmtSyntax: WithCodeBlockSyntax {}
extension ForInStmtSyntax: WithCodeBlockSyntax, LabeledSyntax {}
extension SwitchStmtSyntax: BracedSyntax, LabeledSyntax {}
extension DoStmtSyntax: WithCodeBlockSyntax, LabeledSyntax {}
extension ConditionElementSyntax: WithTrailingCommaSyntax {}
extension IfStmtSyntax: WithCodeBlockSyntax, LabeledSyntax {}
extension ElseBlockSyntax: WithCodeBlockSyntax {}
extension SwitchCaseSyntax: WithStatementsSyntax {}
extension CaseItemSyntax: WithTrailingCommaSyntax {}
extension GenericRequirementSyntax: WithTrailingCommaSyntax {}
extension GenericParameterSyntax: WithTrailingCommaSyntax {}
extension TupleTypeElementSyntax: WithTrailingCommaSyntax {}
extension TupleTypeSyntax: ParenthesizedSyntax {}
extension FunctionTypeSyntax: ParenthesizedSyntax {}
extension GenericArgumentSyntax: WithTrailingCommaSyntax {}
extension TuplePatternSyntax: ParenthesizedSyntax {}
extension TuplePatternElementSyntax: WithTrailingCommaSyntax, LabeledSyntax {}

extension SyntaxNode {
  public var isUnknown: Bool { return raw.kind.isUnknown }
  public var asUnknown: UnknownSyntax? {
    guard isUnknown else { return nil }
    return UnknownSyntax(asSyntaxData)
  }

  public var isUnknownDecl: Bool { return raw.kind == .unknownDecl }
  public var asUnknownDecl: UnknownDeclSyntax? {
    guard isUnknownDecl else { return nil }
    return UnknownDeclSyntax(asSyntaxData)
  }

  public var isUnknownExpr: Bool { return raw.kind == .unknownExpr }
  public var asUnknownExpr: UnknownExprSyntax? {
    guard isUnknownExpr else { return nil }
    return UnknownExprSyntax(asSyntaxData)
  }

  public var isUnknownStmt: Bool { return raw.kind == .unknownStmt }
  public var asUnknownStmt: UnknownStmtSyntax? {
    guard isUnknownStmt else { return nil }
    return UnknownStmtSyntax(asSyntaxData)
  }

  public var isUnknownType: Bool { return raw.kind == .unknownType }
  public var asUnknownType: UnknownTypeSyntax? {
    guard isUnknownType else { return nil }
    return UnknownTypeSyntax(asSyntaxData)
  }

  public var isUnknownPattern: Bool { return raw.kind == .unknownPattern }
  public var asUnknownPattern: UnknownPatternSyntax? {
    guard isUnknownPattern else { return nil }
    return UnknownPatternSyntax(asSyntaxData)
  }

  public var isCodeBlockItem: Bool { return raw.kind == .codeBlockItem }
  public var asCodeBlockItem: CodeBlockItemSyntax? {
    guard isCodeBlockItem else { return nil }
    return CodeBlockItemSyntax(asSyntaxData)
  }

  public var isCodeBlockItemList: Bool { return raw.kind == .codeBlockItemList }
  public var asCodeBlockItemList: CodeBlockItemListSyntax? {
    guard isCodeBlockItemList else { return nil }
    return CodeBlockItemListSyntax(asSyntaxData)
  }

  public var isCodeBlock: Bool { return raw.kind == .codeBlock }
  public var asCodeBlock: CodeBlockSyntax? {
    guard isCodeBlock else { return nil }
    return CodeBlockSyntax(asSyntaxData)
  }

  public var isInOutExpr: Bool { return raw.kind == .inOutExpr }
  public var asInOutExpr: InOutExprSyntax? {
    guard isInOutExpr else { return nil }
    return InOutExprSyntax(asSyntaxData)
  }

  public var isPoundColumnExpr: Bool { return raw.kind == .poundColumnExpr }
  public var asPoundColumnExpr: PoundColumnExprSyntax? {
    guard isPoundColumnExpr else { return nil }
    return PoundColumnExprSyntax(asSyntaxData)
  }

  public var isTupleExprElementList: Bool { return raw.kind == .tupleExprElementList }
  public var asTupleExprElementList: TupleExprElementListSyntax? {
    guard isTupleExprElementList else { return nil }
    return TupleExprElementListSyntax(asSyntaxData)
  }

  public var isArrayElementList: Bool { return raw.kind == .arrayElementList }
  public var asArrayElementList: ArrayElementListSyntax? {
    guard isArrayElementList else { return nil }
    return ArrayElementListSyntax(asSyntaxData)
  }

  public var isDictionaryElementList: Bool { return raw.kind == .dictionaryElementList }
  public var asDictionaryElementList: DictionaryElementListSyntax? {
    guard isDictionaryElementList else { return nil }
    return DictionaryElementListSyntax(asSyntaxData)
  }

  public var isStringLiteralSegments: Bool { return raw.kind == .stringLiteralSegments }
  public var asStringLiteralSegments: StringLiteralSegmentsSyntax? {
    guard isStringLiteralSegments else { return nil }
    return StringLiteralSegmentsSyntax(asSyntaxData)
  }

  public var isTryExpr: Bool { return raw.kind == .tryExpr }
  public var asTryExpr: TryExprSyntax? {
    guard isTryExpr else { return nil }
    return TryExprSyntax(asSyntaxData)
  }

  public var isDeclNameArgument: Bool { return raw.kind == .declNameArgument }
  public var asDeclNameArgument: DeclNameArgumentSyntax? {
    guard isDeclNameArgument else { return nil }
    return DeclNameArgumentSyntax(asSyntaxData)
  }

  public var isDeclNameArgumentList: Bool { return raw.kind == .declNameArgumentList }
  public var asDeclNameArgumentList: DeclNameArgumentListSyntax? {
    guard isDeclNameArgumentList else { return nil }
    return DeclNameArgumentListSyntax(asSyntaxData)
  }

  public var isDeclNameArguments: Bool { return raw.kind == .declNameArguments }
  public var asDeclNameArguments: DeclNameArgumentsSyntax? {
    guard isDeclNameArguments else { return nil }
    return DeclNameArgumentsSyntax(asSyntaxData)
  }

  public var isIdentifierExpr: Bool { return raw.kind == .identifierExpr }
  public var asIdentifierExpr: IdentifierExprSyntax? {
    guard isIdentifierExpr else { return nil }
    return IdentifierExprSyntax(asSyntaxData)
  }

  public var isSuperRefExpr: Bool { return raw.kind == .superRefExpr }
  public var asSuperRefExpr: SuperRefExprSyntax? {
    guard isSuperRefExpr else { return nil }
    return SuperRefExprSyntax(asSyntaxData)
  }

  public var isNilLiteralExpr: Bool { return raw.kind == .nilLiteralExpr }
  public var asNilLiteralExpr: NilLiteralExprSyntax? {
    guard isNilLiteralExpr else { return nil }
    return NilLiteralExprSyntax(asSyntaxData)
  }

  public var isDiscardAssignmentExpr: Bool { return raw.kind == .discardAssignmentExpr }
  public var asDiscardAssignmentExpr: DiscardAssignmentExprSyntax? {
    guard isDiscardAssignmentExpr else { return nil }
    return DiscardAssignmentExprSyntax(asSyntaxData)
  }

  public var isAssignmentExpr: Bool { return raw.kind == .assignmentExpr }
  public var asAssignmentExpr: AssignmentExprSyntax? {
    guard isAssignmentExpr else { return nil }
    return AssignmentExprSyntax(asSyntaxData)
  }

  public var isSequenceExpr: Bool { return raw.kind == .sequenceExpr }
  public var asSequenceExpr: SequenceExprSyntax? {
    guard isSequenceExpr else { return nil }
    return SequenceExprSyntax(asSyntaxData)
  }

  public var isExprList: Bool { return raw.kind == .exprList }
  public var asExprList: ExprListSyntax? {
    guard isExprList else { return nil }
    return ExprListSyntax(asSyntaxData)
  }

  public var isPoundLineExpr: Bool { return raw.kind == .poundLineExpr }
  public var asPoundLineExpr: PoundLineExprSyntax? {
    guard isPoundLineExpr else { return nil }
    return PoundLineExprSyntax(asSyntaxData)
  }

  public var isPoundFileExpr: Bool { return raw.kind == .poundFileExpr }
  public var asPoundFileExpr: PoundFileExprSyntax? {
    guard isPoundFileExpr else { return nil }
    return PoundFileExprSyntax(asSyntaxData)
  }

  public var isPoundFunctionExpr: Bool { return raw.kind == .poundFunctionExpr }
  public var asPoundFunctionExpr: PoundFunctionExprSyntax? {
    guard isPoundFunctionExpr else { return nil }
    return PoundFunctionExprSyntax(asSyntaxData)
  }

  public var isPoundDsohandleExpr: Bool { return raw.kind == .poundDsohandleExpr }
  public var asPoundDsohandleExpr: PoundDsohandleExprSyntax? {
    guard isPoundDsohandleExpr else { return nil }
    return PoundDsohandleExprSyntax(asSyntaxData)
  }

  public var isSymbolicReferenceExpr: Bool { return raw.kind == .symbolicReferenceExpr }
  public var asSymbolicReferenceExpr: SymbolicReferenceExprSyntax? {
    guard isSymbolicReferenceExpr else { return nil }
    return SymbolicReferenceExprSyntax(asSyntaxData)
  }

  public var isPrefixOperatorExpr: Bool { return raw.kind == .prefixOperatorExpr }
  public var asPrefixOperatorExpr: PrefixOperatorExprSyntax? {
    guard isPrefixOperatorExpr else { return nil }
    return PrefixOperatorExprSyntax(asSyntaxData)
  }

  public var isBinaryOperatorExpr: Bool { return raw.kind == .binaryOperatorExpr }
  public var asBinaryOperatorExpr: BinaryOperatorExprSyntax? {
    guard isBinaryOperatorExpr else { return nil }
    return BinaryOperatorExprSyntax(asSyntaxData)
  }

  public var isArrowExpr: Bool { return raw.kind == .arrowExpr }
  public var asArrowExpr: ArrowExprSyntax? {
    guard isArrowExpr else { return nil }
    return ArrowExprSyntax(asSyntaxData)
  }

  public var isFloatLiteralExpr: Bool { return raw.kind == .floatLiteralExpr }
  public var asFloatLiteralExpr: FloatLiteralExprSyntax? {
    guard isFloatLiteralExpr else { return nil }
    return FloatLiteralExprSyntax(asSyntaxData)
  }

  public var isTupleExpr: Bool { return raw.kind == .tupleExpr }
  public var asTupleExpr: TupleExprSyntax? {
    guard isTupleExpr else { return nil }
    return TupleExprSyntax(asSyntaxData)
  }

  public var isArrayExpr: Bool { return raw.kind == .arrayExpr }
  public var asArrayExpr: ArrayExprSyntax? {
    guard isArrayExpr else { return nil }
    return ArrayExprSyntax(asSyntaxData)
  }

  public var isDictionaryExpr: Bool { return raw.kind == .dictionaryExpr }
  public var asDictionaryExpr: DictionaryExprSyntax? {
    guard isDictionaryExpr else { return nil }
    return DictionaryExprSyntax(asSyntaxData)
  }

  public var isTupleExprElement: Bool { return raw.kind == .tupleExprElement }
  public var asTupleExprElement: TupleExprElementSyntax? {
    guard isTupleExprElement else { return nil }
    return TupleExprElementSyntax(asSyntaxData)
  }

  public var isArrayElement: Bool { return raw.kind == .arrayElement }
  public var asArrayElement: ArrayElementSyntax? {
    guard isArrayElement else { return nil }
    return ArrayElementSyntax(asSyntaxData)
  }

  public var isDictionaryElement: Bool { return raw.kind == .dictionaryElement }
  public var asDictionaryElement: DictionaryElementSyntax? {
    guard isDictionaryElement else { return nil }
    return DictionaryElementSyntax(asSyntaxData)
  }

  public var isIntegerLiteralExpr: Bool { return raw.kind == .integerLiteralExpr }
  public var asIntegerLiteralExpr: IntegerLiteralExprSyntax? {
    guard isIntegerLiteralExpr else { return nil }
    return IntegerLiteralExprSyntax(asSyntaxData)
  }

  public var isBooleanLiteralExpr: Bool { return raw.kind == .booleanLiteralExpr }
  public var asBooleanLiteralExpr: BooleanLiteralExprSyntax? {
    guard isBooleanLiteralExpr else { return nil }
    return BooleanLiteralExprSyntax(asSyntaxData)
  }

  public var isTernaryExpr: Bool { return raw.kind == .ternaryExpr }
  public var asTernaryExpr: TernaryExprSyntax? {
    guard isTernaryExpr else { return nil }
    return TernaryExprSyntax(asSyntaxData)
  }

  public var isMemberAccessExpr: Bool { return raw.kind == .memberAccessExpr }
  public var asMemberAccessExpr: MemberAccessExprSyntax? {
    guard isMemberAccessExpr else { return nil }
    return MemberAccessExprSyntax(asSyntaxData)
  }

  public var isIsExpr: Bool { return raw.kind == .isExpr }
  public var asIsExpr: IsExprSyntax? {
    guard isIsExpr else { return nil }
    return IsExprSyntax(asSyntaxData)
  }

  public var isAsExpr: Bool { return raw.kind == .asExpr }
  public var asAsExpr: AsExprSyntax? {
    guard isAsExpr else { return nil }
    return AsExprSyntax(asSyntaxData)
  }

  public var isTypeExpr: Bool { return raw.kind == .typeExpr }
  public var asTypeExpr: TypeExprSyntax? {
    guard isTypeExpr else { return nil }
    return TypeExprSyntax(asSyntaxData)
  }

  public var isClosureCaptureItem: Bool { return raw.kind == .closureCaptureItem }
  public var asClosureCaptureItem: ClosureCaptureItemSyntax? {
    guard isClosureCaptureItem else { return nil }
    return ClosureCaptureItemSyntax(asSyntaxData)
  }

  public var isClosureCaptureItemList: Bool { return raw.kind == .closureCaptureItemList }
  public var asClosureCaptureItemList: ClosureCaptureItemListSyntax? {
    guard isClosureCaptureItemList else { return nil }
    return ClosureCaptureItemListSyntax(asSyntaxData)
  }

  public var isClosureCaptureSignature: Bool { return raw.kind == .closureCaptureSignature }
  public var asClosureCaptureSignature: ClosureCaptureSignatureSyntax? {
    guard isClosureCaptureSignature else { return nil }
    return ClosureCaptureSignatureSyntax(asSyntaxData)
  }

  public var isClosureParam: Bool { return raw.kind == .closureParam }
  public var asClosureParam: ClosureParamSyntax? {
    guard isClosureParam else { return nil }
    return ClosureParamSyntax(asSyntaxData)
  }

  public var isClosureParamList: Bool { return raw.kind == .closureParamList }
  public var asClosureParamList: ClosureParamListSyntax? {
    guard isClosureParamList else { return nil }
    return ClosureParamListSyntax(asSyntaxData)
  }

  public var isClosureSignature: Bool { return raw.kind == .closureSignature }
  public var asClosureSignature: ClosureSignatureSyntax? {
    guard isClosureSignature else { return nil }
    return ClosureSignatureSyntax(asSyntaxData)
  }

  public var isClosureExpr: Bool { return raw.kind == .closureExpr }
  public var asClosureExpr: ClosureExprSyntax? {
    guard isClosureExpr else { return nil }
    return ClosureExprSyntax(asSyntaxData)
  }

  public var isUnresolvedPatternExpr: Bool { return raw.kind == .unresolvedPatternExpr }
  public var asUnresolvedPatternExpr: UnresolvedPatternExprSyntax? {
    guard isUnresolvedPatternExpr else { return nil }
    return UnresolvedPatternExprSyntax(asSyntaxData)
  }

  public var isFunctionCallExpr: Bool { return raw.kind == .functionCallExpr }
  public var asFunctionCallExpr: FunctionCallExprSyntax? {
    guard isFunctionCallExpr else { return nil }
    return FunctionCallExprSyntax(asSyntaxData)
  }

  public var isSubscriptExpr: Bool { return raw.kind == .subscriptExpr }
  public var asSubscriptExpr: SubscriptExprSyntax? {
    guard isSubscriptExpr else { return nil }
    return SubscriptExprSyntax(asSyntaxData)
  }

  public var isOptionalChainingExpr: Bool { return raw.kind == .optionalChainingExpr }
  public var asOptionalChainingExpr: OptionalChainingExprSyntax? {
    guard isOptionalChainingExpr else { return nil }
    return OptionalChainingExprSyntax(asSyntaxData)
  }

  public var isForcedValueExpr: Bool { return raw.kind == .forcedValueExpr }
  public var asForcedValueExpr: ForcedValueExprSyntax? {
    guard isForcedValueExpr else { return nil }
    return ForcedValueExprSyntax(asSyntaxData)
  }

  public var isPostfixUnaryExpr: Bool { return raw.kind == .postfixUnaryExpr }
  public var asPostfixUnaryExpr: PostfixUnaryExprSyntax? {
    guard isPostfixUnaryExpr else { return nil }
    return PostfixUnaryExprSyntax(asSyntaxData)
  }

  public var isSpecializeExpr: Bool { return raw.kind == .specializeExpr }
  public var asSpecializeExpr: SpecializeExprSyntax? {
    guard isSpecializeExpr else { return nil }
    return SpecializeExprSyntax(asSyntaxData)
  }

  public var isStringSegment: Bool { return raw.kind == .stringSegment }
  public var asStringSegment: StringSegmentSyntax? {
    guard isStringSegment else { return nil }
    return StringSegmentSyntax(asSyntaxData)
  }

  public var isExpressionSegment: Bool { return raw.kind == .expressionSegment }
  public var asExpressionSegment: ExpressionSegmentSyntax? {
    guard isExpressionSegment else { return nil }
    return ExpressionSegmentSyntax(asSyntaxData)
  }

  public var isStringLiteralExpr: Bool { return raw.kind == .stringLiteralExpr }
  public var asStringLiteralExpr: StringLiteralExprSyntax? {
    guard isStringLiteralExpr else { return nil }
    return StringLiteralExprSyntax(asSyntaxData)
  }

  public var isKeyPathExpr: Bool { return raw.kind == .keyPathExpr }
  public var asKeyPathExpr: KeyPathExprSyntax? {
    guard isKeyPathExpr else { return nil }
    return KeyPathExprSyntax(asSyntaxData)
  }

  public var isKeyPathBaseExpr: Bool { return raw.kind == .keyPathBaseExpr }
  public var asKeyPathBaseExpr: KeyPathBaseExprSyntax? {
    guard isKeyPathBaseExpr else { return nil }
    return KeyPathBaseExprSyntax(asSyntaxData)
  }

  public var isObjcNamePiece: Bool { return raw.kind == .objcNamePiece }
  public var asObjcNamePiece: ObjcNamePieceSyntax? {
    guard isObjcNamePiece else { return nil }
    return ObjcNamePieceSyntax(asSyntaxData)
  }

  public var isObjcName: Bool { return raw.kind == .objcName }
  public var asObjcName: ObjcNameSyntax? {
    guard isObjcName else { return nil }
    return ObjcNameSyntax(asSyntaxData)
  }

  public var isObjcKeyPathExpr: Bool { return raw.kind == .objcKeyPathExpr }
  public var asObjcKeyPathExpr: ObjcKeyPathExprSyntax? {
    guard isObjcKeyPathExpr else { return nil }
    return ObjcKeyPathExprSyntax(asSyntaxData)
  }

  public var isObjcSelectorExpr: Bool { return raw.kind == .objcSelectorExpr }
  public var asObjcSelectorExpr: ObjcSelectorExprSyntax? {
    guard isObjcSelectorExpr else { return nil }
    return ObjcSelectorExprSyntax(asSyntaxData)
  }

  public var isEditorPlaceholderExpr: Bool { return raw.kind == .editorPlaceholderExpr }
  public var asEditorPlaceholderExpr: EditorPlaceholderExprSyntax? {
    guard isEditorPlaceholderExpr else { return nil }
    return EditorPlaceholderExprSyntax(asSyntaxData)
  }

  public var isObjectLiteralExpr: Bool { return raw.kind == .objectLiteralExpr }
  public var asObjectLiteralExpr: ObjectLiteralExprSyntax? {
    guard isObjectLiteralExpr else { return nil }
    return ObjectLiteralExprSyntax(asSyntaxData)
  }

  public var isTypeInitializerClause: Bool { return raw.kind == .typeInitializerClause }
  public var asTypeInitializerClause: TypeInitializerClauseSyntax? {
    guard isTypeInitializerClause else { return nil }
    return TypeInitializerClauseSyntax(asSyntaxData)
  }

  public var isTypealiasDecl: Bool { return raw.kind == .typealiasDecl }
  public var asTypealiasDecl: TypealiasDeclSyntax? {
    guard isTypealiasDecl else { return nil }
    return TypealiasDeclSyntax(asSyntaxData)
  }

  public var isAssociatedtypeDecl: Bool { return raw.kind == .associatedtypeDecl }
  public var asAssociatedtypeDecl: AssociatedtypeDeclSyntax? {
    guard isAssociatedtypeDecl else { return nil }
    return AssociatedtypeDeclSyntax(asSyntaxData)
  }

  public var isFunctionParameterList: Bool { return raw.kind == .functionParameterList }
  public var asFunctionParameterList: FunctionParameterListSyntax? {
    guard isFunctionParameterList else { return nil }
    return FunctionParameterListSyntax(asSyntaxData)
  }

  public var isParameterClause: Bool { return raw.kind == .parameterClause }
  public var asParameterClause: ParameterClauseSyntax? {
    guard isParameterClause else { return nil }
    return ParameterClauseSyntax(asSyntaxData)
  }

  public var isReturnClause: Bool { return raw.kind == .returnClause }
  public var asReturnClause: ReturnClauseSyntax? {
    guard isReturnClause else { return nil }
    return ReturnClauseSyntax(asSyntaxData)
  }

  public var isFunctionSignature: Bool { return raw.kind == .functionSignature }
  public var asFunctionSignature: FunctionSignatureSyntax? {
    guard isFunctionSignature else { return nil }
    return FunctionSignatureSyntax(asSyntaxData)
  }

  public var isIfConfigClause: Bool { return raw.kind == .ifConfigClause }
  public var asIfConfigClause: IfConfigClauseSyntax? {
    guard isIfConfigClause else { return nil }
    return IfConfigClauseSyntax(asSyntaxData)
  }

  public var isIfConfigClauseList: Bool { return raw.kind == .ifConfigClauseList }
  public var asIfConfigClauseList: IfConfigClauseListSyntax? {
    guard isIfConfigClauseList else { return nil }
    return IfConfigClauseListSyntax(asSyntaxData)
  }

  public var isIfConfigDecl: Bool { return raw.kind == .ifConfigDecl }
  public var asIfConfigDecl: IfConfigDeclSyntax? {
    guard isIfConfigDecl else { return nil }
    return IfConfigDeclSyntax(asSyntaxData)
  }

  public var isPoundErrorDecl: Bool { return raw.kind == .poundErrorDecl }
  public var asPoundErrorDecl: PoundErrorDeclSyntax? {
    guard isPoundErrorDecl else { return nil }
    return PoundErrorDeclSyntax(asSyntaxData)
  }

  public var isPoundWarningDecl: Bool { return raw.kind == .poundWarningDecl }
  public var asPoundWarningDecl: PoundWarningDeclSyntax? {
    guard isPoundWarningDecl else { return nil }
    return PoundWarningDeclSyntax(asSyntaxData)
  }

  public var isPoundSourceLocation: Bool { return raw.kind == .poundSourceLocation }
  public var asPoundSourceLocation: PoundSourceLocationSyntax? {
    guard isPoundSourceLocation else { return nil }
    return PoundSourceLocationSyntax(asSyntaxData)
  }

  public var isPoundSourceLocationArgs: Bool { return raw.kind == .poundSourceLocationArgs }
  public var asPoundSourceLocationArgs: PoundSourceLocationArgsSyntax? {
    guard isPoundSourceLocationArgs else { return nil }
    return PoundSourceLocationArgsSyntax(asSyntaxData)
  }

  public var isDeclModifier: Bool { return raw.kind == .declModifier }
  public var asDeclModifier: DeclModifierSyntax? {
    guard isDeclModifier else { return nil }
    return DeclModifierSyntax(asSyntaxData)
  }

  public var isInheritedType: Bool { return raw.kind == .inheritedType }
  public var asInheritedType: InheritedTypeSyntax? {
    guard isInheritedType else { return nil }
    return InheritedTypeSyntax(asSyntaxData)
  }

  public var isInheritedTypeList: Bool { return raw.kind == .inheritedTypeList }
  public var asInheritedTypeList: InheritedTypeListSyntax? {
    guard isInheritedTypeList else { return nil }
    return InheritedTypeListSyntax(asSyntaxData)
  }

  public var isTypeInheritanceClause: Bool { return raw.kind == .typeInheritanceClause }
  public var asTypeInheritanceClause: TypeInheritanceClauseSyntax? {
    guard isTypeInheritanceClause else { return nil }
    return TypeInheritanceClauseSyntax(asSyntaxData)
  }

  public var isClassDecl: Bool { return raw.kind == .classDecl }
  public var asClassDecl: ClassDeclSyntax? {
    guard isClassDecl else { return nil }
    return ClassDeclSyntax(asSyntaxData)
  }

  public var isStructDecl: Bool { return raw.kind == .structDecl }
  public var asStructDecl: StructDeclSyntax? {
    guard isStructDecl else { return nil }
    return StructDeclSyntax(asSyntaxData)
  }

  public var isProtocolDecl: Bool { return raw.kind == .protocolDecl }
  public var asProtocolDecl: ProtocolDeclSyntax? {
    guard isProtocolDecl else { return nil }
    return ProtocolDeclSyntax(asSyntaxData)
  }

  public var isExtensionDecl: Bool { return raw.kind == .extensionDecl }
  public var asExtensionDecl: ExtensionDeclSyntax? {
    guard isExtensionDecl else { return nil }
    return ExtensionDeclSyntax(asSyntaxData)
  }

  public var isMemberDeclBlock: Bool { return raw.kind == .memberDeclBlock }
  public var asMemberDeclBlock: MemberDeclBlockSyntax? {
    guard isMemberDeclBlock else { return nil }
    return MemberDeclBlockSyntax(asSyntaxData)
  }

  public var isMemberDeclList: Bool { return raw.kind == .memberDeclList }
  public var asMemberDeclList: MemberDeclListSyntax? {
    guard isMemberDeclList else { return nil }
    return MemberDeclListSyntax(asSyntaxData)
  }

  public var isMemberDeclListItem: Bool { return raw.kind == .memberDeclListItem }
  public var asMemberDeclListItem: MemberDeclListItemSyntax? {
    guard isMemberDeclListItem else { return nil }
    return MemberDeclListItemSyntax(asSyntaxData)
  }

  public var isSourceFile: Bool { return raw.kind == .sourceFile }
  public var asSourceFile: SourceFileSyntax? {
    guard isSourceFile else { return nil }
    return SourceFileSyntax(asSyntaxData)
  }

  public var isInitializerClause: Bool { return raw.kind == .initializerClause }
  public var asInitializerClause: InitializerClauseSyntax? {
    guard isInitializerClause else { return nil }
    return InitializerClauseSyntax(asSyntaxData)
  }

  public var isFunctionParameter: Bool { return raw.kind == .functionParameter }
  public var asFunctionParameter: FunctionParameterSyntax? {
    guard isFunctionParameter else { return nil }
    return FunctionParameterSyntax(asSyntaxData)
  }

  public var isModifierList: Bool { return raw.kind == .modifierList }
  public var asModifierList: ModifierListSyntax? {
    guard isModifierList else { return nil }
    return ModifierListSyntax(asSyntaxData)
  }

  public var isFunctionDecl: Bool { return raw.kind == .functionDecl }
  public var asFunctionDecl: FunctionDeclSyntax? {
    guard isFunctionDecl else { return nil }
    return FunctionDeclSyntax(asSyntaxData)
  }

  public var isInitializerDecl: Bool { return raw.kind == .initializerDecl }
  public var asInitializerDecl: InitializerDeclSyntax? {
    guard isInitializerDecl else { return nil }
    return InitializerDeclSyntax(asSyntaxData)
  }

  public var isDeinitializerDecl: Bool { return raw.kind == .deinitializerDecl }
  public var asDeinitializerDecl: DeinitializerDeclSyntax? {
    guard isDeinitializerDecl else { return nil }
    return DeinitializerDeclSyntax(asSyntaxData)
  }

  public var isSubscriptDecl: Bool { return raw.kind == .subscriptDecl }
  public var asSubscriptDecl: SubscriptDeclSyntax? {
    guard isSubscriptDecl else { return nil }
    return SubscriptDeclSyntax(asSyntaxData)
  }

  public var isAccessLevelModifier: Bool { return raw.kind == .accessLevelModifier }
  public var asAccessLevelModifier: AccessLevelModifierSyntax? {
    guard isAccessLevelModifier else { return nil }
    return AccessLevelModifierSyntax(asSyntaxData)
  }

  public var isAccessPathComponent: Bool { return raw.kind == .accessPathComponent }
  public var asAccessPathComponent: AccessPathComponentSyntax? {
    guard isAccessPathComponent else { return nil }
    return AccessPathComponentSyntax(asSyntaxData)
  }

  public var isAccessPath: Bool { return raw.kind == .accessPath }
  public var asAccessPath: AccessPathSyntax? {
    guard isAccessPath else { return nil }
    return AccessPathSyntax(asSyntaxData)
  }

  public var isImportDecl: Bool { return raw.kind == .importDecl }
  public var asImportDecl: ImportDeclSyntax? {
    guard isImportDecl else { return nil }
    return ImportDeclSyntax(asSyntaxData)
  }

  public var isAccessorParameter: Bool { return raw.kind == .accessorParameter }
  public var asAccessorParameter: AccessorParameterSyntax? {
    guard isAccessorParameter else { return nil }
    return AccessorParameterSyntax(asSyntaxData)
  }

  public var isAccessorDecl: Bool { return raw.kind == .accessorDecl }
  public var asAccessorDecl: AccessorDeclSyntax? {
    guard isAccessorDecl else { return nil }
    return AccessorDeclSyntax(asSyntaxData)
  }

  public var isAccessorList: Bool { return raw.kind == .accessorList }
  public var asAccessorList: AccessorListSyntax? {
    guard isAccessorList else { return nil }
    return AccessorListSyntax(asSyntaxData)
  }

  public var isAccessorBlock: Bool { return raw.kind == .accessorBlock }
  public var asAccessorBlock: AccessorBlockSyntax? {
    guard isAccessorBlock else { return nil }
    return AccessorBlockSyntax(asSyntaxData)
  }

  public var isPatternBinding: Bool { return raw.kind == .patternBinding }
  public var asPatternBinding: PatternBindingSyntax? {
    guard isPatternBinding else { return nil }
    return PatternBindingSyntax(asSyntaxData)
  }

  public var isPatternBindingList: Bool { return raw.kind == .patternBindingList }
  public var asPatternBindingList: PatternBindingListSyntax? {
    guard isPatternBindingList else { return nil }
    return PatternBindingListSyntax(asSyntaxData)
  }

  public var isVariableDecl: Bool { return raw.kind == .variableDecl }
  public var asVariableDecl: VariableDeclSyntax? {
    guard isVariableDecl else { return nil }
    return VariableDeclSyntax(asSyntaxData)
  }

  public var isEnumCaseElement: Bool { return raw.kind == .enumCaseElement }
  public var asEnumCaseElement: EnumCaseElementSyntax? {
    guard isEnumCaseElement else { return nil }
    return EnumCaseElementSyntax(asSyntaxData)
  }

  public var isEnumCaseElementList: Bool { return raw.kind == .enumCaseElementList }
  public var asEnumCaseElementList: EnumCaseElementListSyntax? {
    guard isEnumCaseElementList else { return nil }
    return EnumCaseElementListSyntax(asSyntaxData)
  }

  public var isEnumCaseDecl: Bool { return raw.kind == .enumCaseDecl }
  public var asEnumCaseDecl: EnumCaseDeclSyntax? {
    guard isEnumCaseDecl else { return nil }
    return EnumCaseDeclSyntax(asSyntaxData)
  }

  public var isEnumDecl: Bool { return raw.kind == .enumDecl }
  public var asEnumDecl: EnumDeclSyntax? {
    guard isEnumDecl else { return nil }
    return EnumDeclSyntax(asSyntaxData)
  }

  public var isOperatorDecl: Bool { return raw.kind == .operatorDecl }
  public var asOperatorDecl: OperatorDeclSyntax? {
    guard isOperatorDecl else { return nil }
    return OperatorDeclSyntax(asSyntaxData)
  }

  public var isIdentifierList: Bool { return raw.kind == .identifierList }
  public var asIdentifierList: IdentifierListSyntax? {
    guard isIdentifierList else { return nil }
    return IdentifierListSyntax(asSyntaxData)
  }

  public var isOperatorPrecedenceAndTypes: Bool { return raw.kind == .operatorPrecedenceAndTypes }
  public var asOperatorPrecedenceAndTypes: OperatorPrecedenceAndTypesSyntax? {
    guard isOperatorPrecedenceAndTypes else { return nil }
    return OperatorPrecedenceAndTypesSyntax(asSyntaxData)
  }

  public var isPrecedenceGroupDecl: Bool { return raw.kind == .precedenceGroupDecl }
  public var asPrecedenceGroupDecl: PrecedenceGroupDeclSyntax? {
    guard isPrecedenceGroupDecl else { return nil }
    return PrecedenceGroupDeclSyntax(asSyntaxData)
  }

  public var isPrecedenceGroupAttributeList: Bool { return raw.kind == .precedenceGroupAttributeList }
  public var asPrecedenceGroupAttributeList: PrecedenceGroupAttributeListSyntax? {
    guard isPrecedenceGroupAttributeList else { return nil }
    return PrecedenceGroupAttributeListSyntax(asSyntaxData)
  }

  public var isPrecedenceGroupRelation: Bool { return raw.kind == .precedenceGroupRelation }
  public var asPrecedenceGroupRelation: PrecedenceGroupRelationSyntax? {
    guard isPrecedenceGroupRelation else { return nil }
    return PrecedenceGroupRelationSyntax(asSyntaxData)
  }

  public var isPrecedenceGroupNameList: Bool { return raw.kind == .precedenceGroupNameList }
  public var asPrecedenceGroupNameList: PrecedenceGroupNameListSyntax? {
    guard isPrecedenceGroupNameList else { return nil }
    return PrecedenceGroupNameListSyntax(asSyntaxData)
  }

  public var isPrecedenceGroupNameElement: Bool { return raw.kind == .precedenceGroupNameElement }
  public var asPrecedenceGroupNameElement: PrecedenceGroupNameElementSyntax? {
    guard isPrecedenceGroupNameElement else { return nil }
    return PrecedenceGroupNameElementSyntax(asSyntaxData)
  }

  public var isPrecedenceGroupAssignment: Bool { return raw.kind == .precedenceGroupAssignment }
  public var asPrecedenceGroupAssignment: PrecedenceGroupAssignmentSyntax? {
    guard isPrecedenceGroupAssignment else { return nil }
    return PrecedenceGroupAssignmentSyntax(asSyntaxData)
  }

  public var isPrecedenceGroupAssociativity: Bool { return raw.kind == .precedenceGroupAssociativity }
  public var asPrecedenceGroupAssociativity: PrecedenceGroupAssociativitySyntax? {
    guard isPrecedenceGroupAssociativity else { return nil }
    return PrecedenceGroupAssociativitySyntax(asSyntaxData)
  }

  public var isTokenList: Bool { return raw.kind == .tokenList }
  public var asTokenList: TokenListSyntax? {
    guard isTokenList else { return nil }
    return TokenListSyntax(asSyntaxData)
  }

  public var isNonEmptyTokenList: Bool { return raw.kind == .nonEmptyTokenList }
  public var asNonEmptyTokenList: NonEmptyTokenListSyntax? {
    guard isNonEmptyTokenList else { return nil }
    return NonEmptyTokenListSyntax(asSyntaxData)
  }

  public var isCustomAttribute: Bool { return raw.kind == .customAttribute }
  public var asCustomAttribute: CustomAttributeSyntax? {
    guard isCustomAttribute else { return nil }
    return CustomAttributeSyntax(asSyntaxData)
  }

  public var isAttribute: Bool { return raw.kind == .attribute }
  public var asAttribute: AttributeSyntax? {
    guard isAttribute else { return nil }
    return AttributeSyntax(asSyntaxData)
  }

  public var isAttributeList: Bool { return raw.kind == .attributeList }
  public var asAttributeList: AttributeListSyntax? {
    guard isAttributeList else { return nil }
    return AttributeListSyntax(asSyntaxData)
  }

  public var isSpecializeAttributeSpecList: Bool { return raw.kind == .specializeAttributeSpecList }
  public var asSpecializeAttributeSpecList: SpecializeAttributeSpecListSyntax? {
    guard isSpecializeAttributeSpecList else { return nil }
    return SpecializeAttributeSpecListSyntax(asSyntaxData)
  }

  public var isLabeledSpecializeEntry: Bool { return raw.kind == .labeledSpecializeEntry }
  public var asLabeledSpecializeEntry: LabeledSpecializeEntrySyntax? {
    guard isLabeledSpecializeEntry else { return nil }
    return LabeledSpecializeEntrySyntax(asSyntaxData)
  }

  public var isNamedAttributeStringArgument: Bool { return raw.kind == .namedAttributeStringArgument }
  public var asNamedAttributeStringArgument: NamedAttributeStringArgumentSyntax? {
    guard isNamedAttributeStringArgument else { return nil }
    return NamedAttributeStringArgumentSyntax(asSyntaxData)
  }

  public var isDeclName: Bool { return raw.kind == .declName }
  public var asDeclName: DeclNameSyntax? {
    guard isDeclName else { return nil }
    return DeclNameSyntax(asSyntaxData)
  }

  public var isImplementsAttributeArguments: Bool { return raw.kind == .implementsAttributeArguments }
  public var asImplementsAttributeArguments: ImplementsAttributeArgumentsSyntax? {
    guard isImplementsAttributeArguments else { return nil }
    return ImplementsAttributeArgumentsSyntax(asSyntaxData)
  }

  public var isObjCSelectorPiece: Bool { return raw.kind == .objCSelectorPiece }
  public var asObjCSelectorPiece: ObjCSelectorPieceSyntax? {
    guard isObjCSelectorPiece else { return nil }
    return ObjCSelectorPieceSyntax(asSyntaxData)
  }

  public var isObjCSelector: Bool { return raw.kind == .objCSelector }
  public var asObjCSelector: ObjCSelectorSyntax? {
    guard isObjCSelector else { return nil }
    return ObjCSelectorSyntax(asSyntaxData)
  }

  public var isContinueStmt: Bool { return raw.kind == .continueStmt }
  public var asContinueStmt: ContinueStmtSyntax? {
    guard isContinueStmt else { return nil }
    return ContinueStmtSyntax(asSyntaxData)
  }

  public var isWhileStmt: Bool { return raw.kind == .whileStmt }
  public var asWhileStmt: WhileStmtSyntax? {
    guard isWhileStmt else { return nil }
    return WhileStmtSyntax(asSyntaxData)
  }

  public var isDeferStmt: Bool { return raw.kind == .deferStmt }
  public var asDeferStmt: DeferStmtSyntax? {
    guard isDeferStmt else { return nil }
    return DeferStmtSyntax(asSyntaxData)
  }

  public var isExpressionStmt: Bool { return raw.kind == .expressionStmt }
  public var asExpressionStmt: ExpressionStmtSyntax? {
    guard isExpressionStmt else { return nil }
    return ExpressionStmtSyntax(asSyntaxData)
  }

  public var isSwitchCaseList: Bool { return raw.kind == .switchCaseList }
  public var asSwitchCaseList: SwitchCaseListSyntax? {
    guard isSwitchCaseList else { return nil }
    return SwitchCaseListSyntax(asSyntaxData)
  }

  public var isRepeatWhileStmt: Bool { return raw.kind == .repeatWhileStmt }
  public var asRepeatWhileStmt: RepeatWhileStmtSyntax? {
    guard isRepeatWhileStmt else { return nil }
    return RepeatWhileStmtSyntax(asSyntaxData)
  }

  public var isGuardStmt: Bool { return raw.kind == .guardStmt }
  public var asGuardStmt: GuardStmtSyntax? {
    guard isGuardStmt else { return nil }
    return GuardStmtSyntax(asSyntaxData)
  }

  public var isWhereClause: Bool { return raw.kind == .whereClause }
  public var asWhereClause: WhereClauseSyntax? {
    guard isWhereClause else { return nil }
    return WhereClauseSyntax(asSyntaxData)
  }

  public var isForInStmt: Bool { return raw.kind == .forInStmt }
  public var asForInStmt: ForInStmtSyntax? {
    guard isForInStmt else { return nil }
    return ForInStmtSyntax(asSyntaxData)
  }

  public var isSwitchStmt: Bool { return raw.kind == .switchStmt }
  public var asSwitchStmt: SwitchStmtSyntax? {
    guard isSwitchStmt else { return nil }
    return SwitchStmtSyntax(asSyntaxData)
  }

  public var isCatchClauseList: Bool { return raw.kind == .catchClauseList }
  public var asCatchClauseList: CatchClauseListSyntax? {
    guard isCatchClauseList else { return nil }
    return CatchClauseListSyntax(asSyntaxData)
  }

  public var isDoStmt: Bool { return raw.kind == .doStmt }
  public var asDoStmt: DoStmtSyntax? {
    guard isDoStmt else { return nil }
    return DoStmtSyntax(asSyntaxData)
  }

  public var isReturnStmt: Bool { return raw.kind == .returnStmt }
  public var asReturnStmt: ReturnStmtSyntax? {
    guard isReturnStmt else { return nil }
    return ReturnStmtSyntax(asSyntaxData)
  }

  public var isYieldStmt: Bool { return raw.kind == .yieldStmt }
  public var asYieldStmt: YieldStmtSyntax? {
    guard isYieldStmt else { return nil }
    return YieldStmtSyntax(asSyntaxData)
  }

  public var isYieldList: Bool { return raw.kind == .yieldList }
  public var asYieldList: YieldListSyntax? {
    guard isYieldList else { return nil }
    return YieldListSyntax(asSyntaxData)
  }

  public var isFallthroughStmt: Bool { return raw.kind == .fallthroughStmt }
  public var asFallthroughStmt: FallthroughStmtSyntax? {
    guard isFallthroughStmt else { return nil }
    return FallthroughStmtSyntax(asSyntaxData)
  }

  public var isBreakStmt: Bool { return raw.kind == .breakStmt }
  public var asBreakStmt: BreakStmtSyntax? {
    guard isBreakStmt else { return nil }
    return BreakStmtSyntax(asSyntaxData)
  }

  public var isCaseItemList: Bool { return raw.kind == .caseItemList }
  public var asCaseItemList: CaseItemListSyntax? {
    guard isCaseItemList else { return nil }
    return CaseItemListSyntax(asSyntaxData)
  }

  public var isConditionElement: Bool { return raw.kind == .conditionElement }
  public var asConditionElement: ConditionElementSyntax? {
    guard isConditionElement else { return nil }
    return ConditionElementSyntax(asSyntaxData)
  }

  public var isAvailabilityCondition: Bool { return raw.kind == .availabilityCondition }
  public var asAvailabilityCondition: AvailabilityConditionSyntax? {
    guard isAvailabilityCondition else { return nil }
    return AvailabilityConditionSyntax(asSyntaxData)
  }

  public var isMatchingPatternCondition: Bool { return raw.kind == .matchingPatternCondition }
  public var asMatchingPatternCondition: MatchingPatternConditionSyntax? {
    guard isMatchingPatternCondition else { return nil }
    return MatchingPatternConditionSyntax(asSyntaxData)
  }

  public var isOptionalBindingCondition: Bool { return raw.kind == .optionalBindingCondition }
  public var asOptionalBindingCondition: OptionalBindingConditionSyntax? {
    guard isOptionalBindingCondition else { return nil }
    return OptionalBindingConditionSyntax(asSyntaxData)
  }

  public var isConditionElementList: Bool { return raw.kind == .conditionElementList }
  public var asConditionElementList: ConditionElementListSyntax? {
    guard isConditionElementList else { return nil }
    return ConditionElementListSyntax(asSyntaxData)
  }

  public var isDeclarationStmt: Bool { return raw.kind == .declarationStmt }
  public var asDeclarationStmt: DeclarationStmtSyntax? {
    guard isDeclarationStmt else { return nil }
    return DeclarationStmtSyntax(asSyntaxData)
  }

  public var isThrowStmt: Bool { return raw.kind == .throwStmt }
  public var asThrowStmt: ThrowStmtSyntax? {
    guard isThrowStmt else { return nil }
    return ThrowStmtSyntax(asSyntaxData)
  }

  public var isIfStmt: Bool { return raw.kind == .ifStmt }
  public var asIfStmt: IfStmtSyntax? {
    guard isIfStmt else { return nil }
    return IfStmtSyntax(asSyntaxData)
  }

  public var isElseIfContinuation: Bool { return raw.kind == .elseIfContinuation }
  public var asElseIfContinuation: ElseIfContinuationSyntax? {
    guard isElseIfContinuation else { return nil }
    return ElseIfContinuationSyntax(asSyntaxData)
  }

  public var isElseBlock: Bool { return raw.kind == .elseBlock }
  public var asElseBlock: ElseBlockSyntax? {
    guard isElseBlock else { return nil }
    return ElseBlockSyntax(asSyntaxData)
  }

  public var isSwitchCase: Bool { return raw.kind == .switchCase }
  public var asSwitchCase: SwitchCaseSyntax? {
    guard isSwitchCase else { return nil }
    return SwitchCaseSyntax(asSyntaxData)
  }

  public var isSwitchDefaultLabel: Bool { return raw.kind == .switchDefaultLabel }
  public var asSwitchDefaultLabel: SwitchDefaultLabelSyntax? {
    guard isSwitchDefaultLabel else { return nil }
    return SwitchDefaultLabelSyntax(asSyntaxData)
  }

  public var isCaseItem: Bool { return raw.kind == .caseItem }
  public var asCaseItem: CaseItemSyntax? {
    guard isCaseItem else { return nil }
    return CaseItemSyntax(asSyntaxData)
  }

  public var isSwitchCaseLabel: Bool { return raw.kind == .switchCaseLabel }
  public var asSwitchCaseLabel: SwitchCaseLabelSyntax? {
    guard isSwitchCaseLabel else { return nil }
    return SwitchCaseLabelSyntax(asSyntaxData)
  }

  public var isCatchClause: Bool { return raw.kind == .catchClause }
  public var asCatchClause: CatchClauseSyntax? {
    guard isCatchClause else { return nil }
    return CatchClauseSyntax(asSyntaxData)
  }

  public var isPoundAssertStmt: Bool { return raw.kind == .poundAssertStmt }
  public var asPoundAssertStmt: PoundAssertStmtSyntax? {
    guard isPoundAssertStmt else { return nil }
    return PoundAssertStmtSyntax(asSyntaxData)
  }

  public var isGenericWhereClause: Bool { return raw.kind == .genericWhereClause }
  public var asGenericWhereClause: GenericWhereClauseSyntax? {
    guard isGenericWhereClause else { return nil }
    return GenericWhereClauseSyntax(asSyntaxData)
  }

  public var isGenericRequirementList: Bool { return raw.kind == .genericRequirementList }
  public var asGenericRequirementList: GenericRequirementListSyntax? {
    guard isGenericRequirementList else { return nil }
    return GenericRequirementListSyntax(asSyntaxData)
  }

  public var isGenericRequirement: Bool { return raw.kind == .genericRequirement }
  public var asGenericRequirement: GenericRequirementSyntax? {
    guard isGenericRequirement else { return nil }
    return GenericRequirementSyntax(asSyntaxData)
  }

  public var isSameTypeRequirement: Bool { return raw.kind == .sameTypeRequirement }
  public var asSameTypeRequirement: SameTypeRequirementSyntax? {
    guard isSameTypeRequirement else { return nil }
    return SameTypeRequirementSyntax(asSyntaxData)
  }

  public var isGenericParameterList: Bool { return raw.kind == .genericParameterList }
  public var asGenericParameterList: GenericParameterListSyntax? {
    guard isGenericParameterList else { return nil }
    return GenericParameterListSyntax(asSyntaxData)
  }

  public var isGenericParameter: Bool { return raw.kind == .genericParameter }
  public var asGenericParameter: GenericParameterSyntax? {
    guard isGenericParameter else { return nil }
    return GenericParameterSyntax(asSyntaxData)
  }

  public var isGenericParameterClause: Bool { return raw.kind == .genericParameterClause }
  public var asGenericParameterClause: GenericParameterClauseSyntax? {
    guard isGenericParameterClause else { return nil }
    return GenericParameterClauseSyntax(asSyntaxData)
  }

  public var isConformanceRequirement: Bool { return raw.kind == .conformanceRequirement }
  public var asConformanceRequirement: ConformanceRequirementSyntax? {
    guard isConformanceRequirement else { return nil }
    return ConformanceRequirementSyntax(asSyntaxData)
  }

  public var isSimpleTypeIdentifier: Bool { return raw.kind == .simpleTypeIdentifier }
  public var asSimpleTypeIdentifier: SimpleTypeIdentifierSyntax? {
    guard isSimpleTypeIdentifier else { return nil }
    return SimpleTypeIdentifierSyntax(asSyntaxData)
  }

  public var isMemberTypeIdentifier: Bool { return raw.kind == .memberTypeIdentifier }
  public var asMemberTypeIdentifier: MemberTypeIdentifierSyntax? {
    guard isMemberTypeIdentifier else { return nil }
    return MemberTypeIdentifierSyntax(asSyntaxData)
  }

  public var isClassRestrictionType: Bool { return raw.kind == .classRestrictionType }
  public var asClassRestrictionType: ClassRestrictionTypeSyntax? {
    guard isClassRestrictionType else { return nil }
    return ClassRestrictionTypeSyntax(asSyntaxData)
  }

  public var isArrayType: Bool { return raw.kind == .arrayType }
  public var asArrayType: ArrayTypeSyntax? {
    guard isArrayType else { return nil }
    return ArrayTypeSyntax(asSyntaxData)
  }

  public var isDictionaryType: Bool { return raw.kind == .dictionaryType }
  public var asDictionaryType: DictionaryTypeSyntax? {
    guard isDictionaryType else { return nil }
    return DictionaryTypeSyntax(asSyntaxData)
  }

  public var isMetatypeType: Bool { return raw.kind == .metatypeType }
  public var asMetatypeType: MetatypeTypeSyntax? {
    guard isMetatypeType else { return nil }
    return MetatypeTypeSyntax(asSyntaxData)
  }

  public var isOptionalType: Bool { return raw.kind == .optionalType }
  public var asOptionalType: OptionalTypeSyntax? {
    guard isOptionalType else { return nil }
    return OptionalTypeSyntax(asSyntaxData)
  }

  public var isSomeType: Bool { return raw.kind == .someType }
  public var asSomeType: SomeTypeSyntax? {
    guard isSomeType else { return nil }
    return SomeTypeSyntax(asSyntaxData)
  }

  public var isImplicitlyUnwrappedOptionalType: Bool { return raw.kind == .implicitlyUnwrappedOptionalType }
  public var asImplicitlyUnwrappedOptionalType: ImplicitlyUnwrappedOptionalTypeSyntax? {
    guard isImplicitlyUnwrappedOptionalType else { return nil }
    return ImplicitlyUnwrappedOptionalTypeSyntax(asSyntaxData)
  }

  public var isCompositionTypeElement: Bool { return raw.kind == .compositionTypeElement }
  public var asCompositionTypeElement: CompositionTypeElementSyntax? {
    guard isCompositionTypeElement else { return nil }
    return CompositionTypeElementSyntax(asSyntaxData)
  }

  public var isCompositionTypeElementList: Bool { return raw.kind == .compositionTypeElementList }
  public var asCompositionTypeElementList: CompositionTypeElementListSyntax? {
    guard isCompositionTypeElementList else { return nil }
    return CompositionTypeElementListSyntax(asSyntaxData)
  }

  public var isCompositionType: Bool { return raw.kind == .compositionType }
  public var asCompositionType: CompositionTypeSyntax? {
    guard isCompositionType else { return nil }
    return CompositionTypeSyntax(asSyntaxData)
  }

  public var isTupleTypeElement: Bool { return raw.kind == .tupleTypeElement }
  public var asTupleTypeElement: TupleTypeElementSyntax? {
    guard isTupleTypeElement else { return nil }
    return TupleTypeElementSyntax(asSyntaxData)
  }

  public var isTupleTypeElementList: Bool { return raw.kind == .tupleTypeElementList }
  public var asTupleTypeElementList: TupleTypeElementListSyntax? {
    guard isTupleTypeElementList else { return nil }
    return TupleTypeElementListSyntax(asSyntaxData)
  }

  public var isTupleType: Bool { return raw.kind == .tupleType }
  public var asTupleType: TupleTypeSyntax? {
    guard isTupleType else { return nil }
    return TupleTypeSyntax(asSyntaxData)
  }

  public var isFunctionType: Bool { return raw.kind == .functionType }
  public var asFunctionType: FunctionTypeSyntax? {
    guard isFunctionType else { return nil }
    return FunctionTypeSyntax(asSyntaxData)
  }

  public var isAttributedType: Bool { return raw.kind == .attributedType }
  public var asAttributedType: AttributedTypeSyntax? {
    guard isAttributedType else { return nil }
    return AttributedTypeSyntax(asSyntaxData)
  }

  public var isGenericArgumentList: Bool { return raw.kind == .genericArgumentList }
  public var asGenericArgumentList: GenericArgumentListSyntax? {
    guard isGenericArgumentList else { return nil }
    return GenericArgumentListSyntax(asSyntaxData)
  }

  public var isGenericArgument: Bool { return raw.kind == .genericArgument }
  public var asGenericArgument: GenericArgumentSyntax? {
    guard isGenericArgument else { return nil }
    return GenericArgumentSyntax(asSyntaxData)
  }

  public var isGenericArgumentClause: Bool { return raw.kind == .genericArgumentClause }
  public var asGenericArgumentClause: GenericArgumentClauseSyntax? {
    guard isGenericArgumentClause else { return nil }
    return GenericArgumentClauseSyntax(asSyntaxData)
  }

  public var isTypeAnnotation: Bool { return raw.kind == .typeAnnotation }
  public var asTypeAnnotation: TypeAnnotationSyntax? {
    guard isTypeAnnotation else { return nil }
    return TypeAnnotationSyntax(asSyntaxData)
  }

  public var isEnumCasePattern: Bool { return raw.kind == .enumCasePattern }
  public var asEnumCasePattern: EnumCasePatternSyntax? {
    guard isEnumCasePattern else { return nil }
    return EnumCasePatternSyntax(asSyntaxData)
  }

  public var isIsTypePattern: Bool { return raw.kind == .isTypePattern }
  public var asIsTypePattern: IsTypePatternSyntax? {
    guard isIsTypePattern else { return nil }
    return IsTypePatternSyntax(asSyntaxData)
  }

  public var isOptionalPattern: Bool { return raw.kind == .optionalPattern }
  public var asOptionalPattern: OptionalPatternSyntax? {
    guard isOptionalPattern else { return nil }
    return OptionalPatternSyntax(asSyntaxData)
  }

  public var isIdentifierPattern: Bool { return raw.kind == .identifierPattern }
  public var asIdentifierPattern: IdentifierPatternSyntax? {
    guard isIdentifierPattern else { return nil }
    return IdentifierPatternSyntax(asSyntaxData)
  }

  public var isAsTypePattern: Bool { return raw.kind == .asTypePattern }
  public var asAsTypePattern: AsTypePatternSyntax? {
    guard isAsTypePattern else { return nil }
    return AsTypePatternSyntax(asSyntaxData)
  }

  public var isTuplePattern: Bool { return raw.kind == .tuplePattern }
  public var asTuplePattern: TuplePatternSyntax? {
    guard isTuplePattern else { return nil }
    return TuplePatternSyntax(asSyntaxData)
  }

  public var isWildcardPattern: Bool { return raw.kind == .wildcardPattern }
  public var asWildcardPattern: WildcardPatternSyntax? {
    guard isWildcardPattern else { return nil }
    return WildcardPatternSyntax(asSyntaxData)
  }

  public var isTuplePatternElement: Bool { return raw.kind == .tuplePatternElement }
  public var asTuplePatternElement: TuplePatternElementSyntax? {
    guard isTuplePatternElement else { return nil }
    return TuplePatternElementSyntax(asSyntaxData)
  }

  public var isExpressionPattern: Bool { return raw.kind == .expressionPattern }
  public var asExpressionPattern: ExpressionPatternSyntax? {
    guard isExpressionPattern else { return nil }
    return ExpressionPatternSyntax(asSyntaxData)
  }

  public var isTuplePatternElementList: Bool { return raw.kind == .tuplePatternElementList }
  public var asTuplePatternElementList: TuplePatternElementListSyntax? {
    guard isTuplePatternElementList else { return nil }
    return TuplePatternElementListSyntax(asSyntaxData)
  }

  public var isValueBindingPattern: Bool { return raw.kind == .valueBindingPattern }
  public var asValueBindingPattern: ValueBindingPatternSyntax? {
    guard isValueBindingPattern else { return nil }
    return ValueBindingPatternSyntax(asSyntaxData)
  }

  public var isAvailabilitySpecList: Bool { return raw.kind == .availabilitySpecList }
  public var asAvailabilitySpecList: AvailabilitySpecListSyntax? {
    guard isAvailabilitySpecList else { return nil }
    return AvailabilitySpecListSyntax(asSyntaxData)
  }

  public var isAvailabilityArgument: Bool { return raw.kind == .availabilityArgument }
  public var asAvailabilityArgument: AvailabilityArgumentSyntax? {
    guard isAvailabilityArgument else { return nil }
    return AvailabilityArgumentSyntax(asSyntaxData)
  }

  public var isAvailabilityLabeledArgument: Bool { return raw.kind == .availabilityLabeledArgument }
  public var asAvailabilityLabeledArgument: AvailabilityLabeledArgumentSyntax? {
    guard isAvailabilityLabeledArgument else { return nil }
    return AvailabilityLabeledArgumentSyntax(asSyntaxData)
  }

  public var isAvailabilityVersionRestriction: Bool { return raw.kind == .availabilityVersionRestriction }
  public var asAvailabilityVersionRestriction: AvailabilityVersionRestrictionSyntax? {
    guard isAvailabilityVersionRestriction else { return nil }
    return AvailabilityVersionRestrictionSyntax(asSyntaxData)
  }

  public var isVersionTuple: Bool { return raw.kind == .versionTuple }
  public var asVersionTuple: VersionTupleSyntax? {
    guard isVersionTuple else { return nil }
    return VersionTupleSyntax(asSyntaxData)
  }
}

/// MARK: Convenience methods

extension StructDeclSyntax {
  /// Creates a new StructDeclSyntax with the provided name as its identifier.
  /// - param name: The new struct's name.
  /// - returns: A new StructDeclSyntax with the same fields as the receiver,
  ///            but with the provided identifier.
  func withIdentifier(_ name: String) -> StructDeclSyntax {
    let newToken = SyntaxFactory.makeIdentifier(name,
      leadingTrivia: identifier.leadingTrivia,
      trailingTrivia: identifier.trailingTrivia)
    return withIdentifier(newToken)
  }
}

extension SyntaxParser {
  static func verifyNodeDeclarationHash() -> Bool {
    return String(cString: swiftparse_syntax_structure_versioning_identifier()!) ==
      "1232070026209439384"
  }
}
